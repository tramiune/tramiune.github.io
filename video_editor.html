<!doctype html>
<html lang="vi">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Video Editor</title>
    <style>
        :root{--bd:#e7e7e7;--mut:#666}
        body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
        header{padding:12px 14px;border-bottom:1px solid var(--bd);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
        header b{font-size:14px}
        .mut{color:var(--mut);font-size:12px}
        .k{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;font-size:12px}
        main{padding:14px;display:grid;grid-template-columns:1.2fr 1fr;gap:14px}
        .card{border:1px solid var(--bd);border-radius:14px;overflow:hidden;background:#fff}
        .hd{padding:10px 12px;border-bottom:1px solid var(--bd);font-weight:600;font-size:13px}
        .ct{padding:12px}
        video{width:100%;max-height:70vh;background:#000;border-radius:12px}
        canvas{width:100%;max-height:40vh;border-radius:12px;background:#111;display:block}
        label{display:flex;justify-content:space-between;gap:10px;align-items:center;margin:10px 0;font-size:13px}
        input[type="range"]{width:60%}
        input[type="number"], input[type="password"]{
          width:150px;padding:6px 8px;border:1px solid var(--bd);border-radius:10px
        }
        button,a.btn{
          border:1px solid var(--bd);background:#fff;padding:8px 10px;border-radius:10px;cursor:pointer;
          text-decoration:none;color:inherit;display:inline-flex;gap:6px;align-items:center
        }
        button:hover,a.btn:hover{background:#f5f5f5}
        .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
        .status{white-space:pre-wrap;font-size:12px;color:var(--mut);margin-top:10px}
        hr{border:none;border-top:1px solid var(--bd);margin:14px 0}
        .warn{border:1px solid #f0c1c1;background:#fff6f6;padding:8px 10px;border-radius:12px;font-size:12px;color:#7a2a2a;margin-top:10px}
    </style>
</head>
<body>
<header>
    <b>Video Editor</b>
    <span class="mut" id="info"></span>

    <input id="token" type="password" placeholder="GitHub Token (Contents: write)" style="min-width:260px" />
    <label class="mut" title="L∆∞u token tr√™n m√°y b·∫°n (localStorage)">
        <input id="remember" type="checkbox" />
        remember token
    </label>

    <a class="btn" id="back" href="./browser.html">‚Üê Back</a>
</header>

<main>
    <div class="card">
        <div class="hd">Preview video</div>
        <div class="ct">
            <!-- CORS: crossorigin must be on element -->
            <video id="v" controls playsinline crossorigin="anonymous"></video>

            <div class="row" style="margin-top:10px">
                <button id="seekPrev">‚è™ -0.1s</button>
                <button id="seekNext">‚è© +0.1s</button>
                <span class="mut">Time:</span>
                <span class="k" id="t">0.000</span>
                <span class="mut">/</span>
                <span class="k" id="dur">0.000</span>
            </div>

            <label style="margin-top:12px">
                <span>Scrub (sec)</span>
                <input id="scrub" type="range" min="0" max="0" step="0.033" value="0"/>
                <span class="k" id="scrubVal">0.000</span>
            </label>

            <div class="warn" id="corsNote" style="display:none"></div>
        </div>
    </div>

    <div class="card">
        <div class="hd">Frame ‚Üí webp (replace) + Trim video (lite)</div>
        <div class="ct">
            <div class="mut">Frame preview (canvas):</div>
            <canvas id="c"></canvas>

            <div class="row" style="margin-top:10px">
                <button id="downloadWebp">üì∏ Download .webp</button>
                <button id="downloadPreview">üñºÔ∏è Download _preview.webp</button>
                <button id="replaceWebp">‚úÖ Replace target on GitHub</button>
            </div>

            <div class="mut" style="margin-top:8px">
                Target: <span class="k" id="targetLabel">(none)</span>
            </div>

            <hr/>

            <div class="mut">Trim video (lite, export .webm):</div>
            <label>
                <span>Trim start (sec)</span>
                <input id="start" type="number" min="0" step="0.1" value="0"/>
            </label>
            <label>
                <span>Trim end (sec)</span>
                <input id="end" type="number" min="0" step="0.1" value="0"/>
            </label>
            <label>
                <span>Speed</span>
                <input id="speed" type="range" min="0.5" max="2" step="0.1" value="1"/>
                <span class="k" id="speedVal">1.0x</span>
            </label>

            <div class="row" style="margin-top:10px">
                <button id="apply">Apply speed to preview</button>
                <button id="exportTrim">‚úÇÔ∏è Export trimmed</button>
            </div>

            <div class="status" id="status"></div>
        </div>
    </div>
</main>

<script>
    /** Repo config */
    const OWNER = "tramiune";
    const REPO  = "tramiune001_res_wallpaper";
    const BRANCH = "main";          // ƒë·ªïi n·∫øu repo b·∫°n l√† master
    const ROOT_DIR = "resources";
    const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

    const v = document.getElementById("v");
    const c = document.getElementById("c");
    const ctx = c.getContext("2d", { willReadFrequently: false });

    const info = document.getElementById("info");
    const statusEl = document.getElementById("status");
    const corsNote = document.getElementById("corsNote");
    const tEl = document.getElementById("t");
    const durEl = document.getElementById("dur");
    const scrub = document.getElementById("scrub");
    const scrubVal = document.getElementById("scrubVal");
    const targetLabel = document.getElementById("targetLabel");

    const startEl = document.getElementById("start");
    const endEl = document.getElementById("end");
    const speedEl = document.getElementById("speed");
    const speedVal = document.getElementById("speedVal");

    const tokenEl = document.getElementById("token");
    const rememberEl = document.getElementById("remember");

    function setStatus(s){ statusEl.textContent = s || ""; }
    function setWarn(s){
      if (!s) { corsNote.style.display = "none"; corsNote.textContent = ""; return; }
      corsNote.style.display = "block";
      corsNote.textContent = s;
    }

    function qs() {
      const p = new URLSearchParams(location.search);
      return {
        mode: p.get("mode") || "edit",        // edit | replaceImage
        folder: p.get("folder") || "",
        video: p.get("video") || "",
        target: p.get("target") || ""
      };
    }

    function mediaUrlCdn(folder, file){ return `${CDN_BASE}${folder}/${file}`; }
    function baseName(file){
      const i = file.lastIndexOf(".");
      return i >= 0 ? file.slice(0, i) : file;
    }
    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 5000);
    }

    function drawFrameToCanvas(){
      if (!v.videoWidth || !v.videoHeight) return;
      c.width = v.videoWidth;
      c.height = v.videoHeight;
      ctx.drawImage(v, 0, 0, c.width, c.height);
    }

    async function seekTo(time){
      const t = Math.max(0, Math.min(time, v.duration || 0));
      v.pause();
      v.currentTime = t;

      await new Promise(resolve => v.addEventListener("seeked", resolve, { once:true }));
      drawFrameToCanvas();
      updateUI();
    }

    function updateUI(){
      const ct = v.currentTime || 0;
      tEl.textContent = ct.toFixed(3);
      scrubVal.textContent = ct.toFixed(3);
      scrub.value = String(ct);
    }

    /** ---------- token share with browser ---------- */
    const LS_KEY = `wallpaper_browser_token_${OWNER}_${REPO}`;
    (function initRememberToken(){
      const saved = localStorage.getItem(LS_KEY);
      if (saved) {
        tokenEl.value = saved;
        rememberEl.checked = true;
      }
      rememberEl.addEventListener("change", () => {
        if (rememberEl.checked) {
          if (tokenEl.value.trim()) localStorage.setItem(LS_KEY, tokenEl.value.trim());
        } else {
          localStorage.removeItem(LS_KEY);
        }
      });
      tokenEl.addEventListener("input", () => {
        if (rememberEl.checked) localStorage.setItem(LS_KEY, tokenEl.value.trim());
      });
    })();

    function getAuthToken() {
      const t = (tokenEl?.value || "").trim();
      if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (Contents: write).");
      return t;
    }
    function encodePath(path) {
      return path.split("/").map(encodeURIComponent).join("/");
    }
    async function ghGetJson(url, token) {
      const res = await fetch(url, {
        headers: { "Authorization": `Bearer ${token}`, "Accept": "application/vnd.github+json" }
      });
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`HTTP ${res.status}\n${txt}`);
      }
      return res.json();
    }
    async function ghPutJson(url, token, body) {
      const res = await fetch(url, {
        method: "PUT",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`HTTP ${res.status}\n${txt}`);
      }
      return res.json();
    }
    async function getFileSha(filePath, token) {
      const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}?ref=${encodeURIComponent(BRANCH)}`;
      const j = await ghGetJson(url, token);
      if (!j?.sha) throw new Error("Kh√¥ng l·∫•y ƒë∆∞·ª£c sha c·ªßa file.");
      return j.sha;
    }
    async function blobToBase64NoPrefix(blob) {
      const dataUrl = await new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = reject;
        r.readAsDataURL(blob);
      });
      return String(dataUrl).split(",")[1];
    }

    /** ‚úÖ Replace target webp on GitHub */
    async function replaceWebpOnGitHub(folder, targetFileName, webpBlob) {
      const token = getAuthToken();
      const filePath = `${ROOT_DIR}/${folder}/${targetFileName}`;

      setStatus(`Uploading...\n‚Üí ${filePath}`);

      const sha = await getFileSha(filePath, token);
      const content = await blobToBase64NoPrefix(webpBlob);

      await ghPutJson(
        `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`,
        token,
        { message: `Update ${filePath}`, content, sha, branch: BRANCH }
      );

      setStatus(`‚úÖ Replaced on GitHub\n${filePath}`);
    }

    /** ‚úÖ Load video as Blob via GitHub API (no CORS/taint) */
    async function loadVideoViaGitHubApi(folder, fileName) {
      const token = getAuthToken();
      const filePath = `${ROOT_DIR}/${folder}/${fileName}`;
      const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}?ref=${encodeURIComponent(BRANCH)}`;

      setStatus(`Fetching video via GitHub API...\n${filePath}`);

      const meta = await ghGetJson(url, token);
      if (!meta?.download_url) throw new Error("Kh√¥ng c√≥ download_url (file private?)");

      // download_url l√† public raw, v·∫´n c√≥ th·ªÉ CORS; nh∆∞ng ta fetch th√†nh blob t·∫°i origin c·ªßa page ‚Üí canvas OK
      const res = await fetch(meta.download_url);
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`Download video failed: HTTP ${res.status}\n${txt}`);
      }
      const blob = await res.blob();
      const blobUrl = URL.createObjectURL(blob);

      setStatus("");
      return blobUrl;
    }

    /** ---------- UI actions ---------- */
    speedEl.addEventListener("input", ()=> speedVal.textContent = `${Number(speedEl.value).toFixed(1)}x`);
    document.getElementById("apply").onclick = ()=> { v.playbackRate = Number(speedEl.value) || 1; };

    document.getElementById("seekPrev").onclick = ()=> seekTo((v.currentTime||0) - 0.1);
    document.getElementById("seekNext").onclick = ()=> seekTo((v.currentTime||0) + 0.1);

    scrub.addEventListener("input", ()=> { scrubVal.textContent = Number(scrub.value).toFixed(3); });
    scrub.addEventListener("change", ()=> seekTo(Number(scrub.value) || 0));

    async function canvasToWebpBlob(quality) {
      drawFrameToCanvas();
      try {
        const blob = await new Promise(resolve => c.toBlob(resolve, "image/webp", quality));
        if (!blob) throw new Error("toBlob failed (webp not supported?)");
        return blob;
      } catch (e) {
        // tainted canvas message
        throw new Error(`toBlob failed: ${String(e?.message || e)}\n\nFix: load video via GitHub API (token) ƒë·ªÉ tr√°nh CORS taint.`);
      }
    }

    document.getElementById("downloadWebp").onclick = async () => {
      try {
        const { video } = qs();
        const out = `${baseName(video)}.webp`;
        setStatus(`Capturing frame...\n‚Üí ${out}`);
        const blob = await canvasToWebpBlob(0.92);
        downloadBlob(blob, out);
        setStatus(`‚úÖ Saved\n${out}`);
      } catch (e) {
        alert(String(e?.message || e));
      }
    };

    document.getElementById("downloadPreview").onclick = async () => {
      try {
        const { video } = qs();
        const out = `${baseName(video)}_preview.webp`;

        // scale nh·ªè ƒë·ªÉ l√†m preview
        drawFrameToCanvas();
        const targetW = 360;
        const scale = targetW / c.width;
        const w = Math.max(1, Math.round(c.width * scale));
        const h = Math.max(1, Math.round(c.height * scale));

        const tmp = document.createElement("canvas");
        tmp.width = w; tmp.height = h;
        tmp.getContext("2d").drawImage(c, 0, 0, w, h);

        setStatus(`Capturing preview...\n‚Üí ${out}`);
        const blob = await new Promise(resolve => tmp.toBlob(resolve, "image/webp", 0.85));
        if (!blob) throw new Error("toBlob failed (webp not supported?)");
        downloadBlob(blob, out);
        setStatus(`‚úÖ Saved\n${out}`);
      } catch (e) {
        alert(String(e?.message || e));
      }
    };

    document.getElementById("replaceWebp").onclick = async () => {
      try {
        const { mode, folder, target } = qs();
        if (mode !== "replaceImage") throw new Error("Replace ch·ªâ d√πng khi m·ªü t·ª´ n√∫t Update (mode=replaceImage).");
        if (!folder || !target) throw new Error("Thi·∫øu folder/target.");

        const blob = await canvasToWebpBlob(0.92);
        await replaceWebpOnGitHub(folder, target, blob);

        // optional: t·ª± reload trang opener
        try { window.opener?.location?.reload?.(); } catch {}
      } catch (e) {
        alert(String(e?.message || e));
      }
    };

    /** ---------- Trim (lite) export .webm (no-audio) ---------- */
    async function exportTrimWebm(){
      const { video } = qs();

      const start = Math.max(0, Number(startEl.value) || 0);
      const endIn = Math.max(0, Number(endEl.value) || 0);
      const rate = Number(speedEl.value) || 1;

      if (!v.duration || Number.isNaN(v.duration)) throw new Error("Video ch∆∞a load xong.");
      const end = (endIn <= 0 || endIn > v.duration) ? v.duration : endIn;
      if (end <= start) throw new Error("Trim end ph·∫£i > trim start.");

      const out = `${baseName(video)}_trim_${start.toFixed(1)}_${end.toFixed(1)}.webm`;

      setStatus(`Exporting trim (lite)...\nstart=${start}s end=${end}s speed=${rate}x\n‚Üí ${out}\n\nNote: output webm, no-audio (lite mode)`);

      drawFrameToCanvas();
      const stream = c.captureStream(30);
      const mime = MediaRecorder.isTypeSupported("video/webm;codecs=vp9")
        ? "video/webm;codecs=vp9"
        : "video/webm;codecs=vp8";

      const rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 6_000_000 });
      const chunks = [];
      rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };

      let rafId = 0;
      const drawLoop = () => { drawFrameToCanvas(); rafId = requestAnimationFrame(drawLoop); };

      v.pause();
      v.currentTime = start;
      v.playbackRate = rate;
      v.muted = true;

      await new Promise(resolve => v.addEventListener("seeked", resolve, { once:true }));

      await v.play();
      rec.start(500);
      drawLoop();

      const stopAll = async () => {
        cancelAnimationFrame(rafId);
        rec.stop();
        v.pause();
      };

      const tick = () => {
        if ((v.currentTime || 0) >= end) stopAll();
        else requestAnimationFrame(tick);
      };
      tick();

      await new Promise(resolve => rec.onstop = resolve);

      const blob = new Blob(chunks, { type: mime });
      downloadBlob(blob, out);

      setStatus(`‚úÖ Export done\n${out}`);
    }

    document.getElementById("exportTrim").onclick = async () => {
      try { await exportTrimWebm(); }
      catch(e){ alert(String(e?.message || e)); }
    };

    /** ---------- init ---------- */
    (async function init(){
      const { mode, folder, video, target } = qs();
      if (!folder || !video) {
        info.textContent = "Thi·∫øu query ?folder=...&video=...";
        setStatus("M·ªü t·ª´ browser.html b·∫±ng n√∫t Edit / Update ƒë·ªÉ t·ª± fill query.");
        return;
      }

      info.textContent = `${folder}/${video} ¬∑ mode=${mode}`;
      targetLabel.textContent = target ? target : "(none)";

      // MUST set crossOrigin before src
      v.crossOrigin = "anonymous";

      // Strategy:
      // - replaceImage: lu√¥n d√πng GitHub API (blob url) ƒë·ªÉ tr√°nh tainted canvas
      // - edit: n·∫øu c√≥ token th√¨ c≈©ng d√πng API cho ch·∫Øc; n·∫øu kh√¥ng th√¨ d√πng CDN
      try {
        let src;
        if (mode === "replaceImage") {
          setWarn("Mode replaceImage: video s·∫Ω ƒë∆∞·ª£c t·∫£i qua GitHub API (token) ƒë·ªÉ tr√°nh l·ªói CORS tainted canvas.");
          src = await loadVideoViaGitHubApi(folder, video);
        } else {
          const hasToken = !!(tokenEl.value || "").trim();
          if (hasToken) {
            setWarn("C√≥ token: d√πng GitHub API (blob) ƒë·ªÉ tr√°nh CORS taint khi export frame.");
            src = await loadVideoViaGitHubApi(folder, video);
          } else {
            setWarn("Kh√¥ng c√≥ token: d√πng CDN. N·∫øu b·∫°n export frame b·ªã l·ªói 'Tainted canvas', h√£y nh·∫≠p token ƒë·ªÉ t·∫£i video qua GitHub API.");
            src = mediaUrlCdn(folder, video);
          }
        }

        v.src = src;
      } catch (e) {
        setWarn(String(e?.message || e));
        // fallback CDN (ch·ªâ ƒë·ªÉ xem)
        v.src = mediaUrlCdn(folder, video);
      }

      v.addEventListener("loadedmetadata", async () => {
        durEl.textContent = (v.duration || 0).toFixed(3);
        scrub.max = String(v.duration || 0);
        startEl.value = "0";
        endEl.value = (v.duration || 0).toFixed(1);
        speedEl.value = "1";
        speedVal.textContent = "1.0x";
        await seekTo(0);
      });

      v.addEventListener("timeupdate", () => {
        if (!v.paused) updateUI();
      });
    })();
</script>
</body>
</html>
