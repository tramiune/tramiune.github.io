<!doctype html>
<html lang="vi">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Video Editor</title>
    <style>
        :root{--bd:#e7e7e7;--mut:#666}
        body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
        header{padding:12px 14px;border-bottom:1px solid var(--bd);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
        header b{font-size:14px}
        .mut{color:var(--mut);font-size:12px}
        .k{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;font-size:12px}
        main{padding:14px;display:grid;grid-template-columns:1.2fr 1fr;gap:14px}
        .card{border:1px solid var(--bd);border-radius:14px;overflow:hidden;background:#fff}
        .hd{padding:10px 12px;border-bottom:1px solid var(--bd);font-weight:600;font-size:13px}
        .ct{padding:12px}
        video{width:100%;max-height:70vh;background:#000;border-radius:12px}
        canvas{width:100%;max-height:40vh;border-radius:12px;background:#111;display:block}
        label{display:flex;justify-content:space-between;gap:10px;align-items:center;margin:10px 0;font-size:13px}
        input[type="range"]{width:60%}
        input[type="number"], input[type="password"], select{
          width:180px;padding:6px 8px;border:1px solid var(--bd);border-radius:10px
        }
        button,a.btn{
          border:1px solid var(--bd);background:#fff;padding:8px 10px;border-radius:10px;cursor:pointer;
          text-decoration:none;color:inherit;display:inline-flex;gap:6px;align-items:center
        }
        button:hover,a.btn:hover{background:#f5f5f5}
        .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
        .status{white-space:pre-wrap;font-size:12px;color:var(--mut);margin-top:10px}
        hr{border:none;border-top:1px solid var(--bd);margin:14px 0}
        .warn{border:1px solid #f0c1c1;background:#fff6f6;padding:8px 10px;border-radius:12px;font-size:12px;color:#7a2a2a;margin-top:10px}
        .ok{border:1px solid #bfe6c8;background:#f3fff6;padding:8px 10px;border-radius:12px;font-size:12px;color:#1f5a2d;margin-top:10px}
        .chip{display:inline-flex;gap:6px;align-items:center;border:1px solid var(--bd);background:#fafafa;border-radius:999px;padding:2px 10px;font-size:12px}
    </style>
</head>
<body>
<header>
    <b>Video Editor</b>
    <span class="mut" id="info"></span>

    <input id="token" type="password" placeholder="GitHub Token (repo + workflow + contents)" style="min-width:320px" />
    <label class="mut" title="L∆∞u token tr√™n m√°y b·∫°n (localStorage)">
        <input id="remember" type="checkbox" />
        remember token
    </label>

    <a class="btn" id="back" href="./browser.html">‚Üê Back</a>
</header>

<main>
    <div class="card">
        <div class="hd">Preview video</div>
        <div class="ct">
            <div class="row" style="justify-content:space-between;margin-bottom:10px">
                <span class="chip" id="srcChip">source: (loading)</span>
                <a class="btn" id="openCdn" href="#" target="_blank" rel="noreferrer">üîó Open CDN</a>
            </div>

            <video id="v" controls playsinline></video>

            <div class="row" style="margin-top:10px">
                <button id="seekPrev">‚è™ -0.1s</button>
                <button id="seekNext">‚è© +0.1s</button>
                <span class="mut">Time:</span>
                <span class="k" id="t">0.000</span>
                <span class="mut">/</span>
                <span class="k" id="dur">0.000</span>
            </div>

            <label style="margin-top:12px">
                <span>Scrub (sec)</span>
                <input id="scrub" type="range" min="0" max="0" step="0.033" value="0"/>
                <span class="k" id="scrubVal">0.000</span>
            </label>

            <label>
                <span>Playback speed (preview only)</span>
                <input id="speed" type="range" min="0.5" max="2" step="0.1" value="1"/>
                <span class="k" id="speedVal">1.0x</span>
            </label>

            <div class="row" style="margin-top:10px">
                <button id="applySpeed">Apply speed to preview</button>
            </div>

            <div class="warn" id="note" style="display:none"></div>
            <div class="ok" id="ok" style="display:none"></div>
        </div>
    </div>

    <div class="card">
        <div class="hd">Frame ‚Üí webp (replace) + Trim MP4 (replace via GitHub Actions)</div>
        <div class="ct">
            <div class="mut">Frame preview (canvas):</div>
            <canvas id="c"></canvas>

            <div class="row" style="margin-top:10px">
                <button id="downloadWebp">üì∏ Download .webp</button>
                <button id="downloadPreview">üñºÔ∏è Download _preview.webp</button>
                <button id="replaceWebp">‚úÖ Replace target .webp on GitHub</button>
            </div>

            <div class="mut" style="margin-top:8px">
                Target: <span class="k" id="targetLabel">(none)</span>
            </div>

            <hr/>

            <div class="mut">Trim video (GI·ªÆ √ÇM THANH) ‚Äî ch·∫°y tr√™n GitHub Actions (kh√¥ng ‚Äúbad memory‚Äù):</div>

            <label>
                <span>Trim start (sec)</span>
                <input id="start" type="number" min="0" step="0.1" value="0"/>
            </label>
            <label>
                <span>Trim end (sec)</span>
                <input id="end" type="number" min="0" step="0.1" value="0"/>
            </label>

            <label>
                <span>Mode</span>
                <select id="trimMode">
                    <option value="FAST">FAST (copy stream, nhanh, gi·ªØ audio)</option>
                    <option value="PRECISE">PRECISE (re-encode, n·∫∑ng h∆°n)</option>
                </select>
            </label>

            <div class="row" style="margin-top:10px">
                <button id="dispatchTrim">üöÄ Trim & Replace MP4 (GitHub Actions)</button>
                <a class="btn" id="openActions" href="#" target="_blank" rel="noreferrer">üìã Open Actions</a>
            </div>

            <div class="warn" style="margin-top:10px">
                ‚úÖ C√°ch n√†y KH√îNG d√πng FFmpeg wasm n√™n kh√¥ng c√≤n l·ªói <b>bad memory</b>.<br/>
                Workflow s·∫Ω <b>commit & push</b> ƒë√® file MP4 trong repo: resources/&lt;folder&gt;/&lt;video&gt;<br/>
                Token c·∫ßn scope: <b>workflow</b> + <b>repo</b>.
            </div>

            <div class="status" id="status"></div>
        </div>
    </div>
</main>

<script>
    /** =========================
     *  CONFIG ‚Äì s·ª≠a ·ªü ƒë√¢y
     *  ========================= */
    const OWNER = "tramiune";
    const REPO  = "tramiune001_res_wallpaper";
    const BRANCH = "main";
    const ROOT_DIR = "resources";
    const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

    // workflow file name in .github/workflows/
    const TRIM_WORKFLOW_FILE = "trim.yml";
    /** ========================= */

    const v = document.getElementById("v");
    const c = document.getElementById("c");
    const ctx = c.getContext("2d");

    const info = document.getElementById("info");
    const noteEl = document.getElementById("note");
    const okEl = document.getElementById("ok");
    const statusEl = document.getElementById("status");
    const tEl = document.getElementById("t");
    const durEl = document.getElementById("dur");
    const scrub = document.getElementById("scrub");
    const scrubVal = document.getElementById("scrubVal");
    const targetLabel = document.getElementById("targetLabel");

    const startEl = document.getElementById("start");
    const endEl = document.getElementById("end");
    const speedEl = document.getElementById("speed");
    const speedVal = document.getElementById("speedVal");
    const trimModeEl = document.getElementById("trimMode");

    const tokenEl = document.getElementById("token");
    const rememberEl = document.getElementById("remember");

    const srcChip = document.getElementById("srcChip");
    const openCdn = document.getElementById("openCdn");
    const openActions = document.getElementById("openActions");

    function setStatus(s){ statusEl.textContent = s || ""; }
    function setNote(s){
      if (!s){ noteEl.style.display="none"; noteEl.textContent=""; return; }
      noteEl.style.display="block"; noteEl.textContent=s;
    }
    function setOk(s){
      if (!s){ okEl.style.display="none"; okEl.textContent=""; return; }
      okEl.style.display="block"; okEl.textContent=s;
    }

    function qs() {
      const p = new URLSearchParams(location.search);
      return {
        mode: p.get("mode") || "edit",        // edit | replaceImage
        folder: p.get("folder") || "",
        video: p.get("video") || "",
        target: p.get("target") || ""
      };
    }

    function encodePath(path) { return path.split("/").map(encodeURIComponent).join("/"); }
    function mediaUrlCdn(folder, file){ return `${CDN_BASE}${folder}/${file}`; }
    function baseName(file){
      const i = file.lastIndexOf(".");
      return i >= 0 ? file.slice(0, i) : file;
    }
    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 5000);
    }

    function getAuthToken() {
      const t = (tokenEl?.value || "").trim();
      if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (repo + workflow + contents).");
      return t;
    }

    /** token localStorage share (same key as browser.html) */
    const LS_KEY = `wallpaper_browser_token_${OWNER}_${REPO}`;
    (function initRememberToken(){
      const saved = localStorage.getItem(LS_KEY);
      if (saved) { tokenEl.value = saved; rememberEl.checked = true; }
      rememberEl.addEventListener("change", () => {
        if (rememberEl.checked) {
          if (tokenEl.value.trim()) localStorage.setItem(LS_KEY, tokenEl.value.trim());
        } else localStorage.removeItem(LS_KEY);
      });
      tokenEl.addEventListener("input", () => {
        if (rememberEl.checked) localStorage.setItem(LS_KEY, tokenEl.value.trim());
      });
    })();

    /** ========= GitHub API helpers ========= */
    async function ghGetJson(url, token) {
      const res = await fetch(url, {
        headers: { "Authorization": `Bearer ${token}`, "Accept": "application/vnd.github+json" }
      });
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`HTTP ${res.status}\n${txt}`);
      }
      return res.json();
    }

    async function ghPutJson(url, token, body) {
      const res = await fetch(url, {
        method: "PUT",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`HTTP ${res.status}\n${txt}`);
      }
      return res.json();
    }

    async function getFileSha(filePath, token) {
      const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}?ref=${encodeURIComponent(BRANCH)}`;
      const j = await ghGetJson(url, token);
      if (!j?.sha) throw new Error("Kh√¥ng l·∫•y ƒë∆∞·ª£c sha c·ªßa file.");
      return j.sha;
    }

    async function blobToBase64NoPrefix(blob) {
      const dataUrl = await new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = reject;
        r.readAsDataURL(blob);
      });
      return String(dataUrl).split(",")[1];
    }

    /** ========= Load video as Blob (avoid tainted canvas) ========= */
    let gVideoBlob = null;
    let gVideoBlobUrl = null;

    async function fetchVideoBlobOnce(folder, fileName) {
      if (gVideoBlob) return gVideoBlob;
      const token = getAuthToken();
      const filePath = `${ROOT_DIR}/${folder}/${fileName}`;
      const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}?ref=${encodeURIComponent(BRANCH)}`;

      setStatus(`Fetching video (blob, once)...\n${filePath}`);
      const meta = await ghGetJson(url, token);
      if (!meta?.download_url) throw new Error("Kh√¥ng c√≥ download_url.");

      const res = await fetch(meta.download_url);
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`Download failed: HTTP ${res.status}\n${txt}`);
      }
      gVideoBlob = await res.blob();
      setStatus(`‚úÖ Downloaded for preview\nsize=${Math.round(gVideoBlob.size/1024/1024)}MB`);
      return gVideoBlob;
    }

    function setVideoSrcFromBlob(blob) {
      try { if (gVideoBlobUrl) URL.revokeObjectURL(gVideoBlobUrl); } catch {}
      gVideoBlobUrl = URL.createObjectURL(blob);
      v.src = gVideoBlobUrl;
    }

    function drawFrameToCanvas(){
      if (!v.videoWidth || !v.videoHeight) return;
      c.width = v.videoWidth;
      c.height = v.videoHeight;
      ctx.drawImage(v, 0, 0, c.width, c.height);
    }

    async function seekTo(time){
      const t = Math.max(0, Math.min(time, v.duration || 0));
      v.pause();
      v.currentTime = t;
      await new Promise(resolve => v.addEventListener("seeked", resolve, { once:true }));
      drawFrameToCanvas();
      updateUI();
    }

    function updateUI(){
      const ct = v.currentTime || 0;
      tEl.textContent = ct.toFixed(3);
      scrubVal.textContent = ct.toFixed(3);
      scrub.value = String(ct);
    }

    /** ========= Canvas -> WebP ========= */
    async function canvasToWebpBlob(quality) {
      drawFrameToCanvas();
      const blob = await new Promise(resolve => c.toBlob(resolve, "image/webp", quality));
      if (!blob) throw new Error("toBlob failed (webp not supported?)");
      return blob;
    }

    /** Replace target webp on GitHub */
    async function replaceWebpOnGitHub(folder, targetFileName, webpBlob) {
      const token = getAuthToken();
      const filePath = `${ROOT_DIR}/${folder}/${targetFileName}`;
      setStatus(`Uploading...\n‚Üí ${filePath}`);
      const sha = await getFileSha(filePath, token);
      const content = await blobToBase64NoPrefix(webpBlob);

      await ghPutJson(
        `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`,
        token,
        { message: `Update ${filePath}`, content, sha, branch: BRANCH }
      );
      setStatus(`‚úÖ Replaced on GitHub\n${filePath}`);
    }

    /** ========= Trim via GitHub Actions ========= */
    async function dispatchTrimAction(folder, video, start, end, mode) {
      const token = getAuthToken();
      const url = `https://api.github.com/repos/${OWNER}/${REPO}/actions/workflows/${encodeURIComponent(TRIM_WORKFLOW_FILE)}/dispatches`;

      const res = await fetch(url, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          ref: BRANCH,
          inputs: {
            folder: String(folder),
            video: String(video),
            start: String(start),
            end: String(end),
            mode: String(mode || "FAST")
          }
        })
      });

      // GitHub tr·∫£ 204 No Content khi OK
      if (!(res.status === 204 || res.ok)) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`Dispatch failed: HTTP ${res.status}\n${txt}`);
      }
    }

    /** ========= UI wiring ========= */
    speedEl.addEventListener("input", ()=> speedVal.textContent = `${Number(speedEl.value).toFixed(1)}x`);
    document.getElementById("applySpeed").onclick = ()=> { v.playbackRate = Number(speedEl.value) || 1; };

    document.getElementById("seekPrev").onclick = ()=> seekTo((v.currentTime||0) - 0.1);
    document.getElementById("seekNext").onclick = ()=> seekTo((v.currentTime||0) + 0.1);

    scrub.addEventListener("input", ()=> { scrubVal.textContent = Number(scrub.value).toFixed(3); });
    scrub.addEventListener("change", ()=> seekTo(Number(scrub.value) || 0));

    document.getElementById("downloadWebp").onclick = async () => {
      try {
        setOk("");
        const { video } = qs();
        const out = `${baseName(video)}.webp`;
        setStatus(`Capturing frame...\n‚Üí ${out}`);
        const blob = await canvasToWebpBlob(0.92);
        downloadBlob(blob, out);
        setStatus(`‚úÖ Saved\n${out}`);
      } catch (e) { alert(String(e?.message || e)); }
    };

    document.getElementById("downloadPreview").onclick = async () => {
      try {
        setOk("");
        const { video } = qs();
        const out = `${baseName(video)}_preview.webp`;

        drawFrameToCanvas();
        const targetW = 360;
        const scale = targetW / c.width;
        const w = Math.max(1, Math.round(c.width * scale));
        const h = Math.max(1, Math.round(c.height * scale));

        const tmp = document.createElement("canvas");
        tmp.width = w; tmp.height = h;
        tmp.getContext("2d").drawImage(c, 0, 0, w, h);

        setStatus(`Capturing preview...\n‚Üí ${out}`);
        const blob = await new Promise(resolve => tmp.toBlob(resolve, "image/webp", 0.85));
        if (!blob) throw new Error("toBlob failed");
        downloadBlob(blob, out);
        setStatus(`‚úÖ Saved\n${out}`);
      } catch (e) { alert(String(e?.message || e)); }
    };

    document.getElementById("replaceWebp").onclick = async () => {
      try {
        setOk("");
        const { mode, folder, target } = qs();
        if (mode !== "replaceImage") throw new Error("Replace ch·ªâ d√πng khi m·ªü t·ª´ n√∫t Update (mode=replaceImage).");
        if (!folder || !target) throw new Error("Thi·∫øu folder/target.");
        const blob = await canvasToWebpBlob(0.92);
        await replaceWebpOnGitHub(folder, target, blob);
        setOk("‚úÖ ƒê√£ replace .webp tr√™n GitHub. B·∫°n c√≥ th·ªÉ quay l·∫°i browser ƒë·ªÉ xem.");
        try { window.opener?.location?.reload?.(); } catch {}
      } catch (e) { alert(String(e?.message || e)); }
    };

    document.getElementById("dispatchTrim").onclick = async () => {
      try {
        setOk("");
        const { folder, video } = qs();
        if (!folder || !video) throw new Error("Thi·∫øu folder/video.");

        if (!v.duration || Number.isNaN(v.duration)) throw new Error("Video ch∆∞a load xong.");

        const start = Math.max(0, Number(startEl.value) || 0);
        const endIn = Math.max(0, Number(endEl.value) || 0);
        const end = (endIn <= 0 || endIn > v.duration) ? v.duration : endIn;
        if (end <= start) throw new Error("Trim end ph·∫£i > trim start.");

        const mode = trimModeEl.value || "FAST";
        const ok = confirm(
          `Trim & REPLACE MP4 b·∫±ng GitHub Actions?\n\n` +
          `folder: ${folder}\nvideo: ${video}\nstart: ${start}\nend: ${end}\nmode: ${mode}\n\n` +
          `Workflow s·∫Ω commit/push ƒë√® file MP4.`
        );
        if (!ok) return;

        setStatus(
          `Dispatching GitHub Actions...\n` +
          `folder=${folder}\nvideo=${video}\nstart=${start}\nend=${end}\nmode=${mode}\n`
        );
        await dispatchTrimAction(folder, video, start, end, mode);

        setStatus("");
        setOk(
          "‚úÖ ƒê√£ trigger workflow.\n" +
          "Gi·ªù m·ªü Actions ƒë·ªÉ xem progress.\n" +
          "Sau khi workflow xong, quay l·∫°i browser v√† reload l√† MP4 ƒë√£ ƒë∆∞·ª£c thay."
        );

        // m·ªü actions page cho nhanh
        try { window.open(openActions.href, "_blank", "noopener,noreferrer"); } catch {}
      } catch (e) {
        alert(String(e?.message || e));
      }
    };

    /** init */
    (async function init(){
      const { mode, folder, video, target } = qs();

      if (!folder || !video) {
        info.textContent = "Thi·∫øu query ?folder=...&video=...";
        setStatus("M·ªü t·ª´ browser.html b·∫±ng n√∫t Edit / Update ƒë·ªÉ t·ª± fill query.");
        document.getElementById("replaceWebp").disabled = true;
        document.getElementById("dispatchTrim").disabled = true;
        return;
      }

      info.textContent = `${folder}/${video} ¬∑ mode=${mode}`;
      targetLabel.textContent = target ? target : "(none)";

      // actions link
      openActions.href = `https://github.com/${OWNER}/${REPO}/actions?query=workflow%3A${encodeURIComponent(TRIM_WORKFLOW_FILE)}`;

      // open cdn
      openCdn.href = mediaUrlCdn(folder, video);

      // Replace webp button enable/disable
      const replaceBtn = document.getElementById("replaceWebp");
      if (mode !== "replaceImage" || !target) {
        replaceBtn.disabled = true;
        replaceBtn.title = "Ch·ªâ d√πng khi m·ªü t·ª´ n√∫t Update (mode=replaceImage&target=...)";
      }

      // Prefer blob preview (avoid taint): require token
      const hasToken = !!(tokenEl.value || "").trim();
      const cdnUrl = mediaUrlCdn(folder, video);

      srcChip.textContent = "source: blob (GitHub API) preferred";
      setOk("");
      setNote("");

      if (hasToken) {
        setNote("C√≥ token: t·∫£i video d·∫°ng blob qua GitHub API ƒë·ªÉ tr√°nh CORS/taint (export webp OK).");
        try {
          const blob = await fetchVideoBlobOnce(folder, video);
          setVideoSrcFromBlob(blob);
          srcChip.textContent = "source: blob (GitHub API)";
        } catch (e) {
          setNote("Kh√¥ng t·∫£i blob ƒë∆∞·ª£c, fallback sang CDN. (N·∫øu export webp b·ªã l·ªói taint th√¨ ph·∫£i d√πng token/blob)\n\n" + String(e?.message || e));
          v.src = cdnUrl;
          srcChip.textContent = "source: CDN (fallback)";
        }
      } else {
        setNote("Kh√¥ng c√≥ token: xem b·∫±ng CDN. N·∫øu export webp b·ªã l·ªói taint/CORS th√¨ nh·∫≠p token ƒë·ªÉ load blob.");
        v.src = cdnUrl;
        srcChip.textContent = "source: CDN";
      }

      v.addEventListener("loadedmetadata", async () => {
        durEl.textContent = (v.duration || 0).toFixed(3);
        scrub.max = String(v.duration || 0);
        startEl.value = "0";
        endEl.value = (v.duration || 0).toFixed(1);
        speedEl.value = "1";
        speedVal.textContent = "1.0x";
        trimModeEl.value = "FAST";
        await seekTo(0);
      });

      v.addEventListener("timeupdate", () => {
        if (!v.paused) updateUI();
      });

      // If user pastes token after load, allow them to reload as blob by refreshing page (simple).
      tokenEl.addEventListener("change", () => {
        setNote("N·∫øu b·∫°n v·ª´a nh·∫≠p token, h√£y refresh trang ƒë·ªÉ load video qua blob (export webp ·ªïn ƒë·ªãnh h∆°n).");
      });
    })();
</script>
</body>
</html>
