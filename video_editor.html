<!doctype html>
<html lang="vi">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Video Editor</title>
    <style>
        :root{--bd:#e7e7e7;--mut:#666}
        body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
        header{padding:12px 14px;border-bottom:1px solid var(--bd);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
        header b{font-size:14px}
        .mut{color:var(--mut);font-size:12px}
        .k{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;font-size:12px}
        main{padding:14px;display:grid;grid-template-columns:1.2fr 1fr;gap:14px}
        .card{border:1px solid var(--bd);border-radius:14px;overflow:hidden;background:#fff}
        .hd{padding:10px 12px;border-bottom:1px solid var(--bd);font-weight:600;font-size:13px}
        .ct{padding:12px}
        video{width:100%;max-height:70vh;background:#000;border-radius:12px}
        canvas{width:100%;max-height:40vh;border-radius:12px;background:#111;display:block}
        label{display:flex;justify-content:space-between;gap:10px;align-items:center;margin:10px 0;font-size:13px}
        input[type="range"]{width:60%}
        input[type="number"], input[type="password"]{
          width:160px;padding:6px 8px;border:1px solid var(--bd);border-radius:10px
        }
        button,a.btn{
          border:1px solid var(--bd);background:#fff;padding:8px 10px;border-radius:10px;cursor:pointer;
          text-decoration:none;color:inherit;display:inline-flex;gap:6px;align-items:center
        }
        button:hover,a.btn:hover{background:#f5f5f5}
        .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
        .status{white-space:pre-wrap;font-size:12px;color:var(--mut);margin-top:10px}
        hr{border:none;border-top:1px solid var(--bd);margin:14px 0}
        .warn{border:1px solid #f0c1c1;background:#fff6f6;padding:8px 10px;border-radius:12px;font-size:12px;color:#7a2a2a;margin-top:10px}
    </style>
</head>
<body>
<header>
    <b>Video Editor</b>
    <span class="mut" id="info"></span>

    <input id="token" type="password" placeholder="GitHub Token (Contents: write)" style="min-width:260px" />
    <label class="mut" title="L∆∞u token tr√™n m√°y b·∫°n (localStorage)">
        <input id="remember" type="checkbox" />
        remember token
    </label>

    <a class="btn" id="back" href="./browser.html">‚Üê Back</a>
</header>

<main>
    <div class="card">
        <div class="hd">Preview video</div>
        <div class="ct">
            <video id="v" controls playsinline crossorigin="anonymous"></video>

            <div class="row" style="margin-top:10px">
                <button id="seekPrev">‚è™ -0.1s</button>
                <button id="seekNext">‚è© +0.1s</button>
                <span class="mut">Time:</span>
                <span class="k" id="t">0.000</span>
                <span class="mut">/</span>
                <span class="k" id="dur">0.000</span>
            </div>

            <label style="margin-top:12px">
                <span>Scrub (sec)</span>
                <input id="scrub" type="range" min="0" max="0" step="0.033" value="0"/>
                <span class="k" id="scrubVal">0.000</span>
            </label>

            <div class="warn" id="note" style="display:none"></div>
        </div>
    </div>

    <div class="card">
        <div class="hd">Frame ‚Üí webp (replace) + Trim MP4 (replace)</div>
        <div class="ct">
            <div class="mut">Frame preview (canvas):</div>
            <canvas id="c"></canvas>

            <div class="row" style="margin-top:10px">
                <button id="downloadWebp">üì∏ Download .webp</button>
                <button id="downloadPreview">üñºÔ∏è Download _preview.webp</button>
                <button id="replaceWebp">‚úÖ Replace target on GitHub</button>
            </div>

            <div class="mut" style="margin-top:8px">
                Target: <span class="k" id="targetLabel">(none)</span>
            </div>

            <hr/>

            <div class="mut">Trim video (GI·ªÆ √ÇM THANH):</div>
            <label>
                <span>Trim start (sec)</span>
                <input id="start" type="number" min="0" step="0.1" value="0"/>
            </label>
            <label>
                <span>Trim end (sec)</span>
                <input id="end" type="number" min="0" step="0.1" value="0"/>
            </label>

            <label>
                <span>Playback speed (preview only)</span>
                <input id="speed" type="range" min="0.5" max="2" step="0.1" value="1"/>
                <span class="k" id="speedVal">1.0x</span>
            </label>

            <div class="row" style="margin-top:10px">
                <button id="apply">Apply speed to preview</button>
                <button id="replaceTrimMp4">‚ôªÔ∏è Trim & Replace MP4 on GitHub</button>
            </div>

            <div class="warn" style="margin-top:10px">
                N·∫øu g·∫∑p <b>bad memory</b>: file mp4 to qu√° / m√°y thi·∫øu RAM / FFmpeg wasm gi·ªõi h·∫°n b·ªô nh·ªõ.<br/>
                B·∫£n n√†y t·ªëi ∆∞u RAM: ch·ªâ t·∫£i video 1 l·∫ßn, trim FAST nh·∫π h∆°n, d·ªçn FS sau khi xong.
            </div>

            <div class="status" id="status"></div>
        </div>
    </div>
</main>

<!-- ‚úÖ Polyfill: stop crash "SharedArrayBuffer is not defined" on GH Pages -->
<script>
    if (typeof SharedArrayBuffer === "undefined") {
      window.SharedArrayBuffer = ArrayBuffer;
    }
</script>

<!-- ‚úÖ FFmpeg bundle -->
<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.10.1/dist/ffmpeg.min.js"></script>

<script>
    /** Repo config */
    const OWNER = "tramiune";
    const REPO  = "tramiune001_res_wallpaper";
    const BRANCH = "main";
    const ROOT_DIR = "resources";
    const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

    const v = document.getElementById("v");
    const c = document.getElementById("c");
    const ctx = c.getContext("2d", { willReadFrequently: false });

    const info = document.getElementById("info");
    const noteEl = document.getElementById("note");
    const statusEl = document.getElementById("status");
    const tEl = document.getElementById("t");
    const durEl = document.getElementById("dur");
    const scrub = document.getElementById("scrub");
    const scrubVal = document.getElementById("scrubVal");
    const targetLabel = document.getElementById("targetLabel");

    const startEl = document.getElementById("start");
    const endEl = document.getElementById("end");
    const speedEl = document.getElementById("speed");
    const speedVal = document.getElementById("speedVal");

    const tokenEl = document.getElementById("token");
    const rememberEl = document.getElementById("remember");

    function setStatus(s){ statusEl.textContent = s || ""; }
    function setNote(s){
      if (!s){ noteEl.style.display="none"; noteEl.textContent=""; return; }
      noteEl.style.display="block"; noteEl.textContent=s;
    }

    function qs() {
      const p = new URLSearchParams(location.search);
      return {
        mode: p.get("mode") || "edit",        // edit | replaceImage
        folder: p.get("folder") || "",
        video: p.get("video") || "",
        target: p.get("target") || ""
      };
    }

    function encodePath(path) { return path.split("/").map(encodeURIComponent).join("/"); }
    function mediaUrlCdn(folder, file){ return `${CDN_BASE}${folder}/${file}`; }
    function baseName(file){
      const i = file.lastIndexOf(".");
      return i >= 0 ? file.slice(0, i) : file;
    }
    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 5000);
    }
    function drawFrameToCanvas(){
      if (!v.videoWidth || !v.videoHeight) return;
      c.width = v.videoWidth;
      c.height = v.videoHeight;
      ctx.drawImage(v, 0, 0, c.width, c.height);
    }
    async function seekTo(time){
      const t = Math.max(0, Math.min(time, v.duration || 0));
      v.pause();
      v.currentTime = t;
      await new Promise(resolve => v.addEventListener("seeked", resolve, { once:true }));
      drawFrameToCanvas();
      updateUI();
    }
    function updateUI(){
      const ct = v.currentTime || 0;
      tEl.textContent = ct.toFixed(3);
      scrubVal.textContent = ct.toFixed(3);
      scrub.value = String(ct);
    }

    /** token localStorage share */
    const LS_KEY = `wallpaper_browser_token_${OWNER}_${REPO}`;
    (function initRememberToken(){
      const saved = localStorage.getItem(LS_KEY);
      if (saved) { tokenEl.value = saved; rememberEl.checked = true; }
      rememberEl.addEventListener("change", () => {
        if (rememberEl.checked) {
          if (tokenEl.value.trim()) localStorage.setItem(LS_KEY, tokenEl.value.trim());
        } else localStorage.removeItem(LS_KEY);
      });
      tokenEl.addEventListener("input", () => {
        if (rememberEl.checked) localStorage.setItem(LS_KEY, tokenEl.value.trim());
      });
    })();

    function getAuthToken() {
      const t = (tokenEl?.value || "").trim();
      if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (Contents: write).");
      return t;
    }

    async function ghGetJson(url, token) {
      const res = await fetch(url, {
        headers: { "Authorization": `Bearer ${token}`, "Accept": "application/vnd.github+json" }
      });
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`HTTP ${res.status}\n${txt}`);
      }
      return res.json();
    }
    async function ghPutJson(url, token, body) {
      const res = await fetch(url, {
        method: "PUT",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`HTTP ${res.status}\n${txt}`);
      }
      return res.json();
    }
    async function getFileSha(filePath, token) {
      const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}?ref=${encodeURIComponent(BRANCH)}`;
      const j = await ghGetJson(url, token);
      if (!j?.sha) throw new Error("Kh√¥ng l·∫•y ƒë∆∞·ª£c sha c·ªßa file.");
      return j.sha;
    }
    async function blobToBase64NoPrefix(blob) {
      const dataUrl = await new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = reject;
        r.readAsDataURL(blob);
      });
      return String(dataUrl).split(",")[1];
    }

    /** =====================
     *  Load video ONCE (Blob) to save RAM
     *  ===================== */
    let gVideoBlob = null;       // original mp4 blob (loaded once)
    let gVideoBlobUrl = null;    // objectURL for preview

    async function fetchVideoBlobOnce(folder, fileName) {
      if (gVideoBlob) return gVideoBlob;
      const token = getAuthToken();
      const filePath = `${ROOT_DIR}/${folder}/${fileName}`;
      const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}?ref=${encodeURIComponent(BRANCH)}`;

      setStatus(`Fetching video (once)...\n${filePath}`);
      const meta = await ghGetJson(url, token);
      if (!meta?.download_url) throw new Error("Kh√¥ng c√≥ download_url.");

      const res = await fetch(meta.download_url);
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`Download failed: HTTP ${res.status}\n${txt}`);
      }
      gVideoBlob = await res.blob();
      setStatus(`‚úÖ Downloaded\nsize=${Math.round(gVideoBlob.size/1024/1024)}MB`);
      return gVideoBlob;
    }

    function setVideoSrcFromBlob(blob) {
      try { if (gVideoBlobUrl) URL.revokeObjectURL(gVideoBlobUrl); } catch {}
      gVideoBlobUrl = URL.createObjectURL(blob);
      v.src = gVideoBlobUrl;
    }

    function approxContentApiLimitOk(blob){
      // GitHub Contents API content field size is small (~1MB).
      // We'll warn if > 900KB.
      return blob.size <= 900 * 1024;
    }

    /** Replace target webp on GitHub */
    async function replaceWebpOnGitHub(folder, targetFileName, webpBlob) {
      const token = getAuthToken();
      const filePath = `${ROOT_DIR}/${folder}/${targetFileName}`;
      setStatus(`Uploading...\n‚Üí ${filePath}`);
      const sha = await getFileSha(filePath, token);
      const content = await blobToBase64NoPrefix(webpBlob);
      await ghPutJson(
        `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`,
        token,
        { message: `Update ${filePath}`, content, sha, branch: BRANCH }
      );
      setStatus(`‚úÖ Replaced on GitHub\n${filePath}`);
    }

    /** UI actions */
    speedEl.addEventListener("input", ()=> speedVal.textContent = `${Number(speedEl.value).toFixed(1)}x`);
    document.getElementById("apply").onclick = ()=> { v.playbackRate = Number(speedEl.value) || 1; };

    document.getElementById("seekPrev").onclick = ()=> seekTo((v.currentTime||0) - 0.1);
    document.getElementById("seekNext").onclick = ()=> seekTo((v.currentTime||0) + 0.1);

    scrub.addEventListener("input", ()=> { scrubVal.textContent = Number(scrub.value).toFixed(3); });
    scrub.addEventListener("change", ()=> seekTo(Number(scrub.value) || 0));

    async function canvasToWebpBlob(quality) {
      drawFrameToCanvas();
      const blob = await new Promise(resolve => c.toBlob(resolve, "image/webp", quality));
      if (!blob) throw new Error("toBlob failed (webp not supported?)");
      return blob;
    }

    document.getElementById("downloadWebp").onclick = async () => {
      try {
        const { video } = qs();
        const out = `${baseName(video)}.webp`;
        setStatus(`Capturing frame...\n‚Üí ${out}`);
        const blob = await canvasToWebpBlob(0.92);
        downloadBlob(blob, out);
        setStatus(`‚úÖ Saved\n${out}`);
      } catch (e) { alert(String(e?.message || e)); }
    };

    document.getElementById("downloadPreview").onclick = async () => {
      try {
        const { video } = qs();
        const out = `${baseName(video)}_preview.webp`;

        drawFrameToCanvas();
        const targetW = 360;
        const scale = targetW / c.width;
        const w = Math.max(1, Math.round(c.width * scale));
        const h = Math.max(1, Math.round(c.height * scale));

        const tmp = document.createElement("canvas");
        tmp.width = w; tmp.height = h;
        tmp.getContext("2d").drawImage(c, 0, 0, w, h);

        setStatus(`Capturing preview...\n‚Üí ${out}`);
        const blob = await new Promise(resolve => tmp.toBlob(resolve, "image/webp", 0.85));
        if (!blob) throw new Error("toBlob failed");
        downloadBlob(blob, out);
        setStatus(`‚úÖ Saved\n${out}`);
      } catch (e) { alert(String(e?.message || e)); }
    };

    document.getElementById("replaceWebp").onclick = async () => {
      try {
        const { mode, folder, target } = qs();
        if (mode !== "replaceImage") throw new Error("Replace ch·ªâ d√πng khi m·ªü t·ª´ n√∫t Update (mode=replaceImage).");
        if (!folder || !target) throw new Error("Thi·∫øu folder/target.");
        const blob = await canvasToWebpBlob(0.92);
        await replaceWebpOnGitHub(folder, target, blob);
        try { window.opener?.location?.reload?.(); } catch {}
      } catch (e) { alert(String(e?.message || e)); }
    };

    /** =========================
     *  FFmpeg (single-thread) Trim MP4 & Replace (GI·ªÆ AUDIO)
     *  ========================= */
    let _ff = null;

    async function ensureFFmpegLoaded() {
      if (_ff) return _ff;
      if (!window.FFmpeg || !window.FFmpeg.createFFmpeg) throw new Error("FFmpeg wasm ch∆∞a load.");
      const { createFFmpeg, fetchFile } = window.FFmpeg;

      const ffmpeg = createFFmpeg({
        log: true,
        corePath: "https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.10.0/dist/ffmpeg-core.js"
      });

      setStatus("Loading FFmpeg (first time only)...\n(single-thread, GH Pages OK)");
      await ffmpeg.load();
      setStatus("");

      _ff = { ffmpeg, fetchFile };
      return _ff;
    }

    function safeUnlink(ffmpeg, name){ try { ffmpeg.FS("unlink", name); } catch {} }

    async function trimMp4BlobWithFFmpeg(inputMp4Blob, startSec, endSec, mode = "FAST") {
      const { ffmpeg, fetchFile } = await ensureFFmpegLoaded();

      const start = Math.max(0, Number(startSec) || 0);
      const end = Math.max(0, Number(endSec) || 0);
      if (end <= start) throw new Error("Trim end ph·∫£i > trim start.");
      const dur = end - start;

      const inName = "in.mp4";
      const outName = "out.mp4";

      // cleanup any old files to reduce memory
      safeUnlink(ffmpeg, inName);
      safeUnlink(ffmpeg, outName);

      setStatus(`FFmpeg: writing input...\nsize=${Math.round(inputMp4Blob.size/1024/1024)}MB`);
      ffmpeg.FS("writeFile", inName, await fetchFile(inputMp4Blob));

      setStatus(`FFmpeg: trimming...\nstart=${start}s dur=${dur}s mode=${mode}\n(gi·ªØ audio)`);

      if (mode === "FAST") {
        // ‚úÖ nh·∫π h∆°n: -ss BEFORE -i + -t
        await ffmpeg.run(
          "-ss", String(start),
          "-i", inName,
          "-t", String(dur),
          "-c", "copy",
          "-avoid_negative_ts", "make_zero",
          "-movflags", "+faststart",
          outName
        );
      } else {
        // PRECISE: encode video, audio copy if possible
        try {
          await ffmpeg.run(
            "-ss", String(start),
            "-i", inName,
            "-t", String(dur),
            "-c:v", "libx264",
            "-preset", "veryfast",
            "-crf", "23",
            "-c:a", "copy",
            "-movflags", "+faststart",
            outName
          );
        } catch {
          await ffmpeg.run(
            "-ss", String(start),
            "-i", inName,
            "-t", String(dur),
            "-c:v", "libx264",
            "-preset", "veryfast",
            "-crf", "23",
            "-c:a", "aac",
            "-b:a", "128k",
            "-movflags", "+faststart",
            outName
          );
        }
      }

      const data = ffmpeg.FS("readFile", outName);
      const outBlob = new Blob([data.buffer], { type: "video/mp4" });

      // cleanup to free memory
      safeUnlink(ffmpeg, inName);
      safeUnlink(ffmpeg, outName);

      setStatus(`‚úÖ Trim done\nout=${Math.round(outBlob.size/1024/1024)}MB`);
      return outBlob;
    }

    async function replaceVideoOnGitHub(folder, fileName, mp4Blob) {
      const token = getAuthToken();
      const filePath = `${ROOT_DIR}/${folder}/${fileName}`;

      // WARNING about Contents API size
      if (!approxContentApiLimitOk(mp4Blob)) {
        throw new Error(
          `File sau trim ~${Math.round(mp4Blob.size/1024)}KB > ~900KB.\n` +
          `GitHub Contents API th∆∞·ªùng KH√îNG upload ƒë∆∞·ª£c file l·ªõn (limit ~1MB).\n` +
          `C√°ch ƒë√∫ng: d√πng git push / Git LFS / GitHub Actions.\n` +
          `B·∫°n h√£y trim ng·∫Øn h∆°n ho·∫∑c ƒë·ªïi workflow.`
        );
      }

      setStatus(`Uploading trimmed mp4...\n‚Üí ${filePath}`);
      const sha = await getFileSha(filePath, token);
      const content = await blobToBase64NoPrefix(mp4Blob);

      await ghPutJson(
        `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`,
        token,
        { message: `Trim & replace ${filePath}`, content, sha, branch: BRANCH }
      );

      setStatus(`‚úÖ Replaced video on GitHub\n${filePath}`);
    }

    document.getElementById("replaceTrimMp4").onclick = async () => {
      try {
        const { folder, video } = qs();
        if (!folder || !video) throw new Error("Thi·∫øu folder/video.");

        if (!v.duration || Number.isNaN(v.duration)) throw new Error("Video ch∆∞a load xong.");

        const start = Math.max(0, Number(startEl.value) || 0);
        const endIn = Math.max(0, Number(endEl.value) || 0);
        const end = (endIn <= 0 || endIn > v.duration) ? v.duration : endIn;
        if (end <= start) throw new Error("Trim end ph·∫£i > trim start.");

        const mode = confirm("OK = FAST (nhanh, copy stream)\nCancel = PRECISE (chu·∫©n h∆°n, re-encode video)") ? "FAST" : "PRECISE";

        // ‚úÖ LOAD ONCE (blob) and reuse -> less RAM
        const srcBlob = await fetchVideoBlobOnce(folder, video);

        const outBlob = await trimMp4BlobWithFFmpeg(srcBlob, start, end, mode);
        await replaceVideoOnGitHub(folder, video, outBlob);

        // reload preview with trimmed result
        setVideoSrcFromBlob(outBlob);
        try { await v.play().catch(()=>{}); } catch {}

        try { window.opener?.location?.reload?.(); } catch {}
      } catch (e) {
        alert(String(e?.message || e));
      }
    };

    /** init */
    (async function init(){
      const { mode, folder, video, target } = qs();
      if (!folder || !video) {
        info.textContent = "Thi·∫øu query ?folder=...&video=...";
        setStatus("M·ªü t·ª´ browser.html b·∫±ng n√∫t Edit / Update ƒë·ªÉ t·ª± fill query.");
        return;
      }

      info.textContent = `${folder}/${video} ¬∑ mode=${mode}`;
      targetLabel.textContent = target ? target : "(none)";

      v.crossOrigin = "anonymous";

      // Prefer GitHub API blob (avoid taint). Need token to load blob.
      const hasToken = !!(tokenEl.value || "").trim();

      if (hasToken) {
        setNote("C√≥ token: t·∫£i video blob qua GitHub API (kh√¥ng CORS taint). Trim/Replace s·∫Ω d√πng blob n√†y (ƒë·ª° RAM).");
        try {
          const blob = await fetchVideoBlobOnce(folder, video);
          setVideoSrcFromBlob(blob);
        } catch (e) {
          setNote(String(e?.message || e));
          v.src = mediaUrlCdn(folder, video);
        }
      } else {
        setNote("Kh√¥ng c√≥ token: xem b·∫±ng CDN. ƒê·ªÉ trim/replace MP4 c·∫ßn token.");
        v.src = mediaUrlCdn(folder, video);
      }

      v.addEventListener("loadedmetadata", async () => {
        durEl.textContent = (v.duration || 0).toFixed(3);
        scrub.max = String(v.duration || 0);
        startEl.value = "0";
        endEl.value = (v.duration || 0).toFixed(1);
        speedEl.value = "1";
        speedVal.textContent = "1.0x";
        await seekTo(0);
      });

      v.addEventListener("timeupdate", () => {
        if (!v.paused) updateUI();
      });
    })();
</script>
</body>
</html>
