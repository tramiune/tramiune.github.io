<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wallpaper Browser (GitHub API only)</title>
  <style>
    :root { --bd:#e7e7e7; --mut:#666; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    header { padding:12px 14px; border-bottom:1px solid var(--bd); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header b { font-size:14px; }
    header .mut { color:var(--mut); font-size:12px; }
    header input[type="text"], header input[type="password"] {
      padding:8px 10px; border:1px solid var(--bd); border-radius:10px; min-width:220px;
    }
    header button {
      padding:8px 10px; border:1px solid var(--bd); background:#fff; border-radius:10px; cursor:pointer;
    }
    header button:hover { background:#f5f5f5; }
    label.mut { display:inline-flex; gap:6px; align-items:center; }
    input[type="checkbox"] { transform: translateY(1px); }

    .wrap { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 64px); }
    aside { border-right:1px solid var(--bd); padding:10px; overflow:auto; }
    main { padding:12px; overflow:auto; }

    .folder {
      padding:9px 10px; border:1px solid var(--bd); border-radius:12px; cursor:pointer;
      display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;
    }
    .folder:hover { background:#f7f7f7; }
    .folder.active { border-color:#bbb; background:#f5f5f5; }

    .small { font-size:12px; color:var(--mut); }
    .status { font-size:12px; color:var(--mut); white-space:pre-wrap; margin: 6px 0 10px; }

    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(190px, 1fr)); gap:10px; }
    .card { border:1px solid var(--bd); border-radius:14px; overflow:hidden; background:#fff; }
    .thumb { width:100%; aspect-ratio: 9/16; background:#f2f2f2; display:flex; align-items:center; justify-content:center; }
    img, video { width:100%; height:100%; object-fit:cover; display:block; }
    .meta { padding:8px 10px; border-top:1px solid var(--bd); }
    .meta .name { font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .pill { font-size:11px; color:#333; background:#f3f3f3; border:1px solid #e2e2e2; padding:2px 8px; border-radius:999px; display:inline-block; margin-top:6px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .danger { border-color:#f0c1c1 !important; }

    a.btn{
      border:1px solid var(--bd); background:#fff; padding:8px 10px; border-radius:10px;
      cursor:pointer; text-decoration:none; color:inherit; display:inline-flex; gap:6px; align-items:center;
    }
    a.btn:hover{ background:#f5f5f5; }
  </style>
</head>
<body>
<header>
  <b>Wallpaper Browser</b>
  <span class="mut">API-only: list folder/file + load media via GitHub API blob URL</span>

  <input id="q" type="text" placeholder="Filter folder/file..." />

  <input id="token" type="password" placeholder="GitHub Token (Contents: write)" style="min-width:260px" />
  <label class="mut" title="L∆∞u token tr√™n m√°y b·∫°n (localStorage)">
    <input id="remember" type="checkbox" />
    remember token
  </label>

  <label class="mut" title="Hi·ªán file _preview.webp nh∆∞ item ri√™ng">
    <input id="showPreview" type="checkbox" />
    show _preview
  </label>

  <label class="mut" title="Khi generate JSON: LIVE n·∫øu c√≥ _preview.webp th√¨ c√≥ nh√©t thumbUrl hay kh√¥ng">
    <input id="jsonUsePreview" type="checkbox" checked />
    json use preview (LIVE)
  </label>

  <button id="reload">Reload</button>
  <button id="genAll">Generate JSON (ALL)</button>
  <span class="mut" id="rate"></span>
</header>

<div class="wrap">
  <aside>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <b style="font-size:13px;">Folders</b>
      <span class="small" id="folderCount"></span>
    </div>
    <div id="folders"></div>
  </aside>

  <main>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <div>
        <b id="title" style="font-size:13px;">Ch·ªçn folder</b><br/>
        <span class="small" id="subtitle"></span>
      </div>
      <div class="small" id="itemCount"></div>
    </div>

    <div class="status" id="status"></div>
    <div class="grid" id="grid"></div>
  </main>
</div>

<script>
  /** =========================
   *  CONFIG ‚Äì s·ª≠a ·ªü ƒë√¢y
   *  ========================= */
  const OWNER = "tramiune";
  const REPO  = "tramiune001_res_wallpaper";
  const BRANCH = "main";           // ƒë·ªïi n·∫øu repo b·∫°n l√† master
  const ROOT_DIR = "resources";

  // file json output (g·ªôp t·∫•t c·∫£ folder s·ªë)
  const OUTPUT_ALL_JSON = "dev/wallpaper.json";

  // CDN url ƒë·ªÉ nh√©t v√†o JSON (theo format app c·ªßa b·∫°n)
  const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

  const IMAGE_EXT = ["webp","png","jpg","jpeg","gif"];
  const VIDEO_EXT = ["mp4","webm","mov"];
  /** ========================= */

  const elFolders = document.getElementById("folders");
  const elGrid = document.getElementById("grid");
  const elStatus = document.getElementById("status");
  const elTitle = document.getElementById("title");
  const elSubtitle = document.getElementById("subtitle");
  const elFolderCount = document.getElementById("folderCount");
  const elItemCount = document.getElementById("itemCount");
  const elQ = document.getElementById("q");
  const elRate = document.getElementById("rate");
  const elToken = document.getElementById("token");
  const elRemember = document.getElementById("remember");
  const elShowPreview = document.getElementById("showPreview");
  const elJsonUsePreview = document.getElementById("jsonUsePreview");

  let allFolders = [];
  let activeFolder = null;
  let activeFiles = [];

  /** cache blob url theo "folder/file" */
  const blobUrlCache = new Map(); // key -> { url, ts }
  const MAX_CACHE = 120;

  function setStatus(s) { elStatus.textContent = s || ""; }
  function extOf(name) {
    const i = name.lastIndexOf(".");
    return i >= 0 ? name.slice(i+1).toLowerCase() : "";
  }
  function isMediaFile(name) {
    const e = extOf(name);
    return IMAGE_EXT.includes(e) || VIDEO_EXT.includes(e);
  }
  function isPreviewName(name) { return name.includes("_preview."); }

  function encodePath(path) { return path.split("/").map(encodeURIComponent).join("/"); }
  function ghContentsUrl(path) {
    const p = encodePath(path);
    return `https://api.github.com/repos/${OWNER}/${REPO}/contents/${p}?ref=${encodeURIComponent(BRANCH)}`;
  }

  function getAuthToken() {
    const t = elToken.value.trim();
    if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (c·∫ßn Contents: write).");
    return t;
  }

  async function fetchJson(url, withAuth = false) {
    const headers = { "Accept": "application/vnd.github+json" };
    if (withAuth) headers["Authorization"] = `Bearer ${getAuthToken()}`;

    const res = await fetch(url, { headers });
    const limit = res.headers.get("x-ratelimit-limit");
    const remain = res.headers.get("x-ratelimit-remaining");
    if (limit && remain) elRate.textContent = `GitHub API rate: ${remain}/${limit}`;

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`HTTP ${res.status}\n${txt}`);
    }
    return res.json();
  }

  /** remember token (localStorage) */
  const LS_KEY = `wallpaper_browser_token_${OWNER}_${REPO}`;
  (function initRememberToken(){
    const saved = localStorage.getItem(LS_KEY);
    if (saved) {
      elToken.value = saved;
      elRemember.checked = true;
    }
    elRemember.addEventListener("change", () => {
      if (elRemember.checked) {
        if (elToken.value.trim()) localStorage.setItem(LS_KEY, elToken.value.trim());
      } else {
        localStorage.removeItem(LS_KEY);
      }
    });
    elToken.addEventListener("input", () => {
      if (elRemember.checked) localStorage.setItem(LS_KEY, elToken.value.trim());
    });
  })();

  /** ---------- MEDIA LOAD via API -> blob URL ---------- */
  async function getBlobUrlForFile(folderName, fileName) {
    const key = `${folderName}/${fileName}`;
    const cached = blobUrlCache.get(key);
    if (cached?.url) return cached.url;

    const token = getAuthToken(); // API-only => b·∫Øt bu·ªôc token
    const filePath = `${ROOT_DIR}/${folderName}/${fileName}`;

    // l·∫•y download_url qua contents API
    const meta = await fetchJson(ghContentsUrl(filePath), true);
    const dl = meta?.download_url;
    if (!dl) throw new Error(`No download_url for ${filePath}`);

    // t·∫£i blob
    const res = await fetch(dl, { headers: { "Authorization": `Bearer ${token}` } }).catch(() => fetch(dl));
    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Download failed: HTTP ${res.status}\n${txt}`);
    }
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    blobUrlCache.set(key, { url, ts: Date.now() });
    // gi·ªõi h·∫°n cache
    if (blobUrlCache.size > MAX_CACHE) {
      const oldestKey = [...blobUrlCache.entries()].sort((a,b)=>a[1].ts-b[1].ts)[0]?.[0];
      if (oldestKey) {
        const old = blobUrlCache.get(oldestKey);
        try { URL.revokeObjectURL(old.url); } catch {}
        blobUrlCache.delete(oldestKey);
      }
    }

    return url;
  }

  function renderFolders(list) {
    elFolders.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const shown = list.filter(f => f.name.toLowerCase().includes(q));
    elFolderCount.textContent = `${shown.length}/${list.length}`;

    for (const f of shown) {
      const div = document.createElement("div");
      div.className = "folder" + (activeFolder === f.name ? " active" : "");
      div.innerHTML = `<span>üìÅ ${f.name}</span><span class="small">open</span>`;
      div.onclick = () => openFolder(f.name);
      elFolders.appendChild(div);
    }
  }

  /** ---------- DELETE ---------- */
  async function deleteFileOnGitHub(filePath, sha) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`;

    const res = await fetch(url, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ message: `Delete ${filePath}`, sha, branch: BRANCH })
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Delete failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function deleteFileFlow(f) {
    if (!activeFolder) return;
    const filePath = `${ROOT_DIR}/${activeFolder}/${f.name}`;

    const ok = confirm(`Xo√° file kh·ªèi GitHub?\n\n${filePath}\n\n‚ö†Ô∏è Kh√¥ng undo ƒë∆∞·ª£c (tr·ª´ khi b·∫°n git revert).`);
    if (!ok) return;

    setStatus(`Deleting...\n${filePath}`);
    await deleteFileOnGitHub(filePath, f.sha);

    setStatus(`‚úÖ Deleted\n${filePath}`);
    await openFolder(activeFolder);
  }

  /** ---------- GRID ---------- */
  async function renderGrid(files) {
    elGrid.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const showPreview = elShowPreview.checked;

    // preview map (baseImageName.webp -> previewFileName.webp)
    const previewByBase = new Map();
    for (const f of files) {
      if (!isMediaFile(f.name)) continue;
      if (!isPreviewName(f.name)) continue;
      const base = f.name.replace("_preview.", ".");
      previewByBase.set(base, f.name);
    }

    // mp4 map (baseName(no ext) -> filename.mp4)
    const mp4ByBase = new Map();
    for (const f of files) {
      const e = extOf(f.name);
      if (!VIDEO_EXT.includes(e)) continue;
      if (f.name.includes("_noSound.")) continue; // ∆∞u ti√™n mp4 th∆∞·ªùng
      const base = f.name.slice(0, f.name.lastIndexOf("."));
      mp4ByBase.set(base, f.name);
    }

    let shown = files
      .filter(f => isMediaFile(f.name))
      .filter(f => f.name.toLowerCase().includes(q));

    if (!showPreview) shown = shown.filter(f => !isPreviewName(f.name));

    elItemCount.textContent = `Items: ${shown.length}`;

    for (const f of shown) {
      const e = extOf(f.name);
      const isVideo = VIDEO_EXT.includes(e);
      const isImage = IMAGE_EXT.includes(e);

      const card = document.createElement("div");
      card.className = "card";

      const thumb = document.createElement("div");
      thumb.className = "thumb";
      thumb.textContent = "Loading...";

      const meta = document.createElement("div");
      meta.className = "meta";

      const maybePreview = previewByBase.get(f.name);
      const labelPreviewHint =
        (!isVideo && !isPreviewName(f.name) && maybePreview) ? " ¬∑ has preview" : "";

      meta.innerHTML = `
        <div class="name" title="${f.name}">${f.name}</div>
        <div class="pill">${isVideo ? "video" : "image"} ¬∑ ${e}${isPreviewName(f.name) ? " ¬∑ preview" : ""}${labelPreviewHint}</div>
      `;

      const actions = document.createElement("div");
      actions.style.display = "flex";
      actions.style.gap = "8px";
      actions.style.flexWrap = "wrap";
      actions.style.marginTop = "8px";

      // open file (blob)
      const openBtn = document.createElement("a");
      openBtn.className = "btn";
      openBtn.textContent = "üîó Open";
      openBtn.href = "#";
      openBtn.onclick = async (ev) => {
        ev.preventDefault();
        try {
          const url = await getBlobUrlForFile(activeFolder, f.name);
          window.open(url, "_blank", "noopener,noreferrer");
        } catch (err) {
          alert(String(err?.message || err));
        }
      };
      actions.appendChild(openBtn);

      // delete
      const delBtn = document.createElement("button");
      delBtn.textContent = "üóë Delete";
      delBtn.className = "danger";
      delBtn.onclick = async () => {
        try { await deleteFileFlow(f); }
        catch (err) { alert(String(err?.message || err)); }
      };
      actions.appendChild(delBtn);

      // update image from mp4 (GI·ªÆ N√öT UPDATE C·ª¶A B·∫†N)
      const isNormalWebp = isImage && e === "webp" && !isPreviewName(f.name);
      if (isNormalWebp) {
        const base = f.name.slice(0, f.name.lastIndexOf("."));
        const mp4 = mp4ByBase.get(base);
        if (mp4) {
          const updBtn = document.createElement("a");
          updBtn.textContent = "üîÑ Update";
          updBtn.className = "btn";
          // b·∫°n ƒëang c√≥ m√†n update ri√™ng (n·∫øu ch∆∞a c√≥ th√¨ t·ª± ƒë·ªïi path sau)
          updBtn.href =
            `./video_editor.html?mode=replaceImage` +
            `&folder=${encodeURIComponent(activeFolder)}` +
            `&video=${encodeURIComponent(mp4)}` +
            `&target=${encodeURIComponent(f.name)}`;
          updBtn.target = "_blank";
          actions.appendChild(updBtn);
        }
      }

      // trim/edit video (tr·ªè sang dev/trim_dispatch.html)
      if (isVideo) {
        const editBtn = document.createElement("a");
        editBtn.textContent = "‚úÇÔ∏è Trim";
        editBtn.className = "btn";
        editBtn.href = `./dev/trim_dispatch.html?folder=${encodeURIComponent(activeFolder)}&video=${encodeURIComponent(f.name)}`;
        editBtn.target = "_blank";
        actions.appendChild(editBtn);
      }

      meta.appendChild(actions);
      card.appendChild(thumb);
      card.appendChild(meta);
      elGrid.appendChild(card);

      // load media blob url and render
      (async () => {
        try {
          const url = await getBlobUrlForFile(activeFolder, f.name);
          thumb.textContent = "";
          if (isVideo) {
            const vv = document.createElement("video");
            vv.src = url;
            vv.controls = true;
            vv.muted = true;
            vv.playsInline = true;
            vv.preload = "metadata";
            thumb.appendChild(vv);
          } else {
            const img = document.createElement("img");
            img.loading = "lazy";
            img.src = url;
            img.alt = f.name;
            thumb.appendChild(img);
          }
        } catch (err) {
          thumb.textContent = "Load failed";
          console.error(err);
        }
      })();
    }
  }

  /** ---------- LOADERS ---------- */
  async function loadFolders() {
    setStatus("Loading folders... (API-only requires token)");
    elTitle.textContent = "Ch·ªçn folder";
    elSubtitle.textContent = `${OWNER}/${REPO}/${ROOT_DIR}`;
    elItemCount.textContent = "";
    elGrid.innerHTML = "";

    // API-only => d√πng auth ƒë·ªÉ rate-limit cao h∆°n v√† tr√°nh fail
    const data = await fetchJson(ghContentsUrl(ROOT_DIR), true);

    allFolders = data
      .filter(x => x.type === "dir")
      .map(x => ({ name: x.name, path: x.path }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    renderFolders(allFolders);
    setStatus("");
  }

  async function openFolder(folderName) {
    activeFolder = folderName;
    renderFolders(allFolders);

    elTitle.textContent = `üìÅ ${folderName}`;
    elSubtitle.textContent = `${ROOT_DIR}/${folderName}`;
    setStatus("Loading files...");
    elGrid.innerHTML = "";

    const path = `${ROOT_DIR}/${folderName}`;
    const data = await fetchJson(ghContentsUrl(path), true);

    activeFiles = data
      .filter(x => x.type === "file")
      .map(x => ({ name: x.name, size: x.size || 0, sha: x.sha }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    setStatus("");
    await renderGrid(activeFiles);
  }

  /** =========================
   *  GENERATE JSON (ALL)
   *  ========================= */

  // Types:
  // STILL=1, LIVE=0, DOUBLE=2, DAYS=3, COUPLE=4
  const TYPE = { LIVE:0, STILL:1, DOUBLE:2, DAYS:3, COUPLE:4 };

  function pad3(n) { return String(n).padStart(3,"0"); }

  function folderDefaultPrefix(folderName) {
    return folderName.replace(/^\d+_/, "");
  }

  function cdnUrl(folderName, fileName) {
    return `${CDN_BASE}${folderName}/${fileName}`;
  }

  function contentTypeFromExt(name) {
    const e = extOf(name);
    if (e === "webp") return "image/webp";
    if (e === "png") return "image/png";
    if (e === "jpg" || e === "jpeg") return "image/jpeg";
    if (e === "gif") return "image/gif";
    if (e === "mp4") return "video/mp4";
    if (e === "webm") return "video/webm";
    if (e === "mov") return "video/quicktime";
    return "application/octet-stream";
  }

  function hourToHHMM(h) {
    const hh = String(h).padStart(2,"0");
    return `${hh}:00`;
  }

  function uniqId(desired, usedSet) {
    if (!usedSet.has(desired)) { usedSet.add(desired); return desired; }
    let i = 2;
    while (usedSet.has(`${desired}_${i}`)) i++;
    const out = `${desired}_${i}`;
    usedSet.add(out);
    return out;
  }

  async function listFolderFiles(folderName) {
    const path = `${ROOT_DIR}/${folderName}`;
    const data = await fetchJson(ghContentsUrl(path), true);
    return data.filter(x => x.type === "file").map(x => x.name);
  }

  function buildItemsFromFiles(folderName, fileNames, baseCreatedAt, usePreviewForLive) {
    const defPrefix = folderDefaultPrefix(folderName);

    // helpers maps
    const previewByKey = new Map(); // key prefix|num -> preview filename
    const imageByKey   = new Map(); // key prefix|num -> image filename (non preview, non *_0/_1, non *h)
    const mp4ByKey     = new Map(); // key prefix|num -> mp4 filename (prefer non _noSound)
    const stillByKeyOtherExt = new Map(); // if still is png/jpg etc

    const doubleByNum  = new Map(); // num -> {0:file,1:file}
    const coupleByNum  = new Map(); // num -> {single,0,1,preview}
    const daysByNum    = new Map(); // num -> Map(hour -> file)

    // Pass 1: classify
    for (const name of fileNames) {
      const e = extOf(name);

      // preview: <prefix>_<num>_preview.webp
      let m = name.match(/^(.*)_(\d{1,})_preview\.webp$/i);
      if (m) {
        const prefix = m[1];
        const num = pad3(m[2]);
        previewByKey.set(`${prefix}|${num}`, name);

        // couple preview special (associate later)
        if (prefix === "couple") {
          const c = coupleByNum.get(num) || {};
          c.preview = name;
          coupleByNum.set(num, c);
        }
        continue;
      }

      // double: double_<num>_0.webp or double_<num>_1.webp
      m = name.match(/^double_(\d{1,})_([01])\.webp$/i);
      if (m) {
        const num = pad3(m[1]);
        const idx = m[2];
        const obj = doubleByNum.get(num) || {};
        obj[idx] = name;
        doubleByNum.set(num, obj);
        continue;
      }

      // couple pair: couple_<num>_0.webp / couple_<num>_1.webp
      m = name.match(/^couple_(\d{1,})_([01])\.webp$/i);
      if (m) {
        const num = pad3(m[1]);
        const idx = m[2];
        const obj = coupleByNum.get(num) || {};
        obj[idx] = name;
        coupleByNum.set(num, obj);
        continue;
      }

      // couple single: couple_<num>.webp
      m = name.match(/^couple_(\d{1,})\.webp$/i);
      if (m) {
        const num = pad3(m[1]);
        const obj = coupleByNum.get(num) || {};
        obj.single = name;
        coupleByNum.set(num, obj);
        continue;
      }

      // days: days_<num>_6h.webp etc
      m = name.match(/^days_(\d{1,})_(\d{1,2})h\.webp$/i);
      if (m) {
        const num = pad3(m[1]);
        const hour = String(parseInt(m[2],10));
        const hm = daysByNum.get(num) || new Map();
        hm.set(hour, name);
        daysByNum.set(num, hm);
        continue;
      }

      // mp4 live: <prefix>_<num>.mp4  (ignore *_noSound.mp4)
      if (VIDEO_EXT.includes(e)) {
        if (name.includes("_noSound.")) continue;
        m = name.match(/^(.*)_(\d{1,})\.(mp4|webm|mov)$/i);
        if (m) {
          const prefix = m[1];
          const num = pad3(m[2]);
          mp4ByKey.set(`${prefix}|${num}`, name);
          continue;
        }
      }

      // still image main: <prefix>_<num>.webp (not preview)
      if (IMAGE_EXT.includes(e)) {
        m = name.match(/^(.*)_(\d{1,})\.(webp|png|jpg|jpeg|gif)$/i);
        if (m) {
          const prefix = m[1];
          const num = pad3(m[2]);

          // tr√°nh ƒÉn nh·∫ßm m·∫•y pattern ƒë√£ handle ·ªü tr√™n (days/double/couple pair)
          if (prefix === "days") continue;
          if (prefix === "double") continue;
          if (prefix === "couple" && name.match(/^couple_\d{1,}_[01]\.webp$/i)) continue;

          if (e === "webp") imageByKey.set(`${prefix}|${num}`, name);
          else stillByKeyOtherExt.set(`${prefix}|${num}`, name);
        }
      }
    }

    // build items list
    const items = [];

    // DOUBLE items
    for (const [num, obj] of [...doubleByNum.entries()].sort((a,b)=>a[0].localeCompare(b[0]))) {
      if (!obj["0"] || !obj["1"]) continue;
      const idBase = `${folderName}_double_${num}`;
      items.push({
        _idBase: idBase,
        _sortKey: `double|${num}`,
        categoryId: folderName,
        type: TYPE.DOUBLE,
        subType: 0,
        isPremium: true,
        coinToUnlock: 0,
        createdAt: baseCreatedAt,
        medias: [
          { url: cdnUrl(folderName, obj["0"]), name: obj["0"], thumbUrl:"", contentType: contentTypeFromExt(obj["0"]) },
          { url: cdnUrl(folderName, obj["1"]), name: obj["1"], thumbUrl:"", contentType: contentTypeFromExt(obj["1"]) },
        ]
      });
      baseCreatedAt++;
    }

    // DAYS items
    for (const [num, hm] of [...daysByNum.entries()].sort((a,b)=>a[0].localeCompare(b[0]))) {
      const idBase = `${folderName}_days_${num}`;
      const order = ["6","12","18","24"];
      const medias = [];
      for (const h of order) {
        const file = hm.get(h);
        if (!file) continue;
        medias.push({
          url: cdnUrl(folderName, file),
          name: file,
          thumbUrl: "",
          hour: hourToHHMM(h),
          contentType: contentTypeFromExt(file)
        });
      }
      if (!medias.length) continue;
      items.push({
        _idBase: idBase,
        _sortKey: `days|${num}`,
        categoryId: folderName,
        type: TYPE.DAYS,
        subType: 0,
        isPremium: true,
        coinToUnlock: 0,
        createdAt: baseCreatedAt,
        medias
      });
      baseCreatedAt++;
    }

    // COUPLE items (single OR pair _0/_1)
    for (const [num, obj] of [...coupleByNum.entries()].sort((a,b)=>a[0].localeCompare(b[0]))) {
      const medias = [];

      if (obj.single) {
        medias.push({
          url: cdnUrl(folderName, obj.single),
          name: obj.single,
          thumbUrl: obj.preview ? cdnUrl(folderName, obj.preview) : "",
          contentType: contentTypeFromExt(obj.single)
        });
      } else {
        // pair
        if (obj["0"]) medias.push({ url: cdnUrl(folderName, obj["0"]), name: obj["0"], thumbUrl:"", contentType:"image/webp" });
        if (obj["1"]) medias.push({ url: cdnUrl(folderName, obj["1"]), name: obj["1"], thumbUrl:"", contentType:"image/webp" });
      }

      if (!medias.length) continue;

      // gi·ªØ format id ki·ªÉu c≈© cho couple: folderName_XXX
      const idBase = `${folderName}_${num}`;
      items.push({
        _idBase: idBase,
        _sortKey: `couple|${num}`,
        categoryId: folderName,
        type: TYPE.COUPLE,
        subType: 0,
        isPremium: true,
        coinToUnlock: 0,
        createdAt: baseCreatedAt,
        medias
      });
      baseCreatedAt++;
    }

    // LIVE / STILL items: group by prefix|num
    const allKeys = new Set([...imageByKey.keys(), ...stillByKeyOtherExt.keys(), ...mp4ByKey.keys()]);
    const usedSpecialKeys = new Set(); // keys consumed by days/double/couple? (not needed; they use different patterns)
    const sortedKeys = [...allKeys].sort((a,b)=>{
      // sort by num then prefix
      const [pa,na] = a.split("|");
      const [pb,nb] = b.split("|");
      if (na !== nb) return na.localeCompare(nb);
      return pa.localeCompare(pb);
    });

    for (const key of sortedKeys) {
      if (usedSpecialKeys.has(key)) continue;
      const [prefix, num] = key.split("|");

      const mp4 = mp4ByKey.get(key);
      const img = imageByKey.get(key) || stillByKeyOtherExt.get(key);

      if (!mp4 && !img) continue;

      // decide id:
      // n·∫øu prefix == default prefix -> id folder_num (gi·ªØ nh∆∞ anime_003)
      // n·∫øu prefix kh√°c -> id folder_prefix_num (tr√°nh collision ki·ªÉu cinematic_001 vs super_hero_001)
      let idBase = (prefix === defPrefix) ? `${folderName}_${num}` : `${folderName}_${prefix}_${num}`;

      const isLive = !!mp4;

      if (isLive) {
        const mediaArr = [];
        // mp4
        mediaArr.push({
          url: cdnUrl(folderName, mp4),
          name: mp4,
          thumbUrl: "",
          contentType: contentTypeFromExt(mp4)
        });

        // image fallback (n·∫øu c√≥)
        if (img) {
          const p = previewByKey.get(`${prefix}|${num}`);
          mediaArr.push({
            url: cdnUrl(folderName, img),
            name: img,
            thumbUrl: (usePreviewForLive && p) ? cdnUrl(folderName, p) : "",
            contentType: contentTypeFromExt(img)
          });
        }

        items.push({
          _idBase: idBase,
          _sortKey: `live|${prefix}|${num}`,
          categoryId: folderName,
          type: TYPE.LIVE,
          subType: 0,
          isPremium: true,
          coinToUnlock: 0,
          createdAt: baseCreatedAt,
          medias: mediaArr
        });
        baseCreatedAt++;
      } else {
        // still
        items.push({
          _idBase: idBase,
          _sortKey: `still|${prefix}|${num}`,
          categoryId: folderName,
          type: TYPE.STILL,
          subType: 0,
          isPremium: true,
          coinToUnlock: 0,
          createdAt: baseCreatedAt,
          medias: [{
            url: cdnUrl(folderName, img),
            name: img,
            thumbUrl: "",
            contentType: contentTypeFromExt(img)
          }]
        });
        baseCreatedAt++;
      }
    }

    // remove internal fields later; keep order stable
    items.sort((a,b)=>a._sortKey.localeCompare(b._sortKey,"en"));
    return items;
  }

  function toBase64Bytes(uint8) {
    // chunked btoa to avoid call stack / large string
    let binary = "";
    const chunk = 0x8000;
    for (let i=0;i<uint8.length;i+=chunk) {
      binary += String.fromCharCode.apply(null, uint8.subarray(i,i+chunk));
    }
    return btoa(binary);
  }

  async function upsertTextFile(path, text, message) {
    const token = getAuthToken();
    const apiUrl = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(path)}`;

    // check exists to get sha
    let sha = null;
    try {
      const meta = await fetchJson(apiUrl + `?ref=${encodeURIComponent(BRANCH)}`, true);
      sha = meta?.sha || null;
    } catch (e) {
      // 404 ok => create new
      sha = null;
    }

    const contentB64 = btoa(unescape(encodeURIComponent(text))); // safe for utf-8

    const body = {
      message,
      content: contentB64,
      branch: BRANCH
    };
    if (sha) body.sha = sha;

    const res = await fetch(apiUrl, {
      method: "PUT",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Upsert failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function generateAllJsonAndUpload() {
    const token = getAuthToken(); // ensure token
    const ok = confirm(
      `Generate & upload JSON g·ªôp t·∫•t c·∫£ folder d·∫°ng "xxx_..."?\n\n` +
      `S·∫Ω ghi v√†o: ${OUTPUT_ALL_JSON}\nRepo: ${OWNER}/${REPO}\nBranch: ${BRANCH}\n\n` +
      `‚ö†Ô∏è S·∫Ω overwrite file c≈© n·∫øu c√≥.`
    );
    if (!ok) return;

    const usePreviewForLive = !!elJsonUsePreview.checked;

    setStatus("Generating JSON (ALL)...");

    // folder filter: b·∫Øt ƒë·∫ßu b·∫±ng s·ªë + _
    const numericFolders = allFolders
      .map(x => x.name)
      .filter(name => /^\d+_/.test(name))
      .sort((a,b)=>a.localeCompare(b,"en"));

    const baseTs = Math.floor(Date.now()/1000);
    let cursorTs = baseTs;

    const usedIds = new Set();
    const allItems = [];

    for (const folder of numericFolders) {
      setStatus(`Scanning folder: ${folder} ...`);
      const files = await listFolderFiles(folder);
      const items = buildItemsFromFiles(folder, files, cursorTs, usePreviewForLive);

      // assign unique final id + strip internal fields
      for (const it of items) {
        const desired = it._idBase;
        const id = uniqId(desired, usedIds);
        const out = {
          id,
          medias: it.medias,
          categoryId: it.categoryId,
          isPremium: it.isPremium,
          createdAt: it.createdAt,
          subType: it.subType,
          type: it.type,
          coinToUnlock: it.coinToUnlock
        };
        allItems.push(out);
        cursorTs = Math.max(cursorTs, it.createdAt + 1);
      }
    }

    const jsonText = JSON.stringify(allItems, null, 2);

    setStatus(`Uploading ${OUTPUT_ALL_JSON} ...\nItems: ${allItems.length}`);
    await upsertTextFile(OUTPUT_ALL_JSON, jsonText, `Generate wallpaper.json (${allItems.length} items)`);

    setStatus(
      `‚úÖ Done!\n` +
      `Uploaded: ${OUTPUT_ALL_JSON}\n` +
      `Items: ${allItems.length}\n\n` +
      `URL:\nhttps://tramiune.github.io/${REPO}/${OUTPUT_ALL_JSON}`
    );
    alert("Generate JSON xong ‚úÖ");
  }

  document.getElementById("reload").onclick = () => loadFolders();
  document.getElementById("genAll").onclick = () => {
    generateAllJsonAndUpload().catch(err => {
      console.error(err);
      alert(String(err?.message || err));
      setStatus(String(err?.message || err));
    });
  };

  elQ.addEventListener("input", () => {
    renderFolders(allFolders);
    if (activeFolder) renderGrid(activeFiles);
  });
  elShowPreview.addEventListener("change", () => {
    if (activeFolder) renderGrid(activeFiles);
  });

  loadFolders().catch(err => setStatus(String(err?.message || err)));
</script>
</body>
</html>
