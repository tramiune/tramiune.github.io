<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wallpaper Browser (GitHub API only)</title>
  <style>
    :root { --bd:#e7e7e7; --mut:#666; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    header { padding:12px 14px; border-bottom:1px solid var(--bd); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header b { font-size:14px; }
    header .mut { color:var(--mut); font-size:12px; }
    header input[type="text"], header input[type="password"] {
      padding:8px 10px; border:1px solid var(--bd); border-radius:10px; min-width:220px;
    }
    header button, header a.btn {
      padding:8px 10px; border:1px solid var(--bd); background:#fff; border-radius:10px; cursor:pointer;
      text-decoration:none; color:inherit; display:inline-flex; gap:6px; align-items:center;
    }
    header button:hover, header a.btn:hover { background:#f5f5f5; }
    label.mut { display:inline-flex; gap:6px; align-items:center; }
    input[type="checkbox"] { transform: translateY(1px); }

    .wrap { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 64px); }
    aside { border-right:1px solid var(--bd); padding:10px; overflow:auto; }
    main { padding:12px; overflow:auto; }

    .folder {
      padding:9px 10px; border:1px solid var(--bd); border-radius:12px; cursor:pointer;
      display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;
    }
    .folder:hover { background:#f7f7f7; }
    .folder.active { border-color:#bbb; background:#f5f5f5; }

    .small { font-size:12px; color:var(--mut); }
    .status { font-size:12px; color:var(--mut); white-space:pre-wrap; margin: 6px 0 10px; }

    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(190px, 1fr)); gap:10px; }
    .card { border:1px solid var(--bd); border-radius:14px; overflow:hidden; background:#fff; }
    .thumb { width:100%; aspect-ratio: 9/16; background:#f2f2f2; display:flex; align-items:center; justify-content:center; }
    img, video { width:100%; height:100%; object-fit:cover; display:block; }
    .meta { padding:8px 10px; border-top:1px solid var(--bd); }
    .meta .name { font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .pill { font-size:11px; color:#333; background:#f3f3f3; border:1px solid #e2e2e2; padding:2px 8px; border-radius:999px; display:inline-block; margin-top:6px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .danger { border-color:#f0c1c1 !important; }

    .actions { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    a.btn{
      border:1px solid var(--bd); background:#fff; padding:8px 10px; border-radius:10px;
      cursor:pointer; text-decoration:none; color:inherit; display:inline-flex; gap:6px; align-items:center;
    }
    a.btn:hover{ background:#f5f5f5; }
  </style>
</head>
<body>
<header>
  <b>Wallpaper Browser</b>
  <span class="mut">API-only: list folder/file + load media via GitHub API blob URL</span>

  <input id="q" type="text" placeholder="Filter folder/file..." />

  <input id="token" type="password" placeholder="GitHub Token (Contents: write)" style="min-width:260px" />
  <label class="mut" title="L∆∞u token tr√™n m√°y b·∫°n (localStorage)">
    <input id="remember" type="checkbox" />
    remember token
  </label>

  <label class="mut" title="Hi·ªán file _preview.webp nh∆∞ item ri√™ng">
    <input id="showPreview" type="checkbox" />
    show _preview
  </label>

  <button id="reload">Reload</button>

  <a class="btn" href="./orders.html" target="_blank" rel="noreferrer">üß© Orders</a>
  <button id="genFolderJson">üßæ Generate folder JSON</button>
  <button id="genAllJson">üßæ Generate ALL JSON</button>

  <span class="mut" id="rate"></span>
</header>

<div class="wrap">
  <aside>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <b style="font-size:13px;">Folders</b>
      <span class="small" id="folderCount"></span>
    </div>
    <div id="folders"></div>
  </aside>

  <main>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <div>
        <b id="title" style="font-size:13px;">Ch·ªçn folder</b><br/>
        <span class="small" id="subtitle"></span>
      </div>
      <div class="small" id="itemCount"></div>
    </div>

    <div class="status" id="status"></div>
    <div class="grid" id="grid"></div>
  </main>
</div>

<script>
  /** =========================
   *  CONFIG ‚Äì s·ª≠a ·ªü ƒë√¢y
   *  ========================= */
  const OWNER = "tramiune";
  const REPO  = "tramiune001_res_wallpaper";
  const BRANCH = "main";
  const ROOT_DIR = "resources";

  // N∆°i ghi file json t·ªïng (merge)
  const MERGED_JSON_PATH = "dev/wallpaper.json";

  // CDN ƒë·ªÉ gen url trong JSON (app b·∫°n ƒëang d√πng)
  const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

  const IMAGE_EXT = ["webp","png","jpg","jpeg","gif"];
  const VIDEO_EXT = ["mp4","webm","mov"];
  /** ========================= */

  const elFolders = document.getElementById("folders");
  const elGrid = document.getElementById("grid");
  const elStatus = document.getElementById("status");
  const elTitle = document.getElementById("title");
  const elSubtitle = document.getElementById("subtitle");
  const elFolderCount = document.getElementById("folderCount");
  const elItemCount = document.getElementById("itemCount");
  const elQ = document.getElementById("q");
  const elRate = document.getElementById("rate");
  const elToken = document.getElementById("token");
  const elRemember = document.getElementById("remember");
  const elShowPreview = document.getElementById("showPreview");

  let allFolders = [];
  let activeFolder = null;
  let activeFiles = [];

  /** cache blob url theo "folder/file" */
  const blobUrlCache = new Map(); // key -> { url, ts }
  const MAX_CACHE = 120;

  function setStatus(s) { elStatus.textContent = s || ""; }

  function extOf(name) {
    const i = name.lastIndexOf(".");
    return i >= 0 ? name.slice(i+1).toLowerCase() : "";
  }
  function isMediaFile(name) {
    const e = extOf(name);
    return IMAGE_EXT.includes(e) || VIDEO_EXT.includes(e);
  }
  function isPreviewName(name) { return name.includes("_preview."); }

  function encodePath(path) { return path.split("/").map(encodeURIComponent).join("/"); }
  function ghContentsUrl(path) {
    const p = encodePath(path);
    return `https://api.github.com/repos/${OWNER}/${REPO}/contents/${p}?ref=${encodeURIComponent(BRANCH)}`;
  }

  function getAuthToken() {
    const t = elToken.value.trim();
    if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (c·∫ßn Contents: write).");
    return t;
  }

  async function fetchJson(url, withAuth = false) {
    const headers = { "Accept": "application/vnd.github+json" };
    if (withAuth) headers["Authorization"] = `Bearer ${getAuthToken()}`;

    const res = await fetch(url, { headers });
    const limit = res.headers.get("x-ratelimit-limit");
    const remain = res.headers.get("x-ratelimit-remaining");
    if (limit && remain) elRate.textContent = `GitHub API rate: ${remain}/${limit}`;

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`HTTP ${res.status}\n${txt}`);
    }
    return res.json();
  }

  /** remember token (localStorage) */
  const LS_TOKEN = `wallpaper_browser_token_${OWNER}_${REPO}`;
  (function initRememberToken(){
    const saved = localStorage.getItem(LS_TOKEN);
    if (saved) {
      elToken.value = saved;
      elRemember.checked = true;
    }
    elRemember.addEventListener("change", () => {
      if (elRemember.checked) {
        if (elToken.value.trim()) localStorage.setItem(LS_TOKEN, elToken.value.trim());
      } else {
        localStorage.removeItem(LS_TOKEN);
      }
    });
    elToken.addEventListener("input", () => {
      if (elRemember.checked) localStorage.setItem(LS_TOKEN, elToken.value.trim());
    });
  })();

  /** ---------- MEDIA LOAD via API -> blob URL ---------- */
  async function getBlobUrlForFile(folderName, fileName) {
    const key = `${folderName}/${fileName}`;
    const cached = blobUrlCache.get(key);
    if (cached?.url) return cached.url;

    const token = getAuthToken(); // API-only => b·∫Øt bu·ªôc token
    const filePath = `${ROOT_DIR}/${folderName}/${fileName}`;

    // l·∫•y download_url qua contents API
    const meta = await fetchJson(ghContentsUrl(filePath), true);
    const dl = meta?.download_url;
    if (!dl) throw new Error(`No download_url for ${filePath}`);

    // t·∫£i blob
    let res = await fetch(dl, { headers: { "Authorization": `Bearer ${token}` } }).catch(() => null);
    if (!res || !res.ok) res = await fetch(dl);
    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Download failed: HTTP ${res.status}\n${txt}`);
    }

    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    blobUrlCache.set(key, { url, ts: Date.now() });
    if (blobUrlCache.size > MAX_CACHE) {
      const oldestKey = [...blobUrlCache.entries()].sort((a,b)=>a[1].ts-b[1].ts)[0]?.[0];
      if (oldestKey) {
        const old = blobUrlCache.get(oldestKey);
        try { URL.revokeObjectURL(old.url); } catch {}
        blobUrlCache.delete(oldestKey);
      }
    }
    return url;
  }

  function renderFolders(list) {
    elFolders.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const shown = list.filter(f => f.name.toLowerCase().includes(q));
    elFolderCount.textContent = `${shown.length}/${list.length}`;

    for (const f of shown) {
      const div = document.createElement("div");
      div.className = "folder" + (activeFolder === f.name ? " active" : "");
      div.innerHTML = `<span>üìÅ ${f.name}</span><span class="small">open</span>`;
      div.onclick = () => openFolder(f.name);
      elFolders.appendChild(div);
    }
  }

  /** ---------- DELETE ---------- */
  async function deleteFileOnGitHub(filePath, sha) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`;

    const res = await fetch(url, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ message: `Delete ${filePath}`, sha, branch: BRANCH })
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Delete failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function deleteFileFlow(f) {
    if (!activeFolder) return;
    const filePath = `${ROOT_DIR}/${activeFolder}/${f.name}`;
    const ok = confirm(`Xo√° file kh·ªèi GitHub?\n\n${filePath}\n\n‚ö†Ô∏è Kh√¥ng undo ƒë∆∞·ª£c (tr·ª´ khi b·∫°n git revert).`);
    if (!ok) return;

    setStatus(`Deleting...\n${filePath}`);
    await deleteFileOnGitHub(filePath, f.sha);

    setStatus(`‚úÖ Deleted\n${filePath}`);
    await openFolder(activeFolder);
  }

  /** =========================
   *  ORDERS CONFIG (from orders.html)
   *  ========================= */
  const LS_ORDERS = `wallpaper_orders_${OWNER}_${REPO}`;
  function loadOrdersConfig() {
    try {
      const raw = localStorage.getItem(LS_ORDERS);
      if (!raw) return {};
      const obj = JSON.parse(raw);
      return obj && typeof obj === "object" ? obj : {};
    } catch {
      return {};
    }
  }

  /** =========================
   *  JSON GENERATOR
   *  ========================= */
  function pad3(n) { return String(n).padStart(3, "0"); }

  function isValidStillLiveBase(base) {
    // only allow prefix_### to become item
    return /^.+?_\d{3}$/i.test(base);
  }

  function cdnUrl(folder, file) {
    return `${CDN_BASE}${folder}/${file}`;
  }

  function contentTypeFor(name) {
    const e = extOf(name);
    if (VIDEO_EXT.includes(e)) return "video/mp4";
    if (e === "webp") return "image/webp";
    if (e === "png") return "image/png";
    if (e === "jpg" || e === "jpeg") return "image/jpeg";
    if (e === "gif") return "image/gif";
    return "application/octet-stream";
  }

  function buildItemsForFolder(folderName, files) {
    const cfg = loadOrdersConfig()[folderName] || {};
    const order = Array.isArray(cfg.order) ? cfg.order : [];          // ["101_anime_003", ...]
    const livePreview = cfg.livePreview || {};                        // { "101_anime_003": true/false }
    const baseCreatedAt = Number.isFinite(cfg.baseCreatedAt) ? cfg.baseCreatedAt : Math.floor(Date.now()/1000);

    const fileSet = new Set(files.map(x => x.name));

    // Index helpers
    const previewByBase = new Map(); // baseWebpName -> previewName
    for (const name of fileSet) {
      if (!name.endsWith(".webp")) continue;
      if (!name.includes("_preview.webp")) continue;
      const base = name.replace("_preview.webp", ".webp");
      previewByBase.set(base, name);
    }

    // Groups
    const groups = new Map(); // key: id -> { type, n, ... }
    const ensure = (id, init) => {
      if (!groups.has(id)) groups.set(id, init);
      return groups.get(id);
    };

    // DOUBLE: double_###_0.webp + double_###_1.webp
    for (const name of fileSet) {
      const m = name.match(/^double_(\d{3})_(0|1)\.webp$/i);
      if (!m) continue;
      const n = parseInt(m[1], 10);
      const id = `${folderName}_${m[1]}`;
      const g = ensure(id, { type: 2, n, medias: [] });
      g.medias.push({ name, part: Number(m[2]) });
    }

    // DAYS: days_###_6h.webp / 12h / 18h / 24h
    const hourMap = { "6h":"06:00", "12h":"12:00", "18h":"18:00", "24h":"24:00" };
    for (const name of fileSet) {
      const m = name.match(/^days_(\d{3})_(6h|12h|18h|24h)\.webp$/i);
      if (!m) continue;
      const n = parseInt(m[1], 10);
      const id = `${folderName}_${m[1]}`;
      const g = ensure(id, { type: 3, n, medias: [] });
      g.medias.push({ name, hour: hourMap[m[2]] || "" });
    }

    // COUPLE: couple_###.webp (+ optional couple_###_preview.webp)
    for (const name of fileSet) {
      const m = name.match(/^couple_(\d{3})\.webp$/i);
      if (!m) continue;
      const n = parseInt(m[1], 10);
      const id = `${folderName}_${m[1]}`;
      ensure(id, { type: 4, n, baseWebp: name });
    }

    // LIVE/STILL: prefix_###.mp4 + prefix_###.webp
    // IMPORTANT: ignore couple_###_0.webp etc (don‚Äôt let them fall into still)
    const baseMap = new Map(); // base -> { mp4?, webp? }
    for (const name of fileSet) {
      const e = extOf(name);
      if (e !== "mp4" && e !== "webp") continue;

      const base = name.slice(0, name.lastIndexOf("."));
      if (/^couple_\d{3}_.+/i.test(base)) continue;        // ignore couple_001_0, couple_001_1...
      if (/^double_\d{3}_.+/i.test(name)) continue;
      if (/^days_\d{3}_.+/i.test(name)) continue;
      if (name.includes("_preview.")) continue;

      if (!isValidStillLiveBase(base)) continue;

      const rec = baseMap.get(base) || { mp4:false, webp:false, base };
      if (e === "mp4") rec.mp4 = true;
      if (e === "webp") rec.webp = true;
      baseMap.set(base, rec);
    }

    for (const rec of baseMap.values()) {
      // derive number
      const m = rec.base.match(/_(\d{3})$/);
      if (!m) continue;
      const n = parseInt(m[1], 10);
      const id = `${folderName}_${m[1]}`;

      // don't override if it already is DOUBLE/DAYS/COUPLE
      if (groups.has(id)) continue;

      // LIVE if has mp4 + webp. STILL if only webp.
      if (rec.webp) {
        ensure(id, {
          type: rec.mp4 ? 0 : 1,
          n,
          base: rec.base,
          webpName: `${rec.base}.webp`,
          mp4Name: rec.mp4 ? `${rec.base}.mp4` : null
        });
      }
    }

    // Convert to items
    const items = [];
    const seenId = new Set();

    // ordering helper
    const orderIndex = new Map();
    order.forEach((id, idx) => orderIndex.set(id, idx));

    const sorted = [...groups.entries()].map(([id, g]) => ({ id, ...g }))
      .sort((a,b) => {
        const ia = orderIndex.has(a.id) ? orderIndex.get(a.id) : 1e9;
        const ib = orderIndex.has(b.id) ? orderIndex.get(b.id) : 1e9;
        if (ia !== ib) return ia - ib;
        return (a.n ?? 0) - (b.n ?? 0);
      });

    let t = 0;
    for (const g of sorted) {
      if (seenId.has(g.id)) continue;
      seenId.add(g.id);

      const createdAt = baseCreatedAt + (t++);
      const base = g.id.replace(`${folderName}_`, ""); // "003" etc

      if (g.type === 2) {
        // double
        const medias = (g.medias || [])
          .sort((x,y)=> (x.part ?? 0) - (y.part ?? 0))
          .map(x => ({
            url: cdnUrl(folderName, x.name),
            name: x.name,
            thumbUrl: "",
            contentType: "image/webp"
          }));

        // only accept when has >=2 (avoid half item)
        if (medias.length < 2) continue;

        items.push({
          id: g.id,
          medias,
          categoryId: folderName,
          isPremium: true,
          createdAt,
          subType: 0,
          type: 2,
          coinToUnlock: 0
        });
        continue;
      }

      if (g.type === 3) {
        // days
        const medias = (g.medias || [])
          .filter(x => x.hour)
          .sort((a,b)=> a.hour.localeCompare(b.hour))
          .map(x => ({
            url: cdnUrl(folderName, x.name),
            name: x.name,
            thumbUrl: "",
            hour: x.hour,
            contentType: "image/webp"
          }));

        if (medias.length < 4) continue;

        items.push({
          id: g.id,
          medias,
          categoryId: folderName,
          isPremium: true,
          createdAt,
          subType: 0,
          type: 3,
          coinToUnlock: 0
        });
        continue;
      }

      if (g.type === 4) {
        // couple
        const webp = g.baseWebp;
        const preview = previewByBase.get(webp) || "";
        items.push({
          id: g.id,
          medias: [{
            url: cdnUrl(folderName, webp),
            name: webp,
            thumbUrl: preview ? cdnUrl(folderName, preview) : "",
            contentType: "image/webp"
          }],
          categoryId: folderName,
          isPremium: true,
          createdAt,
          subType: 0,
          type: 4,
          coinToUnlock: 0
        });
        continue;
      }

      if (g.type === 1) {
        // still
        const webp = g.webpName;
        if (!fileSet.has(webp)) continue;
        items.push({
          id: g.id,
          medias: [{
            url: cdnUrl(folderName, webp),
            name: webp,
            thumbUrl: "",
            contentType: "image/webp"
          }],
          categoryId: folderName,
          isPremium: true,
          createdAt,
          subType: 0,
          type: 1,
          coinToUnlock: 0
        });
        continue;
      }

      if (g.type === 0) {
        // live
        const mp4 = g.mp4Name;
        const webp = g.webpName;
        if (!mp4 || !fileSet.has(mp4) || !fileSet.has(webp)) continue;

        const preview = previewByBase.get(webp) || "";
        const includePreview = (livePreview[g.id] !== false); // default true
        const thumbUrl = (includePreview && preview) ? cdnUrl(folderName, preview) : "";

        items.push({
          id: g.id,
          medias: [
            { url: cdnUrl(folderName, mp4), name: mp4, thumbUrl: "", contentType: "video/mp4" },
            { url: cdnUrl(folderName, webp), name: webp, thumbUrl, contentType: "image/webp" }
          ],
          categoryId: folderName,
          isPremium: true,
          createdAt,
          subType: 0,
          type: 0,
          coinToUnlock: 0
        });
        continue;
      }
    }

    return items;
  }

  function base64Utf8(str) {
    // safe base64 for unicode
    return btoa(unescape(encodeURIComponent(str)));
  }

  async function putFileToGitHub(path, contentText) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(path)}`;

    // check existing to get sha
    let sha = null;
    try {
      const meta = await fetchJson(`${url}?ref=${encodeURIComponent(BRANCH)}`, true);
      sha = meta?.sha || null;
    } catch (_) {}

    const body = {
      message: `Update ${path}`,
      content: base64Utf8(contentText),
      branch: BRANCH
    };
    if (sha) body.sha = sha;

    const res = await fetch(url, {
      method: "PUT",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`PUT failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function generateFolderJson(folderName) {
    if (!folderName) throw new Error("B·∫°n ch∆∞a ch·ªçn folder.");
    const folderFiles = activeFiles?.length ? activeFiles : await loadFilesOfFolder(folderName);
    const items = buildItemsForFolder(folderName, folderFiles);

    const json = JSON.stringify(items, null, 2);
    const outPath = `${ROOT_DIR}/${folderName}/${folderName}.json`;

    setStatus(`Generating folder JSON...\n${outPath}\nitems=${items.length}`);
    await putFileToGitHub(outPath, json);
    setStatus(`‚úÖ Done\n${outPath}\nitems=${items.length}`);
  }

  async function loadFilesOfFolder(folderName) {
    const data = await fetchJson(ghContentsUrl(`${ROOT_DIR}/${folderName}`), true);
    return data
      .filter(x => x.type === "file")
      .map(x => ({ name: x.name, size: x.size || 0, sha: x.sha }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));
  }

  async function generateAllJsonMerged() {
    const folders = allFolders
      .map(x => x.name)
      .filter(name => /^\d+_/.test(name)); // only numeric prefix folders

    if (!folders.length) throw new Error("Kh√¥ng th·∫•y folder d·∫°ng 101_..., 102_...");

    setStatus(`Generating ALL JSON...\nfolders=${folders.length}\nOutput: ${MERGED_JSON_PATH}`);

    const allItems = [];
    const seen = new Set();
    const dup = [];

    for (let i=0; i<folders.length; i++) {
      const folder = folders[i];
      setStatus(`Generating ALL JSON...\n[${i+1}/${folders.length}] ${folder}`);

      const files = (activeFolder === folder && activeFiles?.length)
        ? activeFiles
        : await loadFilesOfFolder(folder);

      const items = buildItemsForFolder(folder, files);
      for (const it of items) {
        if (seen.has(it.id)) {
          dup.push(it.id);
          continue;
        }
        seen.add(it.id);
        allItems.push(it);
      }
    }

    // optional: sort by category then id
    allItems.sort((a,b) => {
      if (a.categoryId !== b.categoryId) return a.categoryId.localeCompare(b.categoryId);
      return a.id.localeCompare(b.id);
    });

    const json = JSON.stringify(allItems, null, 2);
    await putFileToGitHub(MERGED_JSON_PATH, json);

    if (dup.length) {
      setStatus(`‚úÖ Done\n${MERGED_JSON_PATH}\nitems=${allItems.length}\n‚ö†Ô∏è Duplicates skipped:\n${dup.slice(0,50).join(", ")}${dup.length>50 ? "\n..." : ""}`);
    } else {
      setStatus(`‚úÖ Done\n${MERGED_JSON_PATH}\nitems=${allItems.length}`);
    }
  }

  /** ---------- GRID ---------- */
  async function renderGrid(files) {
    elGrid.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const showPreview = elShowPreview.checked;

    // preview map
    const previewByBase = new Map();
    for (const f of files) {
      if (!isMediaFile(f.name)) continue;
      if (!isPreviewName(f.name)) continue;
      const base = f.name.replace("_preview.", ".");
      previewByBase.set(base, f.name);
    }

    // mp4 map
    const mp4ByBase = new Map();
    for (const f of files) {
      const e = extOf(f.name);
      if (VIDEO_EXT.includes(e)) {
        const base = f.name.slice(0, f.name.lastIndexOf("."));
        mp4ByBase.set(base, f.name);
      }
    }

    let shown = files
      .filter(f => isMediaFile(f.name))
      .filter(f => f.name.toLowerCase().includes(q));

    if (!showPreview) shown = shown.filter(f => !isPreviewName(f.name));

    elItemCount.textContent = `Items: ${shown.length}`;

    for (const f of shown) {
      const e = extOf(f.name);
      const isVideo = VIDEO_EXT.includes(e);
      const isImage = IMAGE_EXT.includes(e);

      const card = document.createElement("div");
      card.className = "card";

      const thumb = document.createElement("div");
      thumb.className = "thumb";
      thumb.textContent = "Loading...";

      const meta = document.createElement("div");
      meta.className = "meta";

      const maybePreview = previewByBase.get(f.name);
      const labelPreviewHint =
        (!isVideo && !isPreviewName(f.name) && maybePreview) ? " ¬∑ has preview" : "";

      meta.innerHTML = `
        <div class="name" title="${f.name}">${f.name}</div>
        <div class="pill">${isVideo ? "video" : "image"} ¬∑ ${e}${isPreviewName(f.name) ? " ¬∑ preview" : ""}${labelPreviewHint}</div>
      `;

      const actions = document.createElement("div");
      actions.className = "actions";

      // open file (blob)
      const openBtn = document.createElement("a");
      openBtn.className = "btn";
      openBtn.textContent = "üîó Open";
      openBtn.href = "#";
      openBtn.onclick = async (ev) => {
        ev.preventDefault();
        try {
          const url = await getBlobUrlForFile(activeFolder, f.name);
          window.open(url, "_blank", "noopener,noreferrer");
        } catch (err) {
          alert(String(err?.message || err));
        }
      };
      actions.appendChild(openBtn);

      // delete
      const delBtn = document.createElement("button");
      delBtn.textContent = "üóë Delete";
      delBtn.className = "danger";
      delBtn.onclick = async () => {
        try { await deleteFileFlow(f); }
        catch (err) { alert(String(err?.message || err)); }
      };
      actions.appendChild(delBtn);

      // edit video
      if (isVideo) {
        const editBtn = document.createElement("a");
        editBtn.textContent = "‚úÇÔ∏è Edit";
        editBtn.className = "btn";
        editBtn.href = `./video_editor.html?mode=edit&folder=${encodeURIComponent(activeFolder)}&video=${encodeURIComponent(f.name)}`;
        editBtn.target = "_blank";
        actions.appendChild(editBtn);
      }

      // update image from mp4 (GI·ªÆ N√öT UPDATE C·ª¶A B·∫†N)
      const isNormalWebp = isImage && e === "webp" && !isPreviewName(f.name);
      if (isNormalWebp) {
        const base = f.name.slice(0, f.name.lastIndexOf("."));
        const mp4 = mp4ByBase.get(base);
        if (mp4) {
          const updBtn = document.createElement("a");
          updBtn.textContent = "üîÑ Update";
          updBtn.className = "btn";
          updBtn.href =
            `./video_editor.html?mode=replaceImage` +
            `&folder=${encodeURIComponent(activeFolder)}` +
            `&video=${encodeURIComponent(mp4)}` +
            `&target=${encodeURIComponent(f.name)}`;
          updBtn.target = "_blank";
          actions.appendChild(updBtn);
        }
      }

      meta.appendChild(actions);
      card.appendChild(thumb);
      card.appendChild(meta);
      elGrid.appendChild(card);

      // load media blob url and render
      (async () => {
        try {
          const url = await getBlobUrlForFile(activeFolder, f.name);
          thumb.textContent = "";
          if (isVideo) {
            const vv = document.createElement("video");
            vv.src = url;
            vv.controls = true;
            vv.muted = true;
            vv.playsInline = true;
            vv.preload = "metadata";
            thumb.appendChild(vv);
          } else {
            const img = document.createElement("img");
            img.loading = "lazy";
            img.src = url;
            img.alt = f.name;
            thumb.appendChild(img);
          }
        } catch (err) {
          thumb.textContent = "Load failed";
          console.error(err);
        }
      })();
    }
  }

  /** ---------- LOADERS ---------- */
  async function loadFolders() {
    setStatus("Loading folders... (API-only requires token)");
    elTitle.textContent = "Ch·ªçn folder";
    elSubtitle.textContent = `${OWNER}/${REPO}/${ROOT_DIR}`;
    elItemCount.textContent = "";
    elGrid.innerHTML = "";

    const data = await fetchJson(ghContentsUrl(ROOT_DIR), true);

    allFolders = data
      .filter(x => x.type === "dir")
      .map(x => ({ name: x.name, path: x.path }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    renderFolders(allFolders);
    setStatus("");
  }

  async function openFolder(folderName) {
    activeFolder = folderName;
    renderFolders(allFolders);

    elTitle.textContent = `üìÅ ${folderName}`;
    elSubtitle.textContent = `${ROOT_DIR}/${folderName}`;
    setStatus("Loading files...");
    elGrid.innerHTML = "";

    const data = await fetchJson(ghContentsUrl(`${ROOT_DIR}/${folderName}`), true);

    activeFiles = data
      .filter(x => x.type === "file")
      .map(x => ({ name: x.name, size: x.size || 0, sha: x.sha }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    setStatus("");
    await renderGrid(activeFiles);
  }

  document.getElementById("reload").onclick = () => loadFolders();

  elQ.addEventListener("input", () => {
    renderFolders(allFolders);
    if (activeFolder) renderGrid(activeFiles);
  });

  elShowPreview.addEventListener("change", () => {
    if (activeFolder) renderGrid(activeFiles);
  });

  document.getElementById("genFolderJson").onclick = async () => {
    try { await generateFolderJson(activeFolder); }
    catch (e) { alert(String(e?.message || e)); }
  };

  document.getElementById("genAllJson").onclick = async () => {
    try { await generateAllJsonMerged(); }
    catch (e) { alert(String(e?.message || e)); }
  };

  loadFolders().catch(err => setStatus(String(err?.message || err)));
</script>
</body>
</html>
