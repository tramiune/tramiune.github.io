<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wallpaper Browser (GitHub API only)</title>
  <style>
    :root { --bd:#e7e7e7; --mut:#666; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    header { padding:12px 14px; border-bottom:1px solid var(--bd); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header b { font-size:14px; }
    header .mut { color:var(--mut); font-size:12px; }
    header input[type="text"], header input[type="password"] {
      padding:8px 10px; border:1px solid var(--bd); border-radius:10px; min-width:220px;
    }
    header button {
      padding:8px 10px; border:1px solid var(--bd); background:#fff; border-radius:10px; cursor:pointer;
    }
    header button:hover { background:#f5f5f5; }
    label.mut { display:inline-flex; gap:6px; align-items:center; }
    input[type="checkbox"] { transform: translateY(1px); }

    .wrap { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 64px); }
    aside { border-right:1px solid var(--bd); padding:10px; overflow:auto; }
    main { padding:12px; overflow:auto; }

    .folder {
      padding:9px 10px; border:1px solid var(--bd); border-radius:12px; cursor:pointer;
      display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;
    }
    .folder:hover { background:#f7f7f7; }
    .folder.active { border-color:#bbb; background:#f5f5f5; }

    .small { font-size:12px; color:var(--mut); }
    .status { font-size:12px; color:var(--mut); white-space:pre-wrap; margin: 6px 0 10px; }

    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(190px, 1fr)); gap:10px; }
    .card { border:1px solid var(--bd); border-radius:14px; overflow:hidden; background:#fff; }
    .thumb { width:100%; aspect-ratio: 9/16; background:#f2f2f2; display:flex; align-items:center; justify-content:center; }
    img, video { width:100%; height:100%; object-fit:cover; display:block; }
    .meta { padding:8px 10px; border-top:1px solid var(--bd); }
    .meta .name { font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .pill { font-size:11px; color:#333; background:#f3f3f3; border:1px solid #e2e2e2; padding:2px 8px; border-radius:999px; display:inline-block; margin-top:6px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .danger { border-color:#f0c1c1 !important; }

    a.btn{
      border:1px solid var(--bd); background:#fff; padding:8px 10px; border-radius:10px;
      cursor:pointer; text-decoration:none; color:inherit; display:inline-flex; gap:6px; align-items:center;
    }
    a.btn:hover{ background:#f5f5f5; }
  </style>
</head>
<body>
<header>
  <b>Wallpaper Browser</b>
  <span class="mut">API-only: list folder/file + load media via GitHub API blob URL</span>

  <input id="q" type="text" placeholder="Filter folder/file..." />

  <input id="token" type="password" placeholder="GitHub Token (Contents: write)" style="min-width:260px" />
  <label class="mut" title="L∆∞u token tr√™n m√°y b·∫°n (localStorage)">
    <input id="remember" type="checkbox" />
    remember token
  </label>

  <label class="mut" title="Hi·ªán file _preview.webp nh∆∞ item ri√™ng">
    <input id="showPreview" type="checkbox" />
    show _preview
  </label>

  <button id="reload">Reload</button>
  <button id="genJson" title="T·∫°o/C·∫≠p nh·∫≠t file {folder}.json trong folder ƒëang m·ªü">üßæ Generate JSON</button>
  <span class="mut" id="rate"></span>
</header>

<div class="wrap">
  <aside>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <b style="font-size:13px;">Folders</b>
      <span class="small" id="folderCount"></span>
    </div>
    <div id="folders"></div>
  </aside>

  <main>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <div>
        <b id="title" style="font-size:13px;">Ch·ªçn folder</b><br/>
        <span class="small" id="subtitle"></span>
      </div>
      <div class="small" id="itemCount"></div>
    </div>

    <div class="status" id="status"></div>
    <div class="grid" id="grid"></div>
  </main>
</div>

<script>
  /** =========================
   *  CONFIG ‚Äì s·ª≠a ·ªü ƒë√¢y
   *  ========================= */
  const OWNER = "tramiune";
  const REPO  = "tramiune001_res_wallpaper";
  const BRANCH = "main";           // ƒë·ªïi n·∫øu repo b·∫°n l√† master
  const ROOT_DIR = "resources";

  // JSON rule y√™u c·∫ßu d√πng jsdelivr CDN
  const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

  const IMAGE_EXT = ["webp","png","jpg","jpeg","gif"];
  const VIDEO_EXT = ["mp4","webm","mov"];
  /** ========================= */

  const TYPE = {
    STILL: 1,
    LIVE: 0,
    DOUBLE: 2,
    DAYS: 3,
    COUPLE: 4
  };

  const elFolders = document.getElementById("folders");
  const elGrid = document.getElementById("grid");
  const elStatus = document.getElementById("status");
  const elTitle = document.getElementById("title");
  const elSubtitle = document.getElementById("subtitle");
  const elFolderCount = document.getElementById("folderCount");
  const elItemCount = document.getElementById("itemCount");
  const elQ = document.getElementById("q");
  const elRate = document.getElementById("rate");
  const elToken = document.getElementById("token");
  const elRemember = document.getElementById("remember");
  const elShowPreview = document.getElementById("showPreview");
  const elGenJson = document.getElementById("genJson");

  let allFolders = [];
  let activeFolder = null;
  let activeFiles = [];

  /** cache blob url theo "folder/file" */
  const blobUrlCache = new Map(); // key -> { url, ts }
  const MAX_CACHE = 120;

  function setStatus(s) { elStatus.textContent = s || ""; }
  function extOf(name) {
    const i = name.lastIndexOf(".");
    return i >= 0 ? name.slice(i+1).toLowerCase() : "";
  }
  function isMediaFile(name) {
    const e = extOf(name);
    return IMAGE_EXT.includes(e) || VIDEO_EXT.includes(e);
  }
  function isPreviewName(name) { return name.includes("_preview."); }

  function encodePath(path) { return path.split("/").map(encodeURIComponent).join("/"); }
  function ghContentsUrl(path) {
    const p = encodePath(path);
    return `https://api.github.com/repos/${OWNER}/${REPO}/contents/${p}?ref=${encodeURIComponent(BRANCH)}`;
  }

  function getAuthToken() {
    const t = elToken.value.trim();
    if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (c·∫ßn Contents: write).");
    return t;
  }

  async function fetchJson(url, withAuth = false) {
    const headers = { "Accept": "application/vnd.github+json" };
    if (withAuth) headers["Authorization"] = `Bearer ${getAuthToken()}`;

    const res = await fetch(url, { headers });
    const limit = res.headers.get("x-ratelimit-limit");
    const remain = res.headers.get("x-ratelimit-remaining");
    if (limit && remain) elRate.textContent = `GitHub API rate: ${remain}/${limit}`;

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`HTTP ${res.status}\n${txt}`);
    }
    return res.json();
  }

  /** remember token (localStorage) */
  const LS_KEY = `wallpaper_browser_token_${OWNER}_${REPO}`;
  (function initRememberToken(){
    const saved = localStorage.getItem(LS_KEY);
    if (saved) {
      elToken.value = saved;
      elRemember.checked = true;
    }
    elRemember.addEventListener("change", () => {
      if (elRemember.checked) {
        if (elToken.value.trim()) localStorage.setItem(LS_KEY, elToken.value.trim());
      } else {
        localStorage.removeItem(LS_KEY);
      }
    });
    elToken.addEventListener("input", () => {
      if (elRemember.checked) localStorage.setItem(LS_KEY, elToken.value.trim());
    });
  })();

  /** ---------- MEDIA LOAD via API -> blob URL ---------- */
  async function getBlobUrlForFile(folderName, fileName) {
    const key = `${folderName}/${fileName}`;
    const cached = blobUrlCache.get(key);
    if (cached?.url) return cached.url;

    const token = getAuthToken(); // API-only => b·∫Øt bu·ªôc token
    const filePath = `${ROOT_DIR}/${folderName}/${fileName}`;

    // l·∫•y download_url qua contents API
    const meta = await fetchJson(ghContentsUrl(filePath), true);
    const dl = meta?.download_url;
    if (!dl) throw new Error(`No download_url for ${filePath}`);

    // t·∫£i blob
    const res = await fetch(dl, { headers: { "Authorization": `Bearer ${token}` } }).catch(() => fetch(dl));
    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Download failed: HTTP ${res.status}\n${txt}`);
    }
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    blobUrlCache.set(key, { url, ts: Date.now() });
    // gi·ªõi h·∫°n cache
    if (blobUrlCache.size > MAX_CACHE) {
      const oldestKey = [...blobUrlCache.entries()].sort((a,b)=>a[1].ts-b[1].ts)[0]?.[0];
      if (oldestKey) {
        const old = blobUrlCache.get(oldestKey);
        try { URL.revokeObjectURL(old.url); } catch {}
        blobUrlCache.delete(oldestKey);
      }
    }

    return url;
  }

  function renderFolders(list) {
    elFolders.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const shown = list.filter(f => f.name.toLowerCase().includes(q));
    elFolderCount.textContent = `${shown.length}/${list.length}`;

    for (const f of shown) {
      const div = document.createElement("div");
      div.className = "folder" + (activeFolder === f.name ? " active" : "");
      div.innerHTML = `<span>üìÅ ${f.name}</span><span class="small">open</span>`;
      div.onclick = () => openFolder(f.name);
      elFolders.appendChild(div);
    }
  }

  /** ---------- DELETE ---------- */
  async function deleteFileOnGitHub(filePath, sha) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`;

    const res = await fetch(url, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ message: `Delete ${filePath}`, sha, branch: BRANCH })
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Delete failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function deleteFileFlow(f) {
    if (!activeFolder) return;
    const filePath = `${ROOT_DIR}/${activeFolder}/${f.name}`;

    const ok = confirm(`Xo√° file kh·ªèi GitHub?\n\n${filePath}\n\n‚ö†Ô∏è Kh√¥ng undo ƒë∆∞·ª£c (tr·ª´ khi b·∫°n git revert).`);
    if (!ok) return;

    setStatus(`Deleting...\n${filePath}`);
    await deleteFileOnGitHub(filePath, f.sha);

    setStatus(`‚úÖ Deleted\n${filePath}`);
    await openFolder(activeFolder);
  }

  /** ---------- GRID ---------- */
  async function renderGrid(files) {
    elGrid.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const showPreview = elShowPreview.checked;

    // preview map
    const previewByBase = new Map();
    for (const f of files) {
      if (!isMediaFile(f.name)) continue;
      if (!isPreviewName(f.name)) continue;
      const base = f.name.replace("_preview.", ".");
      previewByBase.set(base, f.name);
    }

    // mp4 map
    const mp4ByBase = new Map();
    for (const f of files) {
      const e = extOf(f.name);
      if (VIDEO_EXT.includes(e)) {
        const base = f.name.slice(0, f.name.lastIndexOf("."));
        mp4ByBase.set(base, f.name);
      }
    }

    let shown = files
      .filter(f => isMediaFile(f.name))
      .filter(f => f.name.toLowerCase().includes(q));

    if (!showPreview) shown = shown.filter(f => !isPreviewName(f.name));

    elItemCount.textContent = `Items: ${shown.length}`;

    for (const f of shown) {
      const e = extOf(f.name);
      const isVideo = VIDEO_EXT.includes(e);
      const isImage = IMAGE_EXT.includes(e);

      const card = document.createElement("div");
      card.className = "card";

      const thumb = document.createElement("div");
      thumb.className = "thumb";
      thumb.textContent = "Loading...";

      const meta = document.createElement("div");
      meta.className = "meta";

      const maybePreview = previewByBase.get(f.name);
      const labelPreviewHint =
        (!isVideo && !isPreviewName(f.name) && maybePreview) ? " ¬∑ has preview" : "";

      meta.innerHTML = `
        <div class="name" title="${f.name}">${f.name}</div>
        <div class="pill">${isVideo ? "video" : "image"} ¬∑ ${e}${isPreviewName(f.name) ? " ¬∑ preview" : ""}${labelPreviewHint}</div>
      `;

      const actions = document.createElement("div");
      actions.style.display = "flex";
      actions.style.gap = "8px";
      actions.style.flexWrap = "wrap";
      actions.style.marginTop = "8px";

      // open file (blob)
      const openBtn = document.createElement("a");
      openBtn.className = "btn";
      openBtn.textContent = "üîó Open";
      openBtn.href = "#";
      openBtn.onclick = async (ev) => {
        ev.preventDefault();
        try {
          const url = await getBlobUrlForFile(activeFolder, f.name);
          window.open(url, "_blank", "noopener,noreferrer");
        } catch (err) {
          alert(String(err?.message || err));
        }
      };
      actions.appendChild(openBtn);

      // delete
      const delBtn = document.createElement("button");
      delBtn.textContent = "üóë Delete";
      delBtn.className = "danger";
      delBtn.onclick = async () => {
        try { await deleteFileFlow(f); }
        catch (err) { alert(String(err?.message || err)); }
      };
      actions.appendChild(delBtn);

      meta.appendChild(actions);
      card.appendChild(thumb);
      card.appendChild(meta);
      elGrid.appendChild(card);

      // load media blob url and render
      (async () => {
        try {
          const url = await getBlobUrlForFile(activeFolder, f.name);
          thumb.textContent = "";
          if (isVideo) {
            const vv = document.createElement("video");
            vv.src = url;
            vv.controls = true;
            vv.muted = true;
            vv.playsInline = true;
            vv.preload = "metadata";
            thumb.appendChild(vv);
          } else {
            const img = document.createElement("img");
            img.loading = "lazy";
            img.src = url;
            img.alt = f.name;
            thumb.appendChild(img);
          }
        } catch (err) {
          thumb.textContent = "Load failed";
          console.error(err);
        }
      })();
    }
  }

  /** ---------- JSON GENERATOR (same folder) ---------- */

  function pad3(n) { return String(n).padStart(3, "0"); }

  function mimeFromExt(ext) {
    ext = (ext || "").toLowerCase();
    if (ext === "mp4") return "video/mp4";
    if (ext === "webm") return "video/webm";
    if (ext === "mov") return "video/quicktime";
    if (ext === "webp") return "image/webp";
    if (ext === "png") return "image/png";
    if (ext === "jpg" || ext === "jpeg") return "image/jpeg";
    if (ext === "gif") return "image/gif";
    return "application/octet-stream";
  }

  function cdnUrl(folder, file) {
    return `${CDN_BASE}${folder}/${file}`;
  }

  function guessCoupleType(folder, baseName) {
    const f = (folder || "").toLowerCase();
    const b = (baseName || "").toLowerCase();
    return (f.includes("couple") || b.startsWith("couple_")) ? TYPE.COUPLE : null;
  }

  function parseBaseAndIndex(name) {
    // expects something like anime_003.webp or anime_003.mp4
    const m = name.match(/^(.+?)_(\d{3})\.(\w+)$/i);
    if (!m) return null;
    return { prefix: m[1], idx: Number(m[2]), ext: m[3].toLowerCase(), base: `${m[1]}_${m[2]}` };
  }

  function parseDouble(name) {
    // double_001_0.webp / double_001_1.webp (prefix arbitrary)
    const m = name.match(/^(.+?)_(\d{3})_(0|1)\.webp$/i);
    if (!m) return null;
    return { prefix: m[1], idx: Number(m[2]), part: Number(m[3]), base: `${m[1]}_${m[2]}` };
  }

  function parseDays(name) {
    // days_001_6h.webp / ..._12h.webp / ..._18h.webp / ..._24h.webp
    const m = name.match(/^(.+?)_(\d{3})_(6h|12h|18h|24h)\.webp$/i);
    if (!m) return null;
    const hourKey = m[3].toLowerCase();
    const hourMap = { "6h":"06:00", "12h":"12:00", "18h":"18:00", "24h":"24:00" };
    return { prefix: m[1], idx: Number(m[2]), hourKey, hour: hourMap[hourKey] || "", base: `${m[1]}_${m[2]}` };
  }

  function buildCategoryJsonItems(folder, files) {
    // collect existence
    const fileSet = new Set(files.map(x => x.name));

    // preview map base -> previewFileName (base with .webp replacement logic)
    const previewByWebp = new Map(); // key: "<base>.webp" -> "<base>_preview.webp"
    for (const fn of fileSet) {
      if (!fn.toLowerCase().endsWith(".webp")) continue;
      if (!isPreviewName(fn)) continue;
      const baseWebp = fn.replace("_preview.webp", ".webp");
      previewByWebp.set(baseWebp, fn);
    }

    // group maps
    const doubleGroups = new Map(); // base -> {0:file,1:file}
    const daysGroups = new Map();   // base -> {hourKey:file,hour:string}
    const liveGroups = new Map();   // base -> { mp4?, webp? }

    // First pass: detect DOUBLE and DAYS explicitly
    for (const fn of fileSet) {
      if (isPreviewName(fn)) continue;

      const d = parseDouble(fn);
      if (d) {
        if (!doubleGroups.has(d.base)) doubleGroups.set(d.base, {});
        doubleGroups.get(d.base)[String(d.part)] = fn;
        continue;
      }

      const day = parseDays(fn);
      if (day) {
        if (!daysGroups.has(day.base)) daysGroups.set(day.base, []);
        daysGroups.get(day.base).push({ file: fn, hour: day.hour, hourKey: day.hourKey });
        continue;
      }
    }

    // Second pass: detect LIVE/STILL candidates (base_###)
    for (const fn of fileSet) {
      if (isPreviewName(fn)) continue;

      const p = parseBaseAndIndex(fn);
      if (!p) continue;

      // if this base is already DAYS/DOUBLE (because those have extra suffix), skip
      // NOTE: DAYS/DOUBLE filenames don't match parseBaseAndIndex anyway, so safe
      if (!liveGroups.has(p.base)) liveGroups.set(p.base, { base: p.base, mp4: null, webp: null });
      const g = liveGroups.get(p.base);
      if (p.ext === "mp4") g.mp4 = fn;
      if (p.ext === "webp") g.webp = fn;
    }

    const now = Math.floor(Date.now() / 1000);

    const items = [];

    // Build DOUBLE items
    for (const [base, parts] of doubleGroups.entries()) {
      // require 0 and 1 to consider complete; if missing, still include what exists
      const medias = [];
      if (parts["0"]) medias.push({
        url: cdnUrl(folder, parts["0"]),
        name: parts["0"],
        thumbUrl: "",
        contentType: "image/webp"
      });
      if (parts["1"]) medias.push({
        url: cdnUrl(folder, parts["1"]),
        name: parts["1"],
        thumbUrl: "",
        contentType: "image/webp"
      });

      if (medias.length === 0) continue;

      const coupleOverride = guessCoupleType(folder, base);
      items.push({
        id: `${folder}_${base.split("_").pop()}`, // folder_001 ki·ªÉu m·∫´u
        medias,
        categoryId: folder,
        isPremium: true,
        createdAt: now,
        subType: 0,
        type: coupleOverride ?? TYPE.DOUBLE,
        coinToUnlock: 0
      });
    }

    // Build DAYS items
    for (const [base, arr] of daysGroups.entries()) {
      const sorted = arr.slice().sort((a,b)=> {
        const order = { "6h":6, "12h":12, "18h":18, "24h":24 };
        return (order[a.hourKey]||0) - (order[b.hourKey]||0);
      });
      const medias = sorted.map(x => ({
        url: cdnUrl(folder, x.file),
        name: x.file,
        thumbUrl: "",
        hour: x.hour,
        contentType: "image/webp"
      }));
      if (medias.length === 0) continue;

      const coupleOverride = guessCoupleType(folder, base);
      items.push({
        id: `${folder}_${base.split("_").pop()}`,
        medias,
        categoryId: folder,
        isPremium: true,
        createdAt: now,
        subType: 0,
        type: coupleOverride ?? TYPE.DAYS,
        coinToUnlock: 0
      });
    }

    // Build LIVE/STILL/COUPLE items
    for (const [base, g] of liveGroups.entries()) {
      // Need at least webp or mp4 to create item
      if (!g.mp4 && !g.webp) continue;

      // determine type:
      let t = null;
      const coupleOverride = guessCoupleType(folder, base);
      if (coupleOverride != null) {
        // couple folder => treat as COUPLE always (even if only webp)
        t = TYPE.COUPLE;
      } else if (g.mp4) {
        t = TYPE.LIVE;
      } else {
        t = TYPE.STILL;
      }

      // medias build
      const medias = [];

      if (t === TYPE.LIVE) {
        // mp4
        medias.push({
          url: cdnUrl(folder, g.mp4),
          name: g.mp4,
          thumbUrl: "",
          contentType: mimeFromExt("mp4")
        });

        // webp (prefer base.webp; if missing, try same base .webp)
        const webpName = g.webp || `${base}.webp`;
        const thumb = previewByWebp.get(webpName) ? cdnUrl(folder, previewByWebp.get(webpName)) : "";
        medias.push({
          url: cdnUrl(folder, webpName),
          name: webpName,
          thumbUrl: thumb,
          contentType: "image/webp"
        });
      } else {
        // STILL / COUPLE => only webp
        const webpName = g.webp || `${base}.webp`;
        const thumb = previewByWebp.get(webpName) ? cdnUrl(folder, previewByWebp.get(webpName)) : "";
        medias.push({
          url: cdnUrl(folder, webpName),
          name: webpName,
          thumbUrl: thumb,
          contentType: "image/webp"
        });
      }

      // If base.webp doesn't exist in folder, skip to avoid broken url
      // (for LIVE you may still want mp4 only; but your examples always have webp)
      const needsWebp = (t !== TYPE.DAYS && t !== TYPE.DOUBLE);
      if (needsWebp) {
        const webpName = (t === TYPE.LIVE) ? medias[1]?.name : medias[0]?.name;
        if (webpName && !fileSet.has(webpName)) {
          // if missing, do not include this item
          continue;
        }
      }

      items.push({
        id: `${folder}_${base.split("_").pop()}`,
        medias,
        categoryId: folder,
        isPremium: true,
        createdAt: now,
        subType: 0,
        type: t,
        coinToUnlock: 0
      });
    }

    // sort by id numeric
    items.sort((a,b)=>{
      const ai = Number((a.id||"").split("_").pop()) || 0;
      const bi = Number((b.id||"").split("_").pop()) || 0;
      return ai - bi;
    });

    // createdAt incremental for stable uniqueness (optional)
    for (let i=0;i<items.length;i++){
      items[i].createdAt = now + i;
    }

    return items;
  }

  function base64EncodeUtf8(str) {
    // utf8 safe base64
    const bytes = new TextEncoder().encode(str);
    let binary = "";
    for (const b of bytes) binary += String.fromCharCode(b);
    return btoa(binary);
  }

  async function getExistingFileSha(repoPath) {
    try {
      const meta = await fetchJson(ghContentsUrl(repoPath), true);
      if (meta && meta.sha) return meta.sha;
      return null;
    } catch (e) {
      // 404 => not exist
      const msg = String(e?.message || e);
      if (msg.includes("HTTP 404")) return null;
      return null;
    }
  }

  async function putFileToGitHub(repoPath, contentText, commitMsg) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(repoPath)}`;

    const sha = await getExistingFileSha(repoPath);
    const body = {
      message: commitMsg,
      content: base64EncodeUtf8(contentText),
      branch: BRANCH
    };
    if (sha) body.sha = sha;

    const res = await fetch(url, {
      method: "PUT",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`PUT failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function generateJsonForActiveFolder() {
    if (!activeFolder) {
      alert("B·∫°n ch∆∞a ch·ªçn folder.");
      return;
    }
    if (!activeFiles?.length) {
      alert("Folder ƒëang tr·ªëng ho·∫∑c ch∆∞a load.");
      return;
    }

    // build items from activeFiles (includes non-media too -> generator ignores)
    const items = buildCategoryJsonItems(activeFolder, activeFiles);

    const jsonText = JSON.stringify(items, null, 2);
    const jsonFileName = `${activeFolder}.json`;
    const repoPath = `${ROOT_DIR}/${activeFolder}/${jsonFileName}`;

    const ok = confirm(
      `Generate & upload JSON?\n\n` +
      `Folder: ${activeFolder}\n` +
      `File: ${repoPath}\n` +
      `Items: ${items.length}\n\n` +
      `‚ö†Ô∏è S·∫Ω t·∫°o m·ªõi ho·∫∑c ghi ƒë√® file JSON trong repo.`
    );
    if (!ok) return;

    setStatus(`Generating JSON...\n${repoPath}\nitems=${items.length}`);
    await putFileToGitHub(repoPath, jsonText, `Generate ${jsonFileName}`);
    setStatus(`‚úÖ Generated!\n${repoPath}\nitems=${items.length}\n\nTip: reload folder ƒë·ªÉ th·∫•y file JSON.`);
    await openFolder(activeFolder);
  }

  /** ---------- LOADERS ---------- */
  async function loadFolders() {
    setStatus("Loading folders... (API-only requires token)");
    elTitle.textContent = "Ch·ªçn folder";
    elSubtitle.textContent = `${OWNER}/${REPO}/${ROOT_DIR}`;
    elItemCount.textContent = "";
    elGrid.innerHTML = "";

    // API-only => d√πng auth ƒë·ªÉ rate-limit cao h∆°n v√† tr√°nh fail
    const data = await fetchJson(ghContentsUrl(ROOT_DIR), true);

    allFolders = data
      .filter(x => x.type === "dir")
      .map(x => ({ name: x.name, path: x.path }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    renderFolders(allFolders);
    setStatus("");
  }

  async function openFolder(folderName) {
    activeFolder = folderName;
    renderFolders(allFolders);

    elTitle.textContent = `üìÅ ${folderName}`;
    elSubtitle.textContent = `${ROOT_DIR}/${folderName}`;
    setStatus("Loading files...");
    elGrid.innerHTML = "";

    const path = `${ROOT_DIR}/${folderName}`;
    const data = await fetchJson(ghContentsUrl(path), true);

    activeFiles = data
      .filter(x => x.type === "file")
      .map(x => ({ name: x.name, size: x.size || 0, sha: x.sha }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    setStatus("");
    await renderGrid(activeFiles);
  }

  document.getElementById("reload").onclick = () => loadFolders();
  elGenJson.onclick = async () => {
    try { await generateJsonForActiveFolder(); }
    catch (e) { alert(String(e?.message || e)); }
  };

  elQ.addEventListener("input", () => {
    renderFolders(allFolders);
    if (activeFolder) renderGrid(activeFiles);
  });
  elShowPreview.addEventListener("change", () => {
    if (activeFolder) renderGrid(activeFiles);
  });

  loadFolders().catch(err => setStatus(String(err?.message || err)));
</script>
</body>
</html>
