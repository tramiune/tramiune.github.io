<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wallpaper Browser</title>
  <style>
    :root { --bd:#e7e7e7; --mut:#666; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    header { padding:12px 14px; border-bottom:1px solid var(--bd); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header b { font-size:14px; }
    header .mut { color:var(--mut); font-size:12px; }
    header input[type="text"], header input[type="password"] {
      padding:8px 10px; border:1px solid var(--bd); border-radius:10px; min-width:220px;
    }
    header button {
      padding:8px 10px; border:1px solid var(--bd); background:#fff; border-radius:10px; cursor:pointer;
    }
    header button:hover { background:#f5f5f5; }
    label.mut { display:inline-flex; gap:6px; align-items:center; }
    input[type="checkbox"] { transform: translateY(1px); }
    .wrap { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 64px); }
    aside { border-right:1px solid var(--bd); padding:10px; overflow:auto; }
    main { padding:12px; overflow:auto; }
    .folder {
      padding:9px 10px; border:1px solid var(--bd); border-radius:12px; cursor:pointer;
      display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;
    }
    .folder:hover { background:#f7f7f7; }
    .folder.active { border-color:#bbb; background:#f5f5f5; }
    .small { font-size:12px; color:var(--mut); }
    .status { font-size:12px; color:var(--mut); white-space:pre-wrap; margin: 6px 0 10px; }

    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(190px, 1fr)); gap:10px; }
    .card { border:1px solid var(--bd); border-radius:14px; overflow:hidden; background:#fff; }
    .thumb { width:100%; aspect-ratio: 9/16; background:#f2f2f2; display:flex; align-items:center; justify-content:center; }
    img { width:100%; height:100%; object-fit:cover; display:block; }
    video { width:100%; height:100%; object-fit:cover; display:block; }
    .meta { padding:8px 10px; border-top:1px solid var(--bd); }
    .meta .name { font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .pill { font-size:11px; color:#333; background:#f3f3f3; border:1px solid #e2e2e2; padding:2px 8px; border-radius:999px; display:inline-block; margin-top:6px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    a { color: inherit; }
    .danger { border-color:#f0c1c1 !important; }
  </style>
</head>
<body>
<header>
  <b>Wallpaper Browser</b>
  <span class="mut">List folder ‚Üí click ‚Üí show ·∫£nh/video (GitHub Contents API)</span>

  <input id="q" type="text" placeholder="Filter folder/file..." />

  <input id="token" type="password" placeholder="GitHub Token (Contents: write)" style="min-width:260px" />
  <label class="mut" title="L∆∞u token tr√™n m√°y b·∫°n (localStorage)">
    <input id="remember" type="checkbox" />
    remember token
  </label>

  <label class="mut" title="Hi·ªán file _preview.webp nh∆∞ item ri√™ng">
    <input id="showPreview" type="checkbox" />
    show _preview
  </label>

  <button id="reload">Reload</button>
  <span class="mut" id="rate"></span>
</header>

<div class="wrap">
  <aside>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <b style="font-size:13px;">Folders</b>
      <span class="small" id="folderCount"></span>
    </div>
    <div id="folders"></div>
  </aside>

  <main>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <div>
        <b id="title" style="font-size:13px;">Ch·ªçn folder</b><br/>
        <span class="small" id="subtitle"></span>
      </div>
      <div class="small" id="itemCount"></div>
    </div>

    <div class="status" id="status"></div>
    <div class="grid" id="grid"></div>
  </main>
</div>

<script>
  /** =========================
   *  CONFIG ‚Äì s·ª≠a ·ªü ƒë√¢y
   *  ========================= */
  const OWNER = "tramiune";
  const REPO  = "tramiune001_res_wallpaper";
  const BRANCH = "main";      // n·∫øu repo b·∫°n l√† master th√¨ ƒë·ªïi l·∫°i
  const ROOT_DIR = "resources";
  const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

  const IMAGE_EXT = ["webp","png","jpg","jpeg","gif"];
  const VIDEO_EXT = ["mp4","webm","mov"];
  /** ========================= */

  const elFolders = document.getElementById("folders");
  const elGrid = document.getElementById("grid");
  const elStatus = document.getElementById("status");
  const elTitle = document.getElementById("title");
  const elSubtitle = document.getElementById("subtitle");
  const elFolderCount = document.getElementById("folderCount");
  const elItemCount = document.getElementById("itemCount");
  const elQ = document.getElementById("q");
  const elRate = document.getElementById("rate");
  const elToken = document.getElementById("token");
  const elRemember = document.getElementById("remember");
  const elShowPreview = document.getElementById("showPreview");

  let allFolders = [];
  let activeFolder = null;
  let activeFiles = [];

  function setStatus(s) { elStatus.textContent = s || ""; }

  /** Encode t·ª´ng segment, gi·ªØ nguy√™n d·∫•u "/" */
  function encodePath(path) {
    return path.split("/").map(encodeURIComponent).join("/");
  }

  function extOf(name) {
    const i = name.lastIndexOf(".");
    return i >= 0 ? name.slice(i+1).toLowerCase() : "";
  }
  function isMediaFile(name) {
    const e = extOf(name);
    return IMAGE_EXT.includes(e) || VIDEO_EXT.includes(e);
  }
  function isPreviewName(name) {
    return name.includes("_preview.");
  }

  function ghApiContents(path) {
    // IMPORTANT: kh√¥ng encode c·∫£ chu·ªói b·∫±ng encodeURIComponent v√¨ s·∫Ω bi·∫øn "/" th√†nh "%2F"
    const p = encodePath(path);
    return `https://api.github.com/repos/${OWNER}/${REPO}/contents/${p}?ref=${encodeURIComponent(BRANCH)}`;
  }

  async function fetchJson(url) {
    const res = await fetch(url, { headers: { "Accept": "application/vnd.github+json" } });
    const limit = res.headers.get("x-ratelimit-limit");
    const remain = res.headers.get("x-ratelimit-remaining");
    if (limit && remain) elRate.textContent = `GitHub API rate: ${remain}/${limit}`;
    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`HTTP ${res.status} when GET ${url}\n${txt}`);
    }
    return res.json();
  }

  function renderFolders(list) {
    elFolders.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const shown = list.filter(f => f.name.toLowerCase().includes(q));
    elFolderCount.textContent = `${shown.length}/${list.length}`;

    for (const f of shown) {
      const div = document.createElement("div");
      div.className = "folder" + (activeFolder === f.name ? " active" : "");
      div.innerHTML = `<span>üìÅ ${f.name}</span><span class="small">open</span>`;
      div.onclick = () => openFolder(f.name);
      elFolders.appendChild(div);
    }
  }

  function mediaUrl(folderName, fileName) {
    return `${CDN_BASE}${folderName}/${fileName}`;
  }

  function renderGrid(files) {
  elGrid.innerHTML = "";
  const q = elQ.value.trim().toLowerCase();
  const showPreview = elShowPreview.checked;

  // map: baseFile -> previewFile
  const previewByBase = new Map();
  for (const f of files) {
    if (!isMediaFile(f.name)) continue;
    if (!isPreviewName(f.name)) continue;
    const base = f.name.replace("_preview.", ".");
    previewByBase.set(base, f.name);
  }

  let shown = files
    .filter(f => isMediaFile(f.name))
    .filter(f => f.name.toLowerCase().includes(q));

  if (!showPreview) {
    shown = shown.filter(f => !isPreviewName(f.name));
  }

  elItemCount.textContent = `Items: ${shown.length}`;

  for (const f of shown) {
    const e = extOf(f.name);
    const isVideo = VIDEO_EXT.includes(e);

    const card = document.createElement("div");
    card.className = "card";

    /* ---------- THUMB ---------- */
    const thumb = document.createElement("div");
    thumb.className = "thumb";

    const maybePreview = previewByBase.get(f.name);
    const srcUrl = mediaUrl(activeFolder, f.name);

    if (isVideo) {
      const v = document.createElement("video");
      v.src = srcUrl;
      v.controls = true;
      v.muted = true;
      v.playsInline = true;
      v.preload = "metadata";
      thumb.appendChild(v);
    } else {
      const img = document.createElement("img");
      img.loading = "lazy";
      img.src = srcUrl;
      img.alt = f.name;
      thumb.appendChild(img);
    }

    /* ---------- META ---------- */
    const meta = document.createElement("div");
    meta.className = "meta";
    meta.innerHTML = `
      <div class="name" title="${f.name}">${f.name}</div>
      <div class="pill">
        ${isVideo ? "video" : "image"} ¬∑ ${e}${isPreviewName(f.name) ? " ¬∑ preview" : ""}
      </div>
      <div class="small" style="margin-top:6px;">
        <a href="${mediaUrl(activeFolder, f.name)}" target="_blank" rel="noreferrer">
          open file
        </a>
      </div>
    `;

    /* ---------- ACTIONS ---------- */
    const actions = document.createElement("div");
    actions.style.display = "flex";
    actions.style.gap = "8px";
    actions.style.flexWrap = "wrap";
    actions.style.marginTop = "8px";

    // üóë Delete
    const delBtn = document.createElement("button");
    delBtn.textContent = "üóë Delete";
    delBtn.className = "danger";
    delBtn.onclick = async () => {
      try {
        await deleteFileFlow(f);
      } catch (err) {
        alert(String(err?.message || err));
      }
    };
    actions.appendChild(delBtn);

    // ‚úÇÔ∏è Edit (CH·ªà CHO VIDEO)
    if (isVideo) {
      const editBtn = document.createElement("a");
      editBtn.textContent = "‚úÇÔ∏è Edit";
      editBtn.className = "btn";
      editBtn.href =
        `./video_editor.html` +
        `?folder=${encodeURIComponent(activeFolder)}` +
        `&file=${encodeURIComponent(f.name)}`;
      editBtn.target = "_blank"; // m·ªü tab m·ªõi cho ti·ªán
      actions.appendChild(editBtn);
    }

    meta.appendChild(actions);

    /* ---------- BUILD ---------- */
    card.appendChild(thumb);
    card.appendChild(meta);
    elGrid.appendChild(card);
  }
}


  function getAuthToken() {
    const t = elToken.value.trim();
    if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (c·∫ßn Contents: write).");
    return t;
  }

  /** L·∫•y sha m·ªõi nh·∫•t c·ªßa file tr√™n branch ƒë·ªÉ tr√°nh mismatch */
  async function getFileSha(filePath) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}?ref=${encodeURIComponent(BRANCH)}`;

    const res = await fetch(url, {
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json"
      }
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Get SHA failed: HTTP ${res.status}\n${txt}`);
    }
    const j = await res.json();
    if (!j?.sha) throw new Error("Get SHA failed: response thi·∫øu sha");
    return j.sha;
  }

  async function deleteFileOnGitHub(filePath) {
    const token = getAuthToken();
    const sha = await getFileSha(filePath);

    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`;

    console.log("DELETE PATH:", filePath, "BRANCH:", BRANCH, "SHA:", sha);

    const res = await fetch(url, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        message: `Delete ${filePath}`,
        sha,
        branch: BRANCH
      })
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Delete failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function deleteFileFlow(f) {
    if (!activeFolder) return;

    const filePath = `${ROOT_DIR}/${activeFolder}/${f.name}`;

    const ok = confirm(`Xo√° file kh·ªèi GitHub?\n\n${filePath}\n\n‚ö†Ô∏è Kh√¥ng undo ƒë∆∞·ª£c (tr·ª´ khi b·∫°n git revert).`);
    if (!ok) return;

    setStatus(`Deleting...\n${filePath}`);
    await deleteFileOnGitHub(filePath);

    setStatus(`‚úÖ Deleted\n${filePath}`);
    await openFolder(activeFolder);
  }

  async function loadFolders() {
    setStatus("Loading folders...");
    elTitle.textContent = "Ch·ªçn folder";
    elSubtitle.textContent = `${OWNER}/${REPO}/${ROOT_DIR}`;
    elItemCount.textContent = "";
    elGrid.innerHTML = "";

    const data = await fetchJson(ghApiContents(ROOT_DIR));
    allFolders = data
      .filter(x => x.type === "dir")
      .map(x => ({ name: x.name, path: x.path }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    renderFolders(allFolders);
    setStatus("");
  }

  async function openFolder(folderName) {
    activeFolder = folderName;
    renderFolders(allFolders);

    elTitle.textContent = `üìÅ ${folderName}`;
    elSubtitle.textContent = `${ROOT_DIR}/${folderName}`;
    setStatus("Loading files...");
    elGrid.innerHTML = "";

    const path = `${ROOT_DIR}/${folderName}`;
    const data = await fetchJson(ghApiContents(path));

    activeFiles = data
      .filter(x => x.type === "file")
      .map(x => ({ name: x.name, size: x.size || 0, sha: x.sha }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    setStatus("");
    renderGrid(activeFiles);
  }

  /** remember token (localStorage) */
  const LS_KEY = `wallpaper_browser_token_${OWNER}_${REPO}`;
  (function initRememberToken(){
    const saved = localStorage.getItem(LS_KEY);
    if (saved) {
      elToken.value = saved;
      elRemember.checked = true;
    }
    elRemember.addEventListener("change", () => {
      if (elRemember.checked) {
        if (elToken.value.trim()) localStorage.setItem(LS_KEY, elToken.value.trim());
      } else {
        localStorage.removeItem(LS_KEY);
      }
    });
    elToken.addEventListener("input", () => {
      if (elRemember.checked) localStorage.setItem(LS_KEY, elToken.value.trim());
    });
  })();

  document.getElementById("reload").onclick = () => loadFolders();
  elQ.addEventListener("input", () => {
    renderFolders(allFolders);
    if (activeFolder) renderGrid(activeFiles);
  });
  elShowPreview.addEventListener("change", () => {
    if (activeFolder) renderGrid(activeFiles);
  });

  loadFolders().catch(err => setStatus(String(err?.message || err)));
</script>
</body>
</html>
