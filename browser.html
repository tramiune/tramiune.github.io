<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wallpaper Browser (GitHub API only)</title>
  <style>
    :root { --bd:#e7e7e7; --mut:#666; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    header { padding:12px 14px; border-bottom:1px solid var(--bd); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header b { font-size:14px; }
    header .mut { color:var(--mut); font-size:12px; }
    header input[type="text"], header input[type="password"] {
      padding:8px 10px; border:1px solid var(--bd); border-radius:10px; min-width:220px;
    }
    header button {
      padding:8px 10px; border:1px solid var(--bd); background:#fff; border-radius:10px; cursor:pointer;
    }
    header button:hover { background:#f5f5f5; }
    label.mut { display:inline-flex; gap:6px; align-items:center; }
    input[type="checkbox"] { transform: translateY(1px); }

    .wrap { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 64px); }
    aside { border-right:1px solid var(--bd); padding:10px; overflow:auto; }
    main { padding:12px; overflow:auto; }

    .folder {
      padding:9px 10px; border:1px solid var(--bd); border-radius:12px; cursor:pointer;
      display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;
    }
    .folder:hover { background:#f7f7f7; }
    .folder.active { border-color:#bbb; background:#f5f5f5; }

    .small { font-size:12px; color:var(--mut); }
    .status { font-size:12px; color:var(--mut); white-space:pre-wrap; margin: 6px 0 10px; }

    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(190px, 1fr)); gap:10px; }
    .card { border:1px solid var(--bd); border-radius:14px; overflow:hidden; background:#fff; }
    .thumb { width:100%; aspect-ratio: 9/16; background:#f2f2f2; display:flex; align-items:center; justify-content:center; }
    img, video { width:100%; height:100%; object-fit:cover; display:block; }
    .meta { padding:8px 10px; border-top:1px solid var(--bd); }
    .meta .name { font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .pill { font-size:11px; color:#333; background:#f3f3f3; border:1px solid #e2e2e2; padding:2px 8px; border-radius:999px; display:inline-block; margin-top:6px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .danger { border-color:#f0c1c1 !important; }

    a.btn{
      border:1px solid var(--bd); background:#fff; padding:8px 10px; border-radius:10px;
      cursor:pointer; text-decoration:none; color:inherit; display:inline-flex; gap:6px; align-items:center;
    }
    a.btn:hover{ background:#f5f5f5; }
  </style>
</head>
<body>
<header>
  <b>Wallpaper Browser</b>
  <span class="mut">API-only: list folder/file + load media via GitHub API blob URL</span>

  <input id="q" type="text" placeholder="Filter folder/file..." />

  <input id="token" type="password" placeholder="GitHub Token (Contents: write)" style="min-width:260px" />
  <label class="mut" title="L∆∞u token tr√™n m√°y b·∫°n (localStorage)">
    <input id="remember" type="checkbox" />
    remember token
  </label>

  <label class="mut" title="Hi·ªán file _preview.webp nh∆∞ item ri√™ng">
    <input id="showPreview" type="checkbox" />
    show _preview
  </label>

  <button id="reload">Reload</button>

  <a class="btn" href="./orders.html" target="_blank" rel="noreferrer">üß© Orders</a>
  <button id="genAll">üßæ Generate JSON (ALL)</button>

  <span class="mut" id="rate"></span>
</header>

<div class="wrap">
  <aside>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <b style="font-size:13px;">Folders</b>
      <span class="small" id="folderCount"></span>
    </div>
    <div id="folders"></div>
  </aside>

  <main>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <div>
        <b id="title" style="font-size:13px;">Ch·ªçn folder</b><br/>
        <span class="small" id="subtitle"></span>
      </div>
      <div class="small" id="itemCount"></div>
    </div>

    <div class="status" id="status"></div>
    <div class="grid" id="grid"></div>
  </main>
</div>

<script>
  /** =========================
   *  CONFIG ‚Äì s·ª≠a ·ªü ƒë√¢y
   *  ========================= */
  const OWNER = "tramiune";
  const REPO  = "tramiune001_res_wallpaper";
  const BRANCH = "main";           // ƒë·ªïi n·∫øu repo b·∫°n l√† master
  const ROOT_DIR = "resources";

  // output JSON
  const OUT_JSON_PATH = "dev/wallpaper.json";
  const ORDERS_PATH   = "dev/orders.json";

  // CDN url trong JSON output (theo format b·∫°n ƒëang d√πng)
  const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

  const IMAGE_EXT = ["webp","png","jpg","jpeg","gif"];
  const VIDEO_EXT = ["mp4","webm","mov"];
  /** ========================= */

  const elFolders = document.getElementById("folders");
  const elGrid = document.getElementById("grid");
  const elStatus = document.getElementById("status");
  const elTitle = document.getElementById("title");
  const elSubtitle = document.getElementById("subtitle");
  const elFolderCount = document.getElementById("folderCount");
  const elItemCount = document.getElementById("itemCount");
  const elQ = document.getElementById("q");
  const elRate = document.getElementById("rate");
  const elToken = document.getElementById("token");
  const elRemember = document.getElementById("remember");
  const elShowPreview = document.getElementById("showPreview");

  let allFolders = [];
  let activeFolder = null;
  let activeFiles = [];

  /** cache blob url theo "folder/file" */
  const blobUrlCache = new Map(); // key -> { url, ts }
  const MAX_CACHE = 120;

  function setStatus(s) { elStatus.textContent = s || ""; }
  function extOf(name) {
    const i = name.lastIndexOf(".");
    return i >= 0 ? name.slice(i+1).toLowerCase() : "";
  }
  function isMediaFile(name) {
    const e = extOf(name);
    return IMAGE_EXT.includes(e) || VIDEO_EXT.includes(e);
  }
  function isPreviewName(name) { return name.includes("_preview."); }

  function encodePath(path) { return path.split("/").map(encodeURIComponent).join("/"); }
  function ghContentsUrl(path) {
    const p = encodePath(path);
    return `https://api.github.com/repos/${OWNER}/${REPO}/contents/${p}?ref=${encodeURIComponent(BRANCH)}`;
  }

  function getAuthToken() {
    const t = elToken.value.trim();
    if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (c·∫ßn Contents: write).");
    return t;
  }

  async function fetchJson(url, withAuth = false) {
    const headers = { "Accept": "application/vnd.github+json" };
    if (withAuth) headers["Authorization"] = `Bearer ${getAuthToken()}`;

    const res = await fetch(url, { headers });
    const limit = res.headers.get("x-ratelimit-limit");
    const remain = res.headers.get("x-ratelimit-remaining");
    if (limit && remain) elRate.textContent = `GitHub API rate: ${remain}/${limit}`;

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`HTTP ${res.status}\n${txt}`);
    }
    return res.json();
  }

  /** remember token (localStorage) */
  const LS_KEY = `wallpaper_browser_token_${OWNER}_${REPO}`;
  (function initRememberToken(){
    const saved = localStorage.getItem(LS_KEY);
    if (saved) {
      elToken.value = saved;
      elRemember.checked = true;
    }
    elRemember.addEventListener("change", () => {
      if (elRemember.checked) {
        if (elToken.value.trim()) localStorage.setItem(LS_KEY, elToken.value.trim());
      } else {
        localStorage.removeItem(LS_KEY);
      }
    });
    elToken.addEventListener("input", () => {
      if (elRemember.checked) localStorage.setItem(LS_KEY, elToken.value.trim());
    });
  })();

  /** ---------- MEDIA LOAD via API -> blob URL ---------- */
  async function getBlobUrlForFile(folderName, fileName) {
    const key = `${folderName}/${fileName}`;
    const cached = blobUrlCache.get(key);
    if (cached?.url) return cached.url;

    const token = getAuthToken(); // API-only => b·∫Øt bu·ªôc token
    const filePath = `${ROOT_DIR}/${folderName}/${fileName}`;

    // l·∫•y download_url qua contents API
    const meta = await fetchJson(ghContentsUrl(filePath), true);
    const dl = meta?.download_url;
    if (!dl) throw new Error(`No download_url for ${filePath}`);

    // t·∫£i blob
    const res = await fetch(dl, { headers: { "Authorization": `Bearer ${token}` } }).catch(() => fetch(dl));
    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Download failed: HTTP ${res.status}\n${txt}`);
    }
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    blobUrlCache.set(key, { url, ts: Date.now() });
    // gi·ªõi h·∫°n cache
    if (blobUrlCache.size > MAX_CACHE) {
      const oldestKey = [...blobUrlCache.entries()].sort((a,b)=>a[1].ts-b[1].ts)[0]?.[0];
      if (oldestKey) {
        const old = blobUrlCache.get(oldestKey);
        try { URL.revokeObjectURL(old.url); } catch {}
        blobUrlCache.delete(oldestKey);
      }
    }
    return url;
  }

  function renderFolders(list) {
    elFolders.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const shown = list.filter(f => f.name.toLowerCase().includes(q));
    elFolderCount.textContent = `${shown.length}/${list.length}`;

    for (const f of shown) {
      const div = document.createElement("div");
      div.className = "folder" + (activeFolder === f.name ? " active" : "");
      div.innerHTML = `<span>üìÅ ${f.name}</span><span class="small">open</span>`;
      div.onclick = () => openFolder(f.name);
      elFolders.appendChild(div);
    }
  }

  /** ---------- DELETE ---------- */
  async function deleteFileOnGitHub(filePath, sha) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`;

    const res = await fetch(url, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ message: `Delete ${filePath}`, sha, branch: BRANCH })
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Delete failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function deleteFileFlow(f) {
    if (!activeFolder) return;
    const filePath = `${ROOT_DIR}/${activeFolder}/${f.name}`;

    const ok = confirm(`Xo√° file kh·ªèi GitHub?\n\n${filePath}\n\n‚ö†Ô∏è Kh√¥ng undo ƒë∆∞·ª£c (tr·ª´ khi b·∫°n git revert).`);
    if (!ok) return;

    setStatus(`Deleting...\n${filePath}`);
    await deleteFileOnGitHub(filePath, f.sha);

    setStatus(`‚úÖ Deleted\n${filePath}`);
    await openFolder(activeFolder);
  }

  /** ---------- GRID ---------- */
  async function renderGrid(files) {
    elGrid.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const showPreview = elShowPreview.checked;

    // preview map
    const previewByBase = new Map();
    for (const f of files) {
      if (!isMediaFile(f.name)) continue;
      if (!isPreviewName(f.name)) continue;
      const base = f.name.replace("_preview.", ".");
      previewByBase.set(base, f.name);
    }

    // mp4 map
    const mp4ByBase = new Map();
    for (const f of files) {
      const e = extOf(f.name);
      if (VIDEO_EXT.includes(e)) {
        const base = f.name.slice(0, f.name.lastIndexOf("."));
        mp4ByBase.set(base, f.name);
      }
    }

    let shown = files
      .filter(f => isMediaFile(f.name))
      .filter(f => f.name.toLowerCase().includes(q));

    if (!showPreview) shown = shown.filter(f => !isPreviewName(f.name));

    elItemCount.textContent = `Items: ${shown.length}`;

    for (const f of shown) {
      const e = extOf(f.name);
      const isVideo = VIDEO_EXT.includes(e);
      const isImage = IMAGE_EXT.includes(e);

      const card = document.createElement("div");
      card.className = "card";

      const thumb = document.createElement("div");
      thumb.className = "thumb";
      thumb.textContent = "Loading...";

      const meta = document.createElement("div");
      meta.className = "meta";

      const maybePreview = previewByBase.get(f.name);
      const labelPreviewHint =
        (!isVideo && !isPreviewName(f.name) && maybePreview) ? " ¬∑ has preview" : "";

      meta.innerHTML = `
        <div class="name" title="${f.name}">${f.name}</div>
        <div class="pill">${isVideo ? "video" : "image"} ¬∑ ${e}${isPreviewName(f.name) ? " ¬∑ preview" : ""}${labelPreviewHint}</div>
      `;

      const actions = document.createElement("div");
      actions.style.display = "flex";
      actions.style.gap = "8px";
      actions.style.flexWrap = "wrap";
      actions.style.marginTop = "8px";

      // open file (blob)
      const openBtn = document.createElement("a");
      openBtn.className = "btn";
      openBtn.textContent = "üîó Open";
      openBtn.href = "#";
      openBtn.onclick = async (ev) => {
        ev.preventDefault();
        try {
          const url = await getBlobUrlForFile(activeFolder, f.name);
          window.open(url, "_blank", "noopener,noreferrer");
        } catch (err) {
          alert(String(err?.message || err));
        }
      };
      actions.appendChild(openBtn);

      // delete
      const delBtn = document.createElement("button");
      delBtn.textContent = "üóë Delete";
      delBtn.className = "danger";
      delBtn.onclick = async () => {
        try { await deleteFileFlow(f); }
        catch (err) { alert(String(err?.message || err)); }
      };
      actions.appendChild(delBtn);

      // edit video
      if (isVideo) {
        const editBtn = document.createElement("a");
        editBtn.textContent = "‚úÇÔ∏è Edit";
        editBtn.className = "btn";
        editBtn.href = `./video_editor.html?mode=edit&folder=${encodeURIComponent(activeFolder)}&video=${encodeURIComponent(f.name)}`;
        editBtn.target = "_blank";
        actions.appendChild(editBtn);
      }

      // update image from mp4 (GI·ªÆ NGUY√äN)
      const isNormalWebp = isImage && e === "webp" && !isPreviewName(f.name);
      if (isNormalWebp) {
        const base = f.name.slice(0, f.name.lastIndexOf("."));
        const mp4 = mp4ByBase.get(base);
        if (mp4) {
          const updBtn = document.createElement("a");
          updBtn.textContent = "üîÑ Update";
          updBtn.className = "btn";
          updBtn.href =
            `./video_editor.html?mode=replaceImage` +
            `&folder=${encodeURIComponent(activeFolder)}` +
            `&video=${encodeURIComponent(mp4)}` +
            `&target=${encodeURIComponent(f.name)}`;
          updBtn.target = "_blank";
          actions.appendChild(updBtn);
        }
      }

      meta.appendChild(actions);
      card.appendChild(thumb);
      card.appendChild(meta);
      elGrid.appendChild(card);

      // load media blob url and render
      (async () => {
        try {
          const url = await getBlobUrlForFile(activeFolder, f.name);
          thumb.textContent = "";
          if (isVideo) {
            const vv = document.createElement("video");
            vv.src = url;
            vv.controls = true;
            vv.muted = true;
            vv.playsInline = true;
            vv.preload = "metadata";
            thumb.appendChild(vv);
          } else {
            const img = document.createElement("img");
            img.loading = "lazy";
            img.src = url;
            img.alt = f.name;
            thumb.appendChild(img);
          }
        } catch (err) {
          thumb.textContent = "Load failed";
          console.error(err);
        }
      })();
    }
  }

  /** ---------- LOADERS ---------- */
  async function loadFolders() {
    setStatus("Loading folders... (API-only requires token)");
    elTitle.textContent = "Ch·ªçn folder";
    elSubtitle.textContent = `${OWNER}/${REPO}/${ROOT_DIR}`;
    elItemCount.textContent = "";
    elGrid.innerHTML = "";

    // API-only => d√πng auth
    const data = await fetchJson(ghContentsUrl(ROOT_DIR), true);

    allFolders = data
      .filter(x => x.type === "dir")
      .map(x => ({ name: x.name, path: x.path }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    renderFolders(allFolders);
    setStatus("");
  }

  async function openFolder(folderName) {
    activeFolder = folderName;
    renderFolders(allFolders);

    elTitle.textContent = `üìÅ ${folderName}`;
    elSubtitle.textContent = `${ROOT_DIR}/${folderName}`;
    setStatus("Loading files...");
    elGrid.innerHTML = "";

    const path = `${ROOT_DIR}/${folderName}`;
    const data = await fetchJson(ghContentsUrl(path), true);

    activeFiles = data
      .filter(x => x.type === "file")
      .map(x => ({ name: x.name, size: x.size || 0, sha: x.sha }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    setStatus("");
    await renderGrid(activeFiles);
  }

  document.getElementById("reload").onclick = () => loadFolders();
  elQ.addEventListener("input", () => {
    renderFolders(allFolders);
    if (activeFolder) renderGrid(activeFiles);
  });
  elShowPreview.addEventListener("change", () => {
    if (activeFolder) renderGrid(activeFiles);
  });

  /** =========================
   *  GENERATE JSON (ALL)
   *  ========================= */

  function mainPrefixOfFolder(folderName) {
    return folderName.replace(/^\d+_/, "");
  }
  function parseBaseKey(fileName) {
    const dot = fileName.lastIndexOf(".");
    let base = dot >= 0 ? fileName.slice(0, dot) : fileName;
    base = base.replace(/_preview$/i, "");
    return base;
  }
  function mediaUrl(folderName, fileName) {
    return `${CDN_BASE}${folderName}/${fileName}`;
  }

  async function getFileShaIfExists(path) {
    try {
      const meta = await fetchJson(ghContentsUrl(path), true);
      return meta?.sha || null;
    } catch (e) {
      const msg = String(e?.message || e);
      if (msg.includes("404")) return null;
      return null;
    }
  }

  async function upsertTextFile(path, text, commitMsg) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(path)}`;
    const sha = await getFileShaIfExists(path);

    const body = {
      message: commitMsg || `Update ${path}`,
      content: btoa(unescape(encodeURIComponent(text))),
      branch: BRANCH
    };
    if (sha) body.sha = sha;

    const res = await fetch(url, {
      method: "PUT",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`PUT failed: HTTP ${res.status}\n${txt}`);
    }
    return res.json();
  }

  async function loadOrdersDoc() {
    try {
      const meta = await fetchJson(ghContentsUrl(ORDERS_PATH), true);
      if (!meta?.content) return { version:1, updatedAt:0, folders:{} };
      const text = decodeURIComponent(escape(atob(meta.content.replace(/\n/g,""))));
      const obj = JSON.parse(text);
      return {
        version: 1,
        updatedAt: obj.updatedAt || 0,
        folders: obj.folders || {}
      };
    } catch {
      return { version:1, updatedAt:0, folders:{} };
    }
  }

  function ensureFolderCfg(ordersDoc, folderName) {
    const now = Math.floor(Date.now()/1000);
    ordersDoc.folders[folderName] ??= { baseCreatedAt: now, order: [], liveUsePreview: {} };
    ordersDoc.folders[folderName].baseCreatedAt ??= now;
    ordersDoc.folders[folderName].order ??= [];
    ordersDoc.folders[folderName].liveUsePreview ??= {};
    return ordersDoc.folders[folderName];
  }

  function groupItemsFromFiles(folderName, files, folderCfg) {
    const previewForWebp = new Map(); // base.webp -> base_preview.webp
    for (const f of files) {
      if (isPreviewName(f.name) && extOf(f.name) === "webp") {
        const base = f.name.replace("_preview.webp", ".webp");
        previewForWebp.set(base, f.name);
      }
    }

    const groups = new Map();
    const mainPrefix = mainPrefixOfFolder(folderName);

    function ensureGroup(groupKey, init) {
      if (!groups.has(groupKey)) groups.set(groupKey, Object.assign({ groupKey }, init || {}));
      return groups.get(groupKey);
    }

    for (const f of files) {
      if (!isMediaFile(f.name)) continue;
      const e = extOf(f.name);
      const base = parseBaseKey(f.name);

      // DOUBLE
      const mDouble = base.match(/^(double_\d{3})_(0|1)$/i);
      if (mDouble && e === "webp") {
        const key = mDouble[1];
        const g = ensureGroup(key, { type: 2, medias: [] });
        g.medias.push({ name: f.name });
        continue;
      }

      // DAYS
      const mDays = base.match(/^(days_\d{3})_(\d{1,2})h$/i);
      if (mDays && e === "webp") {
        const key = mDays[1];
        const hourNum = parseInt(mDays[2], 10);
        const hour = String(hourNum).padStart(2, "0") + ":00";
        const g = ensureGroup(key, { type: 3, medias: [] });
        g.medias.push({ name: f.name, hour });
        continue;
      }

      // COUPLE
      const mCouple = base.match(/^(couple_\d{3})$/i);
      if (mCouple && e === "webp") {
        const key = mCouple[1];
        const g = ensureGroup(key, { type: 4, medias: [] });
        g.medias.push({ name: f.name });
        continue;
      }

      // LIVE/STILL
      if (e === "mp4" || e === "webp") {
        const g = ensureGroup(base, { type: 1, names: new Set() });
        g.names.add(f.name);
        continue;
      }
    }

    const out = [];

    for (const g of groups.values()) {
      if (g.type === 2) {
        g.medias.sort((a,b)=>a.name.localeCompare(b.name,"en"));
        // id: folder_<num>
        const mm = g.groupKey.match(/^double_(\d{3})$/i);
        const num = mm ? mm[1] : g.groupKey;
        g.id = `${folderName}_${num}`;
        out.push(g);
        continue;
      }

      if (g.type === 3) {
        // sort by hour
        g.medias.sort((a,b)=>String(a.hour).localeCompare(String(b.hour),"en"));
        const mm = g.groupKey.match(/^days_(\d{3})$/i);
        const num = mm ? mm[1] : g.groupKey;
        g.id = `${folderName}_${num}`;
        out.push(g);
        continue;
      }

      if (g.type === 4) {
        const mm = g.groupKey.match(/^couple_(\d{3})$/i);
        const num = mm ? mm[1] : g.groupKey;
        g.id = `${folderName}_${num}`;
        out.push(g);
        continue;
      }

      // LIVE/STILL decide by existence
      const base = g.groupKey;
      const mp4 = `${base}.mp4`;
      const webp = `${base}.webp`;
      const hasMp4 = g.names.has(mp4);
      const hasWebp = g.names.has(webp);
      if (!hasWebp) continue;

      const isLive = hasMp4;
      g.type = isLive ? 0 : 1;

      // id rule anti-dup:
      let id = "";
      const mm = base.match(/^(.+?)_(\d{3})$/);
      if (mm) {
        const prefix = mm[1];
        const num = mm[2];
        if (prefix === mainPrefix) id = `${folderName}_${num}`;
        else id = `${folderName}_${prefix}_${num}`;
      } else {
        id = `${folderName}_${base}`;
      }
      g.id = id;

      const previewName = previewForWebp.get(webp) || "";
      g.preview = previewName;
      g.baseKey = base;

      // keep a normalized media list
      g.medias = [];
      if (isLive) g.medias.push({ name: mp4 });
      g.medias.push({ name: webp });

      // live usePreview choice
      if (isLive) {
        // default: if has preview => true
        const v = folderCfg.liveUsePreview?.[base];
        g.usePreview = (v == null) ? !!previewName : !!v;
      }

      out.push(g);
    }

    // Apply order from folderCfg.order (list of groupKey)
    const byKey = new Map(out.map(x => [x.groupKey, x]));
    const ordered = [];
    const orderArr = Array.isArray(folderCfg.order) ? folderCfg.order : [];
    for (const k of orderArr) {
      if (byKey.has(k)) {
        ordered.push(byKey.get(k));
        byKey.delete(k);
      }
    }
    for (const x of out) if (byKey.has(x.groupKey)) ordered.push(x);

    // refresh order list
    folderCfg.order = ordered.map(x => x.groupKey);

    return ordered;
  }

  function buildJsonItemsForFolder(folderName, groups, folderCfg) {
    const baseCreatedAt = Number(folderCfg.baseCreatedAt || Math.floor(Date.now()/1000));
    const items = [];

    for (let i=0;i<groups.length;i++) {
      const g = groups[i];
      const createdAt = baseCreatedAt + i;
      const categoryId = folderName;

      // medias
      const medias = [];
      if (g.type === 0) {
        // LIVE: mp4 + webp, thumbUrl = preview n·∫øu tick + c√≥ preview
        const mp4Name = g.medias.find(x=>x.name.endsWith(".mp4"))?.name;
        const webpName = g.medias.find(x=>x.name.endsWith(".webp"))?.name;

        if (mp4Name) medias.push({
          url: mediaUrl(folderName, mp4Name),
          name: mp4Name,
          thumbUrl: "",
          contentType: "video/mp4"
        });
        if (webpName) medias.push({
          url: mediaUrl(folderName, webpName),
          name: webpName,
          thumbUrl: (g.usePreview && g.preview) ? mediaUrl(folderName, g.preview) : "",
          contentType: "image/webp"
        });
      } else if (g.type === 1) {
        // STILL: 1 webp
        const webpName = g.medias.find(x=>x.name.endsWith(".webp"))?.name || `${g.groupKey}.webp`;
        medias.push({
          url: mediaUrl(folderName, webpName),
          name: webpName,
          thumbUrl: "",
          contentType: "image/webp"
        });
      } else if (g.type === 4) {
        // COUPLE: 1 webp (optional preview if exists)
        const webp = g.medias[0]?.name;
        const preview = webp ? webp.replace(".webp","_preview.webp") : "";
        medias.push({
          url: mediaUrl(folderName, webp),
          name: webp,
          thumbUrl: (preview && g.preview !== false && isPreviewName(preview)) ? mediaUrl(folderName, preview) : "",
          contentType: "image/webp"
        });
      } else if (g.type === 2) {
        // DOUBLE: 2 webp
        for (const m of g.medias) {
          medias.push({
            url: mediaUrl(folderName, m.name),
            name: m.name,
            thumbUrl: "",
            contentType: "image/webp"
          });
        }
      } else if (g.type === 3) {
        // DAYS: multiple webp + hour
        for (const m of g.medias) {
          medias.push({
            url: mediaUrl(folderName, m.name),
            name: m.name,
            thumbUrl: "",
            hour: m.hour,
            contentType: "image/webp"
          });
        }
      }

      items.push({
        id: g.id,
        medias,
        categoryId,
        isPremium: true,
        createdAt,
        subType: 0,
        type: g.type,
        coinToUnlock: 0
      });
    }
    return items;
  }

  document.getElementById("genAll").onclick = async () => {
    try {
      const ok = confirm(`Generate JSON ALL folders d·∫°ng "###_*" v√† upload v√†o:\n\n${OUT_JSON_PATH}\n\nOK?`);
      if (!ok) return;

      setStatus("Loading orders.json...");
      const ordersDoc = await loadOrdersDoc();

      setStatus("Listing folders...");
      const data = await fetchJson(ghContentsUrl(ROOT_DIR), true);
      const folders = data
        .filter(x => x.type === "dir")
        .map(x => x.name)
        .filter(name => /^\d+_/.test(name))      // ch·ªâ folder d·∫°ng 101_...
        .sort((a,b)=>a.localeCompare(b,"en"));

      const allItems = [];
      const usedIds = new Set();

      for (const folderName of folders) {
        setStatus(`Reading folder: ${folderName} ...`);
        const folderCfg = ensureFolderCfg(ordersDoc, folderName);

        const list = await fetchJson(ghContentsUrl(`${ROOT_DIR}/${folderName}`), true);
        const files = list
          .filter(x => x.type === "file")
          .map(x => ({ name: x.name }))
          .sort((a,b)=>a.name.localeCompare(b.name,"en"));

        const groups = groupItemsFromFiles(folderName, files, folderCfg);
        const items = buildJsonItemsForFolder(folderName, groups, folderCfg);

        // ensure unique IDs globally
        for (const it of items) {
          let id = it.id;
          if (!usedIds.has(id)) {
            usedIds.add(id);
          } else {
            // add suffix _dupN
            let n = 2;
            while (usedIds.has(`${id}_dup${n}`)) n++;
            it.id = `${id}_dup${n}`;
            usedIds.add(it.id);
          }
          allItems.push(it);
        }
      }

      // update orders.json too (because order arrays might be auto-filled)
      ordersDoc.updatedAt = Math.floor(Date.now()/1000);

      setStatus(`Uploading ${OUT_JSON_PATH} ...`);
      await upsertTextFile(
        OUT_JSON_PATH,
        JSON.stringify(allItems, null, 2),
        `Generate wallpaper.json (${new Date().toISOString()})`
      );

      // optional: also save refreshed orders.json (so new groups appended)
      setStatus(`Uploading ${ORDERS_PATH} (refresh) ...`);
      await upsertTextFile(
        ORDERS_PATH,
        JSON.stringify(ordersDoc, null, 2),
        `Refresh orders.json (${new Date().toISOString()})`
      );

      setStatus(`‚úÖ Done!\nGenerated ${allItems.length} items\nSaved:\n- ${OUT_JSON_PATH}\n- ${ORDERS_PATH}`);
      alert("‚úÖ Generate JSON ALL done!");
    } catch (e) {
      setStatus(`‚ùå Generate failed\n${String(e?.message || e)}`);
      alert(String(e?.message || e));
    }
  };

  loadFolders().catch(err => setStatus(String(err?.message || err)));
</script>
</body>
</html>
