<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wallpaper Browser</title>
  <style>
    :root { --bd:#e7e7e7; --mut:#666; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    header { padding:12px 14px; border-bottom:1px solid var(--bd); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header b { font-size:14px; }
    header .mut { color:var(--mut); font-size:12px; }
    header input[type="text"], header input[type="password"] {
      padding:8px 10px; border:1px solid var(--bd); border-radius:10px; min-width:220px;
    }
    header button {
      padding:8px 10px; border:1px solid var(--bd); background:#fff; border-radius:10px; cursor:pointer;
    }
    header button:hover { background:#f5f5f5; }
    label.mut { display:inline-flex; gap:6px; align-items:center; }
    input[type="checkbox"] { transform: translateY(1px); }

    .wrap { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 64px); }
    aside { border-right:1px solid var(--bd); padding:10px; overflow:auto; }
    main { padding:12px; overflow:auto; }

    .folder {
      padding:9px 10px; border:1px solid var(--bd); border-radius:12px; cursor:pointer;
      display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;
    }
    .folder:hover { background:#f7f7f7; }
    .folder.active { border-color:#bbb; background:#f5f5f5; }

    .small { font-size:12px; color:var(--mut); }
    .status { font-size:12px; color:var(--mut); white-space:pre-wrap; margin: 6px 0 10px; }

    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(190px, 1fr)); gap:10px; }
    .card { border:1px solid var(--bd); border-radius:14px; overflow:hidden; background:#fff; }
    .thumb { width:100%; aspect-ratio: 9/16; background:#f2f2f2; display:flex; align-items:center; justify-content:center; }
    img, video { width:100%; height:100%; object-fit:cover; display:block; }
    .meta { padding:8px 10px; border-top:1px solid var(--bd); }
    .meta .name { font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .pill { font-size:11px; color:#333; background:#f3f3f3; border:1px solid #e2e2e2; padding:2px 8px; border-radius:999px; display:inline-block; margin-top:6px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .danger { border-color:#f0c1c1 !important; }

    a.btn, button.btn{
      border:1px solid var(--bd); background:#fff; padding:8px 10px; border-radius:10px;
      cursor:pointer; text-decoration:none; color:inherit; display:inline-flex; gap:6px; align-items:center;
    }
    a.btn:hover, button.btn:hover{ background:#f5f5f5; }
    button.btn{ font: inherit; }
  </style>
</head>
<body>
<header>
  <b>Wallpaper Browser</b>
  <span class="mut">CDN media + GitHub Contents API (list/delete/write json)</span>

  <input id="q" type="text" placeholder="Filter folder/file..." />

  <input id="token" type="password" placeholder="GitHub Token (Contents: write)" style="min-width:260px" />
  <label class="mut" title="L∆∞u token tr√™n m√°y b·∫°n (localStorage)">
    <input id="remember" type="checkbox" />
    remember token
  </label>

  <label class="mut" title="Hi·ªán file _preview.webp nh∆∞ item ri√™ng">
    <input id="showPreview" type="checkbox" />
    show _preview
  </label>

  <button id="reload">Reload</button>

  <button id="genAll" class="btn" title="G·ªôp t·∫•t c·∫£ folder 101_,102_... -> dev/wallpaper.json">üß© Generate JSON (ALL)</button>

  <span class="mut" id="rate"></span>
</header>

<div class="wrap">
  <aside>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <b style="font-size:13px;">Folders</b>
      <span class="small" id="folderCount"></span>
    </div>
    <div id="folders"></div>
  </aside>

  <main>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <div>
        <b id="title" style="font-size:13px;">Ch·ªçn folder</b><br/>
        <span class="small" id="subtitle"></span>
      </div>
      <div class="small" id="itemCount"></div>
    </div>

    <div class="status" id="status"></div>
    <div class="grid" id="grid"></div>
  </main>
</div>

<script>
  /** =========================
   *  CONFIG ‚Äì s·ª≠a ·ªü ƒë√¢y
   *  ========================= */
  const OWNER = "tramiune";
  const REPO  = "tramiune001_res_wallpaper";
  const BRANCH = "main";
  const ROOT_DIR = "resources";

  // CDN cho media (ƒë·ªÉ nh∆∞ c≈©)
  const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

  // JSON output (g·ªôp ALL)
  const ALL_JSON_PATH = "dev/wallpaper.json"; // repo path

  const IMAGE_EXT = ["webp","png","jpg","jpeg","gif"];
  const VIDEO_EXT = ["mp4","webm","mov"];
  /** ========================= */

  // Types
  const TYPE = { LIVE:0, STILL:1, DOUBLE:2, DAYS:3, COUPLE:4 };

  const elFolders = document.getElementById("folders");
  const elGrid = document.getElementById("grid");
  const elStatus = document.getElementById("status");
  const elTitle = document.getElementById("title");
  const elSubtitle = document.getElementById("subtitle");
  const elFolderCount = document.getElementById("folderCount");
  const elItemCount = document.getElementById("itemCount");
  const elQ = document.getElementById("q");
  const elRate = document.getElementById("rate");
  const elToken = document.getElementById("token");
  const elRemember = document.getElementById("remember");
  const elShowPreview = document.getElementById("showPreview");

  let allFolders = [];
  let activeFolder = null;
  let activeFiles = [];

  function setStatus(s) { elStatus.textContent = s || ""; }

  function extOf(name) {
    const i = name.lastIndexOf(".");
    return i >= 0 ? name.slice(i+1).toLowerCase() : "";
  }
  function isMediaFile(name) {
    const e = extOf(name);
    return IMAGE_EXT.includes(e) || VIDEO_EXT.includes(e);
  }
  function isPreviewName(name) { return name.includes("_preview."); }
  function encodePath(path) { return path.split("/").map(encodeURIComponent).join("/"); }

  function ghContentsUrl(path) {
    const p = encodePath(path);
    return `https://api.github.com/repos/${OWNER}/${REPO}/contents/${p}?ref=${encodeURIComponent(BRANCH)}`;
  }

  function mediaUrl(folderName, fileName) {
    return `${CDN_BASE}${folderName}/${fileName}`;
  }

  function getAuthToken() {
    const t = elToken.value.trim();
    if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (c·∫ßn Contents: write).");
    return t;
  }

  async function fetchJson(url, withAuth = false) {
    const headers = { "Accept": "application/vnd.github+json" };
    if (withAuth) headers["Authorization"] = `Bearer ${getAuthToken()}`;

    const res = await fetch(url, { headers });
    const limit = res.headers.get("x-ratelimit-limit");
    const remain = res.headers.get("x-ratelimit-remaining");
    if (limit && remain) elRate.textContent = `GitHub API rate: ${remain}/${limit}`;

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`HTTP ${res.status}\n${txt}`);
    }
    return res.json();
  }

  /** remember token (localStorage) */
  const LS_KEY = `wallpaper_browser_token_${OWNER}_${REPO}`;
  (function initRememberToken(){
    const saved = localStorage.getItem(LS_KEY);
    if (saved) {
      elToken.value = saved;
      elRemember.checked = true;
    }
    elRemember.addEventListener("change", () => {
      if (elRemember.checked) {
        if (elToken.value.trim()) localStorage.setItem(LS_KEY, elToken.value.trim());
      } else {
        localStorage.removeItem(LS_KEY);
      }
    });
    elToken.addEventListener("input", () => {
      if (elRemember.checked) localStorage.setItem(LS_KEY, elToken.value.trim());
    });
  })();

  /** ---------- DELETE ---------- */
  async function deleteFileOnGitHub(filePath, sha) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`;

    const res = await fetch(url, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ message: `Delete ${filePath}`, sha, branch: BRANCH })
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Delete failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function deleteFileFlow(f) {
    if (!activeFolder) return;
    const filePath = `${ROOT_DIR}/${activeFolder}/${f.name}`;

    const ok = confirm(`Xo√° file kh·ªèi GitHub?\n\n${filePath}\n\n‚ö†Ô∏è Kh√¥ng undo ƒë∆∞·ª£c (tr·ª´ khi b·∫°n git revert).`);
    if (!ok) return;

    setStatus(`Deleting...\n${filePath}`);
    await deleteFileOnGitHub(filePath, f.sha);

    setStatus(`‚úÖ Deleted\n${filePath}`);
    await openFolder(activeFolder);
  }

  /** ---------- UPSERT FILE (PUT) ---------- */
  function b64EncodeUnicode(str) {
    const bytes = new TextEncoder().encode(str);
    let bin = "";
    for (const b of bytes) bin += String.fromCharCode(b);
    return btoa(bin);
  }

  async function getFileShaIfExists(path) {
    try {
      const meta = await fetchJson(ghContentsUrl(path), true);
      return meta?.sha || null;
    } catch (e) {
      const msg = String(e?.message || e);
      if (msg.includes("HTTP 404")) return null;
      return null;
    }
  }

  async function upsertTextFile(path, text, message) {
    const token = getAuthToken();
    const sha = await getFileShaIfExists(path);

    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(path)}`;
    const body = {
      message: message || `Update ${path}`,
      content: b64EncodeUnicode(text),
      branch: BRANCH
    };
    if (sha) body.sha = sha;

    const res = await fetch(url, {
      method: "PUT",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Write failed: HTTP ${res.status}\n${txt}`);
    }
    return res.json();
  }

  /** ---------- GRID (kept: Update/Edit/Delete) ---------- */
  async function renderGrid(files) {
    elGrid.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const showPreview = elShowPreview.checked;

    // preview map: base file -> preview file
    const previewByBase = new Map();
    for (const f of files) {
      if (!isMediaFile(f.name)) continue;
      if (!isPreviewName(f.name)) continue;
      const base = f.name.replace("_preview.", ".");
      previewByBase.set(base, f.name);
    }

    // mp4 map: base name -> mp4 file (for Update)
    const mp4ByBase = new Map();
    for (const f of files) {
      const e = extOf(f.name);
      if (VIDEO_EXT.includes(e)) {
        const base = f.name.slice(0, f.name.lastIndexOf(".")); // anime_003
        mp4ByBase.set(base, f.name);
      }
    }

    let shown = files
      .filter(f => isMediaFile(f.name))
      .filter(f => f.name.toLowerCase().includes(q));

    if (!showPreview) shown = shown.filter(f => !isPreviewName(f.name));

    elItemCount.textContent = `Items: ${shown.length}`;

    for (const f of shown) {
      const e = extOf(f.name);
      const isVideo = VIDEO_EXT.includes(e);
      const isImage = IMAGE_EXT.includes(e);

      const card = document.createElement("div");
      card.className = "card";

      const thumb = document.createElement("div");
      thumb.className = "thumb";

      // only show preview thumb for VIDEO items if exists
      const maybePreview = previewByBase.get(f.name);
      const displayUrl = (isVideo && maybePreview)
        ? mediaUrl(activeFolder, maybePreview)
        : mediaUrl(activeFolder, f.name);

      if (isVideo) {
        if (maybePreview) {
          const img = document.createElement("img");
          img.loading = "lazy";
          img.src = displayUrl;
          img.alt = f.name;
          thumb.appendChild(img);
        } else {
          const v = document.createElement("video");
          v.src = displayUrl;
          v.controls = true;
          v.muted = true;
          v.playsInline = true;
          v.preload = "metadata";
          thumb.appendChild(v);
        }
      } else {
        const img = document.createElement("img");
        img.loading = "lazy";
        img.src = displayUrl;
        img.alt = f.name;
        thumb.appendChild(img);
      }

      const meta = document.createElement("div");
      meta.className = "meta";

      const labelPreviewHint =
        (!isVideo && !isPreviewName(f.name) && maybePreview) ? " ¬∑ has preview" : "";

      meta.innerHTML = `
        <div class="name" title="${f.name}">${f.name}</div>
        <div class="pill">${isVideo ? "video" : "image"} ¬∑ ${e}${isPreviewName(f.name) ? " ¬∑ preview" : ""}${labelPreviewHint}</div>
        <div class="small" style="margin-top:6px;">
          <a href="${mediaUrl(activeFolder, f.name)}" target="_blank" rel="noreferrer">open file</a>
        </div>
      `;

      const actions = document.createElement("div");
      actions.style.display = "flex";
      actions.style.gap = "8px";
      actions.style.flexWrap = "wrap";
      actions.style.marginTop = "8px";

      const delBtn = document.createElement("button");
      delBtn.textContent = "üóë Delete";
      delBtn.className = "btn danger";
      delBtn.onclick = async () => {
        try { await deleteFileFlow(f); }
        catch (err) { alert(String(err?.message || err)); }
      };
      actions.appendChild(delBtn);

      if (isVideo) {
        const editBtn = document.createElement("a");
        editBtn.textContent = "‚úÇÔ∏è Edit";
        editBtn.className = "btn";
        editBtn.href = `./video_editor.html?mode=edit&folder=${encodeURIComponent(activeFolder)}&video=${encodeURIComponent(f.name)}`;
        editBtn.target = "_blank";
        actions.appendChild(editBtn);
      }

      const isNormalWebp = isImage && e === "webp" && !isPreviewName(f.name);
      if (isNormalWebp) {
        const base = f.name.slice(0, f.name.lastIndexOf(".")); // anime_001
        const mp4 = mp4ByBase.get(base);
        if (mp4) {
          const updBtn = document.createElement("a");
          updBtn.textContent = "üîÑ Update";
          updBtn.className = "btn";
          updBtn.href =
            `./video_editor.html?mode=replaceImage` +
            `&folder=${encodeURIComponent(activeFolder)}` +
            `&video=${encodeURIComponent(mp4)}` +
            `&target=${encodeURIComponent(f.name)}`;
          updBtn.target = "_blank";
          actions.appendChild(updBtn);
        }
      }

      meta.appendChild(actions);
      card.appendChild(thumb);
      card.appendChild(meta);
      elGrid.appendChild(card);
    }
  }

  /** ---------- LIST ---------- */
  function renderFolders(list) {
    elFolders.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const shown = list.filter(f => f.name.toLowerCase().includes(q));
    elFolderCount.textContent = `${shown.length}/${list.length}`;

    for (const f of shown) {
      const div = document.createElement("div");
      div.className = "folder" + (activeFolder === f.name ? " active" : "");
      div.innerHTML = `<span>üìÅ ${f.name}</span><span class="small">open</span>`;
      div.onclick = () => openFolder(f.name);
      elFolders.appendChild(div);
    }
  }

  async function loadFolders() {
    setStatus("Loading folders...");
    elTitle.textContent = "Ch·ªçn folder";
    elSubtitle.textContent = `${OWNER}/${REPO}/${ROOT_DIR}`;
    elItemCount.textContent = "";
    elGrid.innerHTML = "";

    const data = await fetchJson(ghContentsUrl(ROOT_DIR), false);

    allFolders = data
      .filter(x => x.type === "dir")
      .map(x => ({ name: x.name, path: x.path }))
      .sort((a,b) => a.name.localeCompare(b, "en"));

    renderFolders(allFolders);
    setStatus("");
  }

  async function openFolder(folderName) {
    activeFolder = folderName;
    renderFolders(allFolders);

    elTitle.textContent = `üìÅ ${folderName}`;
    elSubtitle.textContent = `${ROOT_DIR}/${folderName}`;
    setStatus("Loading files...");
    elGrid.innerHTML = "";

    const path = `${ROOT_DIR}/${folderName}`;
    const data = await fetchJson(ghContentsUrl(path), false);

    activeFiles = data
      .filter(x => x.type === "file")
      .map(x => ({ name: x.name, size: x.size || 0, sha: x.sha }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    setStatus("");
    await renderGrid(activeFiles);
  }

  /** =========================
   *  JSON GENERATOR (ALL) ‚Äì TRI·ªÜT ƒê·ªÇ, KH√îNG B·ªé S√ìT
   *  - Kh√¥ng dedupe (tr√πng gi·ªØa folder OK)
   *  - D·ª±a tr√™n file th·ª±c t·∫ø trong folder:
   *    couple_{nnn}.webp (+ preview n·∫øu c√≥)     => type=4
   *    double_{nnn}_0.webp / _1.webp           => type=2 (c√≥ c√°i n√†o add c√°i ƒë√≥)
   *    days_{nnn}_6h/12h/18h/24h.webp          => type=3 (c√≥ slot n√†o add slot ƒë√≥)
   *    {prefix}_{nnn}.mp4 + {prefix}_{nnn}.webp => type=0
   *    ch·ªâ {prefix}_{nnn}.webp                 => type=1
   *  ========================= */

  function pad3(n) {
    const s = String(n);
    return s.length >= 3 ? s : ("000" + s).slice(-3);
  }

  function hourFromDaysSuffix(suf) {
    if (suf === "6h") return "06:00";
    if (suf === "12h") return "12:00";
    if (suf === "18h") return "18:00";
    if (suf === "24h") return "24:00";
    return "";
  }

  function groupFiles(files) {
    const set = new Set(files.map(f => f.name));
    return set;
  }

 function generateItemsForFolderStrict(categoryId, files) {
  const createdAtSec = Math.floor(Date.now() / 1000);
  const names = new Set(files.map(f => f.name));

  const has = (n) => names.has(n);

  const coupleNums = new Set();
  const doubleNums = new Set();
  const daysNums   = new Set();

  // key: `${prefix}_${nnn}` -> { prefix,num, hasMp4,hasWebp,hasPreview }
  const normal = new Map();

  for (const name of names) {
    if (name.endsWith(".json")) continue;

    // couple
    let m = name.match(/^couple_(\d{1,})\.webp$/);
    if (m) { coupleNums.add(parseInt(m[1],10)); continue; }

    // double
    m = name.match(/^double_(\d{1,})_(0|1)\.webp$/);
    if (m) { doubleNums.add(parseInt(m[1],10)); continue; }

    // days
    m = name.match(/^days_(\d{1,})_(6h|12h|18h|24h)\.webp$/);
    if (m) { daysNums.add(parseInt(m[1],10)); continue; }

    // normal mp4/webp: anime_003.mp4 / anime_003.webp
m = name.match(/^([a-zA-Z][a-zA-Z0-9_]*)_(\d{1,})\.(mp4|webp)$/);
    if (m) {
      const prefix = m[1];
      const num = pad3(parseInt(m[2],10));
      const ext = m[3];
      const key = `${prefix}_${num}`; // baseName without extension
      const obj = normal.get(key) || { prefix, num, hasMp4:false, hasWebp:false, hasPreview:false };
      if (ext === "mp4") obj.hasMp4 = true;
      if (ext === "webp") obj.hasWebp = true;
      normal.set(key, obj);
      continue;
    }

    // normal preview: anime_003_preview.webp
m = name.match(/^([a-zA-Z][a-zA-Z0-9_]*)_(\d{1,})_preview\.webp$/);
    if (m) {
      const prefix = m[1];
      const num = pad3(parseInt(m[2],10));
      const key = `${prefix}_${num}`;
      const obj = normal.get(key) || { prefix, num, hasMp4:false, hasWebp:false, hasPreview:false };
      obj.hasPreview = true;
      normal.set(key, obj);
      continue;
    }
  }

  const items = [];

  // COUPLE
  [...coupleNums].sort((a,b)=>a-b).forEach(n => {
    const num = pad3(n);
    const webpName = `couple_${num}.webp`;
    const previewName = `couple_${num}_preview.webp`;
    items.push({
      id: `${categoryId}_couple_${num}`,                 // ‚úÖ unique
      medias: [{
        url: mediaUrl(categoryId, webpName),
        name: webpName,
        thumbUrl: has(previewName) ? mediaUrl(categoryId, previewName) : "",
        contentType: "image/webp"
      }],
      categoryId,
      isPremium: true,
      createdAt: createdAtSec,
      subType: 0,
      type: TYPE.COUPLE,
      coinToUnlock: 0
    });
  });

  // DOUBLE
  [...doubleNums].sort((a,b)=>a-b).forEach(n => {
    const num = pad3(n);
    const f0 = `double_${num}_0.webp`;
    const f1 = `double_${num}_1.webp`;
    const medias = [];
    if (has(f0)) medias.push({ url: mediaUrl(categoryId, f0), name: f0, thumbUrl: "", contentType: "image/webp" });
    if (has(f1)) medias.push({ url: mediaUrl(categoryId, f1), name: f1, thumbUrl: "", contentType: "image/webp" });

    if (medias.length) {
      items.push({
        id: `${categoryId}_double_${num}`,               // ‚úÖ unique
        medias,
        categoryId,
        isPremium: true,
        createdAt: createdAtSec,
        subType: 0,
        type: TYPE.DOUBLE,
        coinToUnlock: 0
      });
    }
  });

  // DAYS
  const dayOrder = ["6h","12h","18h","24h"];
  [...daysNums].sort((a,b)=>a-b).forEach(n => {
    const num = pad3(n);
    const medias = [];
    for (const suf of dayOrder) {
      const fname = `days_${num}_${suf}.webp`;
      if (has(fname)) {
        medias.push({
          url: mediaUrl(categoryId, fname),
          name: fname,
          thumbUrl: "",
          hour: hourFromDaysSuffix(suf),
          contentType: "image/webp"
        });
      }
    }
    if (medias.length) {
      items.push({
        id: `${categoryId}_days_${num}`,                 // ‚úÖ unique
        medias,
        categoryId,
        isPremium: true,
        createdAt: createdAtSec,
        subType: 0,
        type: TYPE.DAYS,
        coinToUnlock: 0
      });
    }
  });

  // NORMAL (LIVE / STILL)
  const normalsSorted = [...normal.entries()].sort((a,b)=>{
    // sort by baseName
    return a[0].localeCompare(b[0]);
  });

  for (const [baseName, it] of normalsSorted) {
    const prefix = it.prefix;
    const num = it.num;

    const mp4Name = `${prefix}_${num}.mp4`;
    const webpName = `${prefix}_${num}.webp`;
    const previewName = `${prefix}_${num}_preview.webp`;

    // ‚úÖ ID includes baseName (anime_003 / silly_031 ...)
    const id = `${categoryId}_${baseName}`;

    // LIVE
    if (it.hasMp4 && it.hasWebp) {
      items.push({
        id,
        medias: [
          { url: mediaUrl(categoryId, mp4Name), name: mp4Name, thumbUrl: "", contentType: "video/mp4" },
          {
            url: mediaUrl(categoryId, webpName),
            name: webpName,
            thumbUrl: (it.hasPreview && has(previewName)) ? mediaUrl(categoryId, previewName) : "",
            contentType: "image/webp"
          }
        ],
        categoryId,
        isPremium: true,
        createdAt: createdAtSec,
        subType: 0,
        type: TYPE.LIVE,
        coinToUnlock: 0
      });
      continue;
    }

    // STILL
    if (it.hasWebp) {
      items.push({
        id,
        medias: [
          {
            url: mediaUrl(categoryId, webpName),
            name: webpName,
            thumbUrl: (it.hasPreview && has(previewName)) ? mediaUrl(categoryId, previewName) : "",
            contentType: "image/webp"
          }
        ],
        categoryId,
        isPremium: true,
        createdAt: createdAtSec,
        subType: 0,
        type: TYPE.STILL,
        coinToUnlock: 0
      });
    }
  }

  return items;
}


  async function listFolderFiles(folderName) {
    const path = `${ROOT_DIR}/${folderName}`;
    const data = await fetchJson(ghContentsUrl(path), false);
    return data
      .filter(x => x.type === "file")
      .map(x => ({ name: x.name, size: x.size || 0, sha: x.sha }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));
  }

  async function generateAllJsonAndUpload() {
    try {
      // need token to write
      getAuthToken();

      setStatus("Generating ALL JSON...\nScanning folders 101_, 102_, ...");
      const root = await fetchJson(ghContentsUrl(ROOT_DIR), false);

      const folders = root
        .filter(x => x.type === "dir")
        .map(x => x.name)
        .filter(name => /^\d+_/.test(name))
        .sort((a,b) => a.localeCompare(b, "en"));

      let allItems = [];
      for (let i=0;i<folders.length;i++) {
        const folderName = folders[i];
        setStatus(`Generating ALL JSON...\n(${i+1}/${folders.length}) ${folderName}`);
        const files = await listFolderFiles(folderName);

        // TRI·ªÜT ƒê·ªÇ: d·ª±a theo file th·∫≠t
        const items = generateItemsForFolderStrict(folderName, files);

        // kh√¥ng dedupe
        allItems = allItems.concat(items);
      }

      // ƒë·∫£m b·∫£o unique id to√†n c·ª•c (fallback)
const seen = new Map();
for (const it of allItems) {
  if (!seen.has(it.id)) { seen.set(it.id, 1); continue; }
  const c = seen.get(it.id) + 1;
  seen.set(it.id, c);
  it.id = `${it.id}__${c}`; // suffix n·∫øu v·∫´n tr√πng
}


      const jsonText = JSON.stringify(allItems, null, 2);

      setStatus(`Uploading...\n${ALL_JSON_PATH}\nItems: ${allItems.length}`);
      await upsertTextFile(
        ALL_JSON_PATH,
        jsonText,
        `Generate ${ALL_JSON_PATH} (${allItems.length} items)`
      );

      setStatus(`‚úÖ Done!\nWrote: ${ALL_JSON_PATH}\nItems: ${allItems.length}\n\nAPI:\nhttps://${OWNER}.github.io/${REPO}/dev/wallpaper.json`);
      alert(`‚úÖ Generate ALL JSON OK!\nItems: ${allItems.length}\nWrote: ${ALL_JSON_PATH}`);
    } catch (err) {
      console.error(err);
      setStatus(`‚ùå Failed:\n${String(err?.message || err)}`);
      alert(String(err?.message || err));
    }
  }

  /** ---------- EVENTS ---------- */
  document.getElementById("reload").onclick = () => loadFolders();
  document.getElementById("genAll").onclick = () => generateAllJsonAndUpload();

  elQ.addEventListener("input", () => {
    renderFolders(allFolders);
    if (activeFolder) renderGrid(activeFiles);
  });
  elShowPreview.addEventListener("change", () => {
    if (activeFolder) renderGrid(activeFiles);
  });

  loadFolders().catch(err => setStatus(String(err?.message || err)));
</script>
</body>
</html>
