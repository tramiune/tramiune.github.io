<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wallpaper Browser (GitHub API only)</title>
  <style>
    :root { --bd:#e7e7e7; --mut:#666; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    header { padding:12px 14px; border-bottom:1px solid var(--bd); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header b { font-size:14px; }
    header .mut { color:var(--mut); font-size:12px; }
    header input[type="text"], header input[type="password"] {
      padding:8px 10px; border:1px solid var(--bd); border-radius:10px; min-width:220px;
    }
    header button {
      padding:8px 10px; border:1px solid var(--bd); background:#fff; border-radius:10px; cursor:pointer;
    }
    header button:hover { background:#f5f5f5; }
    label.mut { display:inline-flex; gap:6px; align-items:center; }
    input[type="checkbox"] { transform: translateY(1px); }

    .wrap { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 64px); }
    aside { border-right:1px solid var(--bd); padding:10px; overflow:auto; }
    main { padding:12px; overflow:auto; }

    .folder {
      padding:9px 10px; border:1px solid var(--bd); border-radius:12px; cursor:pointer;
      display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;
    }
    .folder:hover { background:#f7f7f7; }
    .folder.active { border-color:#bbb; background:#f5f5f5; }

    .small { font-size:12px; color:var(--mut); }
    .status { font-size:12px; color:var(--mut); white-space:pre-wrap; margin: 6px 0 10px; }

    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(190px, 1fr)); gap:10px; }
    .card { border:1px solid var(--bd); border-radius:14px; overflow:hidden; background:#fff; }
    .thumb { width:100%; aspect-ratio: 9/16; background:#f2f2f2; display:flex; align-items:center; justify-content:center; }
    img, video { width:100%; height:100%; object-fit:cover; display:block; }
    .meta { padding:8px 10px; border-top:1px solid var(--bd); }
    .meta .name { font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .pill { font-size:11px; color:#333; background:#f3f3f3; border:1px solid #e2e2e2; padding:2px 8px; border-radius:999px; display:inline-block; margin-top:6px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .danger { border-color:#f0c1c1 !important; }

    a.btn, button.btn{
      border:1px solid var(--bd); background:#fff; padding:8px 10px; border-radius:10px;
      cursor:pointer; text-decoration:none; color:inherit; display:inline-flex; gap:6px; align-items:center;
      font: inherit;
    }
    a.btn:hover, button.btn:hover{ background:#f5f5f5; }
  </style>
</head>
<body>
<header>
  <b>Wallpaper Browser</b>
  <span class="mut">API-only: list folder/file + load media via GitHub API blob URL</span>

  <input id="q" type="text" placeholder="Filter folder/file..." />

  <input id="token" type="password" placeholder="GitHub Token (Contents: write)" style="min-width:260px" />
  <label class="mut" title="L∆∞u token tr√™n m√°y b·∫°n (localStorage)">
    <input id="remember" type="checkbox" />
    remember token
  </label>

  <label class="mut" title="Hi·ªán file _preview.webp nh∆∞ item ri√™ng">
    <input id="showPreview" type="checkbox" />
    show _preview
  </label>

  <button id="reload">Reload</button>
  <button id="genJson" title="T·∫°o/C·∫≠p nh·∫≠t file {folder}.json trong folder ƒëang m·ªü">üßæ Generate JSON</button>
  <span class="mut" id="rate"></span>
</header>

<div class="wrap">
  <aside>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <b style="font-size:13px;">Folders</b>
      <span class="small" id="folderCount"></span>
    </div>
    <div id="folders"></div>
  </aside>

  <main>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <div>
        <b id="title" style="font-size:13px;">Ch·ªçn folder</b><br/>
        <span class="small" id="subtitle"></span>
      </div>
      <div class="small" id="itemCount"></div>
    </div>

    <div class="status" id="status"></div>
    <div class="grid" id="grid"></div>
  </main>
</div>

<script>
  /** =========================
   *  CONFIG ‚Äì s·ª≠a ·ªü ƒë√¢y
   *  ========================= */
  const OWNER = "tramiune";
  const REPO  = "tramiune001_res_wallpaper";
  const BRANCH = "main";
  const ROOT_DIR = "resources";

  // JSON rule: d√πng jsdelivr CDN
  const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

  const IMAGE_EXT = ["webp","png","jpg","jpeg","gif"];
  const VIDEO_EXT = ["mp4","webm","mov"];
  /** ========================= */

  const TYPE = { STILL:1, LIVE:0, DOUBLE:2, DAYS:3, COUPLE:4 };

  const elFolders = document.getElementById("folders");
  const elGrid = document.getElementById("grid");
  const elStatus = document.getElementById("status");
  const elTitle = document.getElementById("title");
  const elSubtitle = document.getElementById("subtitle");
  const elFolderCount = document.getElementById("folderCount");
  const elItemCount = document.getElementById("itemCount");
  const elQ = document.getElementById("q");
  const elRate = document.getElementById("rate");
  const elToken = document.getElementById("token");
  const elRemember = document.getElementById("remember");
  const elShowPreview = document.getElementById("showPreview");
  const elGenJson = document.getElementById("genJson");

  let allFolders = [];
  let activeFolder = null;
  let activeFiles = [];

  /** cache blob url theo "folder/file" */
  const blobUrlCache = new Map(); // key -> { url, ts }
  const MAX_CACHE = 120;

  function setStatus(s) { elStatus.textContent = s || ""; }
  function extOf(name) {
    const i = name.lastIndexOf(".");
    return i >= 0 ? name.slice(i+1).toLowerCase() : "";
  }
  function isMediaFile(name) {
    const e = extOf(name);
    return IMAGE_EXT.includes(e) || VIDEO_EXT.includes(e);
  }
  function isPreviewName(name) { return name.includes("_preview."); }

  function encodePath(path) { return path.split("/").map(encodeURIComponent).join("/"); }
  function ghContentsUrl(path) {
    const p = encodePath(path);
    return `https://api.github.com/repos/${OWNER}/${REPO}/contents/${p}?ref=${encodeURIComponent(BRANCH)}`;
  }

  function getAuthToken() {
    const t = elToken.value.trim();
    if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (c·∫ßn Contents: write).");
    return t;
  }

  async function fetchJson(url, withAuth = false) {
    const headers = { "Accept": "application/vnd.github+json" };
    if (withAuth) headers["Authorization"] = `Bearer ${getAuthToken()}`;

    const res = await fetch(url, { headers });
    const limit = res.headers.get("x-ratelimit-limit");
    const remain = res.headers.get("x-ratelimit-remaining");
    if (limit && remain) elRate.textContent = `GitHub API rate: ${remain}/${limit}`;

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`HTTP ${res.status}\n${txt}`);
    }
    return res.json();
  }

  /** remember token (localStorage) */
  const LS_KEY = `wallpaper_browser_token_${OWNER}_${REPO}`;
  (function initRememberToken(){
    const saved = localStorage.getItem(LS_KEY);
    if (saved) {
      elToken.value = saved;
      elRemember.checked = true;
    }
    elRemember.addEventListener("change", () => {
      if (elRemember.checked) {
        if (elToken.value.trim()) localStorage.setItem(LS_KEY, elToken.value.trim());
      } else {
        localStorage.removeItem(LS_KEY);
      }
    });
    elToken.addEventListener("input", () => {
      if (elRemember.checked) localStorage.setItem(LS_KEY, elToken.value.trim());
    });
  })();

  /** ---------- MEDIA LOAD via API -> blob URL ---------- */
  async function getBlobUrlForFile(folderName, fileName) {
    const key = `${folderName}/${fileName}`;
    const cached = blobUrlCache.get(key);
    if (cached?.url) return cached.url;

    const token = getAuthToken(); // API-only => b·∫Øt bu·ªôc token
    const filePath = `${ROOT_DIR}/${folderName}/${fileName}`;

    const meta = await fetchJson(ghContentsUrl(filePath), true);
    const dl = meta?.download_url;
    if (!dl) throw new Error(`No download_url for ${filePath}`);

    const res = await fetch(dl, { headers: { "Authorization": `Bearer ${token}` } }).catch(() => fetch(dl));
    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Download failed: HTTP ${res.status}\n${txt}`);
    }
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);

    blobUrlCache.set(key, { url, ts: Date.now() });
    if (blobUrlCache.size > MAX_CACHE) {
      const oldestKey = [...blobUrlCache.entries()].sort((a,b)=>a[1].ts-b[1].ts)[0]?.[0];
      if (oldestKey) {
        const old = blobUrlCache.get(oldestKey);
        try { URL.revokeObjectURL(old.url); } catch {}
        blobUrlCache.delete(oldestKey);
      }
    }
    return url;
  }

  function renderFolders(list) {
    elFolders.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const shown = list.filter(f => f.name.toLowerCase().includes(q));
    elFolderCount.textContent = `${shown.length}/${list.length}`;

    for (const f of shown) {
      const div = document.createElement("div");
      div.className = "folder" + (activeFolder === f.name ? " active" : "");
      div.innerHTML = `<span>üìÅ ${f.name}</span><span class="small">open</span>`;
      div.onclick = () => openFolder(f.name);
      elFolders.appendChild(div);
    }
  }

  /** ---------- DELETE ---------- */
  async function deleteFileOnGitHub(filePath, sha) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`;

    const res = await fetch(url, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ message: `Delete ${filePath}`, sha, branch: BRANCH })
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Delete failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function deleteFileFlow(f) {
    if (!activeFolder) return;
    const filePath = `${ROOT_DIR}/${activeFolder}/${f.name}`;

    const ok = confirm(`Xo√° file kh·ªèi GitHub?\n\n${filePath}\n\n‚ö†Ô∏è Kh√¥ng undo ƒë∆∞·ª£c (tr·ª´ khi b·∫°n git revert).`);
    if (!ok) return;

    setStatus(`Deleting...\n${filePath}`);
    await deleteFileOnGitHub(filePath, f.sha);

    setStatus(`‚úÖ Deleted\n${filePath}`);
    await openFolder(activeFolder);
  }

  /** ---------- GRID (c√≥ Update) ---------- */
  async function renderGrid(files) {
    elGrid.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const showPreview = elShowPreview.checked;

    // map base -> preview filename (ch·ªâ d√πng ƒë·ªÉ hint, kh√¥ng d√πng ƒë·ªÉ render)
    const previewByBase = new Map();
    for (const f of files) {
      if (!isMediaFile(f.name)) continue;
      if (!isPreviewName(f.name)) continue;
      const base = f.name.replace("_preview.", ".");
      previewByBase.set(base, f.name);
    }

    // map baseName(without ext) -> mp4 filename
    const mp4ByBase = new Map();
    for (const f of files) {
      const e = extOf(f.name);
      if (VIDEO_EXT.includes(e)) {
        const base = f.name.slice(0, f.name.lastIndexOf("."));
        mp4ByBase.set(base, f.name);
      }
    }

    let shown = files
      .filter(f => isMediaFile(f.name))
      .filter(f => f.name.toLowerCase().includes(q));

    if (!showPreview) shown = shown.filter(f => !isPreviewName(f.name));

    elItemCount.textContent = `Items: ${shown.length}`;

    for (const f of shown) {
      const e = extOf(f.name);
      const isVideo = VIDEO_EXT.includes(e);
      const isImage = IMAGE_EXT.includes(e);

      const card = document.createElement("div");
      card.className = "card";

      const thumb = document.createElement("div");
      thumb.className = "thumb";
      thumb.textContent = "Loading...";

      const meta = document.createElement("div");
      meta.className = "meta";

      const maybePreview = previewByBase.get(f.name);
      const labelPreviewHint =
        (!isVideo && !isPreviewName(f.name) && maybePreview) ? " ¬∑ has preview" : "";

      meta.innerHTML = `
        <div class="name" title="${f.name}">${f.name}</div>
        <div class="pill">${isVideo ? "video" : "image"} ¬∑ ${e}${isPreviewName(f.name) ? " ¬∑ preview" : ""}${labelPreviewHint}</div>
      `;

      const actions = document.createElement("div");
      actions.style.display = "flex";
      actions.style.gap = "8px";
      actions.style.flexWrap = "wrap";
      actions.style.marginTop = "8px";

      // Open (blob)
      const openBtn = document.createElement("a");
      openBtn.className = "btn";
      openBtn.textContent = "üîó Open";
      openBtn.href = "#";
      openBtn.onclick = async (ev) => {
        ev.preventDefault();
        try {
          const url = await getBlobUrlForFile(activeFolder, f.name);
          window.open(url, "_blank", "noopener,noreferrer");
        } catch (err) {
          alert(String(err?.message || err));
        }
      };
      actions.appendChild(openBtn);

      // Delete
      const delBtn = document.createElement("button");
      delBtn.textContent = "üóë Delete";
      delBtn.className = "btn danger";
      delBtn.onclick = async () => {
        try { await deleteFileFlow(f); }
        catch (err) { alert(String(err?.message || err)); }
      };
      actions.appendChild(delBtn);

      // Edit video (trim)
      if (isVideo) {
        const editBtn = document.createElement("a");
        editBtn.textContent = "‚úÇÔ∏è Edit";
        editBtn.className = "btn";
        editBtn.href = `./video_editor.html?mode=edit&folder=${encodeURIComponent(activeFolder)}&video=${encodeURIComponent(f.name)}`;
        editBtn.target = "_blank";
        actions.appendChild(editBtn);
      }

      // Update image from mp4 (webp not preview)
      const isNormalWebp = isImage && e === "webp" && !isPreviewName(f.name);
      if (isNormalWebp) {
        const base = f.name.slice(0, f.name.lastIndexOf("."));
        const mp4 = mp4ByBase.get(base);
        if (mp4) {
          const updBtn = document.createElement("a");
          updBtn.textContent = "üîÑ Update";
          updBtn.className = "btn";
          updBtn.href =
            `./video_editor.html?mode=replaceImage` +
            `&folder=${encodeURIComponent(activeFolder)}` +
            `&video=${encodeURIComponent(mp4)}` +
            `&target=${encodeURIComponent(f.name)}`;
          updBtn.target = "_blank";
          actions.appendChild(updBtn);
        }
      }

      meta.appendChild(actions);
      card.appendChild(thumb);
      card.appendChild(meta);
      elGrid.appendChild(card);

      // Load media blob url and render
      (async () => {
        try {
          const url = await getBlobUrlForFile(activeFolder, f.name);
          thumb.textContent = "";
          if (isVideo) {
            const vv = document.createElement("video");
            vv.src = url;
            vv.controls = true;
            vv.muted = true;
            vv.playsInline = true;
            vv.preload = "metadata";
            thumb.appendChild(vv);
          } else {
            const img = document.createElement("img");
            img.loading = "lazy";
            img.src = url;
            img.alt = f.name;
            thumb.appendChild(img);
          }
        } catch (err) {
          thumb.textContent = "Load failed";
          console.error(err);
        }
      })();
    }
  }

  /** ---------- JSON GENERATOR ---------- */
  function cdnUrl(folder, file) {
    return `${CDN_BASE}${folder}/${file}`;
  }

  function parseBase3(name) {
    // prefix_003.ext
    const m = name.match(/^([a-z0-9]+)_(\d{3})\.(\w+)$/i);
    if (!m) return null;
    return { prefix: m[1].toLowerCase(), idx: Number(m[2]), ext: m[3].toLowerCase(), base: `${m[1]}_${m[2]}` };
  }

  function parsePreview(name) {
    // prefix_003_preview.webp
    const m = name.match(/^([a-z0-9]+)_(\d{3})_preview\.webp$/i);
    if (!m) return null;
    return { prefix: m[1].toLowerCase(), idx: Number(m[2]), base: `${m[1]}_${m[2]}` };
  }

  function parseDouble(name) {
    // double_001_0.webp / double_001_1.webp
    const m = name.match(/^(double)_(\d{3})_(0|1)\.webp$/i);
    if (!m) return null;
    return { idx: Number(m[2]), part: Number(m[3]), base: `double_${m[2]}` };
  }

  function parseDays(name) {
    // days_001_6h.webp / 12h / 18h / 24h
    const m = name.match(/^(days)_(\d{3})_(6h|12h|18h|24h)\.webp$/i);
    if (!m) return null;
    const hourKey = m[3].toLowerCase();
    const hourMap = { "6h":"06:00", "12h":"12:00", "18h":"18:00", "24h":"24:00" };
    return { idx: Number(m[2]), hourKey, hour: hourMap[hourKey] || "", base: `days_${m[2]}` };
  }

  function buildCategoryJsonItems(folder, files) {
    const now = Math.floor(Date.now() / 1000);
    const names = files.map(x => x.name);
    const fileSet = new Set(names);

    // preview map: base -> preview file
    const previewByBase = new Map();
    for (const fn of names) {
      const pv = parsePreview(fn);
      if (pv) previewByBase.set(pv.base, fn);
    }

    // DOUBLE groups
    const doubleGroups = new Map(); // base -> {0,1}
    for (const fn of names) {
      const d = parseDouble(fn);
      if (!d) continue;
      if (!doubleGroups.has(d.base)) doubleGroups.set(d.base, {});
      doubleGroups.get(d.base)[String(d.part)] = fn;
    }

    // DAYS groups
    const daysGroups = new Map(); // base -> arr
    for (const fn of names) {
      const d = parseDays(fn);
      if (!d) continue;
      if (!daysGroups.has(d.base)) daysGroups.set(d.base, []);
      daysGroups.get(d.base).push({ file: fn, hourKey: d.hourKey, hour: d.hour });
    }

    // LIVE/STILL/COUPLE groups by base
    const baseGroups = new Map(); // base -> {prefix, idx, mp4?, webp?}
    for (const fn of names) {
      if (isPreviewName(fn)) continue;
      if (parseDouble(fn) || parseDays(fn)) continue;

      const p = parseBase3(fn);
      if (!p) continue;

      if (!baseGroups.has(p.base)) baseGroups.set(p.base, { prefix: p.prefix, idx: p.idx, mp4: null, webp: null });
      const g = baseGroups.get(p.base);
      if (p.ext === "mp4") g.mp4 = fn;
      if (p.ext === "webp") g.webp = fn;
    }

    const items = [];

    // DOUBLE
    for (const [base, parts] of doubleGroups.entries()) {
      const medias = [];
      if (parts["0"]) medias.push({ url: cdnUrl(folder, parts["0"]), name: parts["0"], thumbUrl: "", contentType: "image/webp" });
      if (parts["1"]) medias.push({ url: cdnUrl(folder, parts["1"]), name: parts["1"], thumbUrl: "", contentType: "image/webp" });
      if (!medias.length) continue;

      items.push({
        id: `${folder}_${base.split("_").pop()}`,
        medias,
        categoryId: folder,
        isPremium: true,
        createdAt: now,
        subType: 0,
        type: TYPE.DOUBLE,
        coinToUnlock: 0
      });
    }

    // DAYS
    for (const [base, arr] of daysGroups.entries()) {
      const order = { "6h":6, "12h":12, "18h":18, "24h":24 };
      const sorted = arr.slice().sort((a,b)=>(order[a.hourKey]||0)-(order[b.hourKey]||0));

      const medias = sorted.map(x => ({
        url: cdnUrl(folder, x.file),
        name: x.file,
        thumbUrl: "",
        hour: x.hour,
        contentType: "image/webp"
      }));
      if (!medias.length) continue;

      items.push({
        id: `${folder}_${base.split("_").pop()}`,
        medias,
        categoryId: folder,
        isPremium: true,
        createdAt: now,
        subType: 0,
        type: TYPE.DAYS,
        coinToUnlock: 0
      });
    }

    // LIVE / STILL / COUPLE
    for (const [base, g] of baseGroups.entries()) {
      // require webp at least
      const webpName = g.webp || `${base}.webp`;
      if (!fileSet.has(webpName)) continue;

      let t;
      if ((g.prefix || "") === "couple") t = TYPE.COUPLE;
      else if (g.mp4) t = TYPE.LIVE;
      else t = TYPE.STILL;

      const medias = [];
      if (t === TYPE.LIVE) {
        if (g.mp4) {
          medias.push({
            url: cdnUrl(folder, g.mp4),
            name: g.mp4,
            thumbUrl: "",
            contentType: "video/mp4"
          });
        }
        const pv = previewByBase.get(base);
        medias.push({
          url: cdnUrl(folder, webpName),
          name: webpName,
          thumbUrl: pv ? cdnUrl(folder, pv) : "",
          contentType: "image/webp"
        });
      } else {
        const pv = previewByBase.get(base);
        medias.push({
          url: cdnUrl(folder, webpName),
          name: webpName,
          thumbUrl: pv ? cdnUrl(folder, pv) : "",
          contentType: "image/webp"
        });
      }

      items.push({
        id: `${folder}_${String(g.idx).padStart(3,"0")}`,
        medias,
        categoryId: folder,
        isPremium: true,
        createdAt: now,
        subType: 0,
        type: t,
        coinToUnlock: 0
      });
    }

    // sort + createdAt stable
    items.sort((a,b)=>{
      const ai = Number((a.id||"").split("_").pop()) || 0;
      const bi = Number((b.id||"").split("_").pop()) || 0;
      return ai - bi;
    });
    for (let i=0;i<items.length;i++) items[i].createdAt = now + i;

    return items;
  }

  function base64EncodeUtf8(str) {
    const bytes = new TextEncoder().encode(str);
    let binary = "";
    for (const b of bytes) binary += String.fromCharCode(b);
    return btoa(binary);
  }

  async function getExistingFileSha(repoPath) {
    try {
      const meta = await fetchJson(ghContentsUrl(repoPath), true);
      return meta?.sha || null;
    } catch (e) {
      const msg = String(e?.message || e);
      if (msg.includes("HTTP 404")) return null;
      return null;
    }
  }

  async function putFileToGitHub(repoPath, contentText, commitMsg) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(repoPath)}`;

    const sha = await getExistingFileSha(repoPath);
    const body = {
      message: commitMsg,
      content: base64EncodeUtf8(contentText),
      branch: BRANCH
    };
    if (sha) body.sha = sha;

    const res = await fetch(url, {
      method: "PUT",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`PUT failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function generateJsonForActiveFolder() {
    if (!activeFolder) { alert("B·∫°n ch∆∞a ch·ªçn folder."); return; }
    if (!activeFiles?.length) { alert("Folder ƒëang tr·ªëng ho·∫∑c ch∆∞a load."); return; }

    const items = buildCategoryJsonItems(activeFolder, activeFiles);
    const jsonText = JSON.stringify(items, null, 2);

    const jsonFileName = `${activeFolder}.json`;
    const repoPath = `${ROOT_DIR}/${activeFolder}/${jsonFileName}`;

    const ok = confirm(
      `Generate & upload JSON?\n\n` +
      `Folder: ${activeFolder}\n` +
      `File: ${repoPath}\n` +
      `Items: ${items.length}\n\n` +
      `‚ö†Ô∏è S·∫Ω t·∫°o m·ªõi ho·∫∑c ghi ƒë√® file JSON trong repo.`
    );
    if (!ok) return;

    setStatus(`Generating JSON...\n${repoPath}\nitems=${items.length}`);
    await putFileToGitHub(repoPath, jsonText, `Generate ${jsonFileName}`);
    setStatus(`‚úÖ Generated!\n${repoPath}\nitems=${items.length}\n\nTip: reload folder ƒë·ªÉ th·∫•y file JSON.`);
    await openFolder(activeFolder);
  }

  /** ---------- LOADERS ---------- */
  async function loadFolders() {
    setStatus("Loading folders... (API-only requires token)");
    elTitle.textContent = "Ch·ªçn folder";
    elSubtitle.textContent = `${OWNER}/${REPO}/${ROOT_DIR}`;
    elItemCount.textContent = "";
    elGrid.innerHTML = "";

    const data = await fetchJson(ghContentsUrl(ROOT_DIR), true);

    allFolders = data
      .filter(x => x.type === "dir")
      .map(x => ({ name: x.name, path: x.path }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    renderFolders(allFolders);
    setStatus("");
  }

  async function openFolder(folderName) {
    activeFolder = folderName;
    renderFolders(allFolders);

    elTitle.textContent = `üìÅ ${folderName}`;
    elSubtitle.textContent = `${ROOT_DIR}/${folderName}`;
    setStatus("Loading files...");
    elGrid.innerHTML = "";

    const path = `${ROOT_DIR}/${folderName}`;
    const data = await fetchJson(ghContentsUrl(path), true);

    activeFiles = data
      .filter(x => x.type === "file")
      .map(x => ({ name: x.name, size: x.size || 0, sha: x.sha }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    setStatus("");
    await renderGrid(activeFiles);
  }

  document.getElementById("reload").onclick = () => loadFolders();
  elGenJson.onclick = async () => {
    try { await generateJsonForActiveFolder(); }
    catch (e) { alert(String(e?.message || e)); }
  };

  elQ.addEventListener("input", () => {
    renderFolders(allFolders);
    if (activeFolder) renderGrid(activeFiles);
  });
  elShowPreview.addEventListener("change", () => {
    if (activeFolder) renderGrid(activeFiles);
  });

  loadFolders().catch(err => setStatus(String(err?.message || err)));
</script>
</body>
</html>
