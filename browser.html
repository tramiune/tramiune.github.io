<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wallpaper Browser</title>
  <style>
    :root { --bd:#e7e7e7; --mut:#666; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    header { padding:12px 14px; border-bottom:1px solid var(--bd); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header b { font-size:14px; }
    header .mut { color:var(--mut); font-size:12px; }
    header input[type="text"], header input[type="password"] {
      padding:8px 10px; border:1px solid var(--bd); border-radius:10px; min-width:220px;
    }
    header button {
      padding:8px 10px; border:1px solid var(--bd); background:#fff; border-radius:10px; cursor:pointer;
    }
    header button:hover { background:#f5f5f5; }
    label.mut { display:inline-flex; gap:6px; align-items:center; }
    input[type="checkbox"] { transform: translateY(1px); }

    .wrap { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 64px); }
    aside { border-right:1px solid var(--bd); padding:10px; overflow:auto; }
    main { padding:12px; overflow:auto; }

    .folder {
      padding:9px 10px; border:1px solid var(--bd); border-radius:12px; cursor:pointer;
      display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;
    }
    .folder:hover { background:#f7f7f7; }
    .folder.active { border-color:#bbb; background:#f5f5f5; }

    .small { font-size:12px; color:var(--mut); }
    .status { font-size:12px; color:var(--mut); white-space:pre-wrap; margin: 6px 0 10px; }

    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(190px, 1fr)); gap:10px; }
    .card { border:1px solid var(--bd); border-radius:14px; overflow:hidden; background:#fff; }
    .thumb { width:100%; aspect-ratio: 9/16; background:#f2f2f2; display:flex; align-items:center; justify-content:center; }
    img, video { width:100%; height:100%; object-fit:cover; display:block; }
    .meta { padding:8px 10px; border-top:1px solid var(--bd); }
    .meta .name { font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .pill { font-size:11px; color:#333; background:#f3f3f3; border:1px solid #e2e2e2; padding:2px 8px; border-radius:999px; display:inline-block; margin-top:6px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .danger { border-color:#f0c1c1 !important; }

    a.btn, button.btn{
      border:1px solid var(--bd); background:#fff; padding:8px 10px; border-radius:10px;
      cursor:pointer; text-decoration:none; color:inherit; display:inline-flex; gap:6px; align-items:center;
    }
    a.btn:hover, button.btn:hover{ background:#f5f5f5; }
    button.btn{ font: inherit; }
  </style>
</head>
<body>
<header>
  <b>Wallpaper Browser</b>
  <span class="mut">CDN media + GitHub Contents API (list/delete/write json)</span>

  <input id="q" type="text" placeholder="Filter folder/file..." />

  <input id="token" type="password" placeholder="GitHub Token (Contents: write)" style="min-width:260px" />
  <label class="mut" title="L∆∞u token tr√™n m√°y b·∫°n (localStorage)">
    <input id="remember" type="checkbox" />
    remember token
  </label>

  <label class="mut" title="Hi·ªán file _preview.webp nh∆∞ item ri√™ng">
    <input id="showPreview" type="checkbox" />
    show _preview
  </label>

  <button id="reload">Reload</button>

  <button id="genAll" class="btn" title="G·ªôp t·∫•t c·∫£ folder 101_,102_... -> dev/wallpaper.json">üß© Generate JSON (ALL)</button>

  <span class="mut" id="rate"></span>
</header>

<div class="wrap">
  <aside>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <b style="font-size:13px;">Folders</b>
      <span class="small" id="folderCount"></span>
    </div>
    <div id="folders"></div>
  </aside>

  <main>
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <div>
        <b id="title" style="font-size:13px;">Ch·ªçn folder</b><br/>
        <span class="small" id="subtitle"></span>
      </div>
      <div class="small" id="itemCount"></div>
    </div>

    <div class="status" id="status"></div>
    <div class="grid" id="grid"></div>
  </main>
</div>

<script>
  /** =========================
   *  CONFIG ‚Äì s·ª≠a ·ªü ƒë√¢y
   *  ========================= */
  const OWNER = "tramiune";
  const REPO  = "tramiune001_res_wallpaper";
  const BRANCH = "main";
  const ROOT_DIR = "resources";

  // CDN cho media (ƒë·ªÉ nh∆∞ c≈©)
  const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

  // JSON output (g·ªôp ALL)
  const ALL_JSON_PATH = "dev/wallpaper.json"; // repo path

  const IMAGE_EXT = ["webp","png","jpg","jpeg","gif"];
  const VIDEO_EXT = ["mp4","webm","mov"];
  /** ========================= */

  // Types
  const TYPE = { LIVE:0, STILL:1, DOUBLE:2, DAYS:3, COUPLE:4 };

  const elFolders = document.getElementById("folders");
  const elGrid = document.getElementById("grid");
  const elStatus = document.getElementById("status");
  const elTitle = document.getElementById("title");
  const elSubtitle = document.getElementById("subtitle");
  const elFolderCount = document.getElementById("folderCount");
  const elItemCount = document.getElementById("itemCount");
  const elQ = document.getElementById("q");
  const elRate = document.getElementById("rate");
  const elToken = document.getElementById("token");
  const elRemember = document.getElementById("remember");
  const elShowPreview = document.getElementById("showPreview");

  let allFolders = [];
  let activeFolder = null;
  let activeFiles = [];

  function setStatus(s) { elStatus.textContent = s || ""; }

  function extOf(name) {
    const i = name.lastIndexOf(".");
    return i >= 0 ? name.slice(i+1).toLowerCase() : "";
  }
  function isMediaFile(name) {
    const e = extOf(name);
    return IMAGE_EXT.includes(e) || VIDEO_EXT.includes(e);
  }
  function isPreviewName(name) { return name.includes("_preview."); }
  function encodePath(path) { return path.split("/").map(encodeURIComponent).join("/"); }

  function ghContentsUrl(path) {
    const p = encodePath(path);
    return `https://api.github.com/repos/${OWNER}/${REPO}/contents/${p}?ref=${encodeURIComponent(BRANCH)}`;
  }

  function mediaUrl(folderName, fileName) {
    return `${CDN_BASE}${folderName}/${fileName}`;
  }

  function getAuthToken() {
    const t = elToken.value.trim();
    if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (c·∫ßn Contents: write).");
    return t;
  }

  async function fetchJson(url, withAuth = false) {
    const headers = { "Accept": "application/vnd.github+json" };
    if (withAuth) headers["Authorization"] = `Bearer ${getAuthToken()}`;

    const res = await fetch(url, { headers });
    const limit = res.headers.get("x-ratelimit-limit");
    const remain = res.headers.get("x-ratelimit-remaining");
    if (limit && remain) elRate.textContent = `GitHub API rate: ${remain}/${limit}`;

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`HTTP ${res.status}\n${txt}`);
    }
    return res.json();
  }

  /** remember token (localStorage) */
  const LS_KEY = `wallpaper_browser_token_${OWNER}_${REPO}`;
  (function initRememberToken(){
    const saved = localStorage.getItem(LS_KEY);
    if (saved) {
      elToken.value = saved;
      elRemember.checked = true;
    }
    elRemember.addEventListener("change", () => {
      if (elRemember.checked) {
        if (elToken.value.trim()) localStorage.setItem(LS_KEY, elToken.value.trim());
      } else {
        localStorage.removeItem(LS_KEY);
      }
    });
    elToken.addEventListener("input", () => {
      if (elRemember.checked) localStorage.setItem(LS_KEY, elToken.value.trim());
    });
  })();

  /** ---------- DELETE ---------- */
  async function deleteFileOnGitHub(filePath, sha) {
    const token = getAuthToken();
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(filePath)}`;

    const res = await fetch(url, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ message: `Delete ${filePath}`, sha, branch: BRANCH })
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Delete failed: HTTP ${res.status}\n${txt}`);
    }
  }

  async function deleteFileFlow(f) {
    if (!activeFolder) return;
    const filePath = `${ROOT_DIR}/${activeFolder}/${f.name}`;

    const ok = confirm(`Xo√° file kh·ªèi GitHub?\n\n${filePath}\n\n‚ö†Ô∏è Kh√¥ng undo ƒë∆∞·ª£c (tr·ª´ khi b·∫°n git revert).`);
    if (!ok) return;

    setStatus(`Deleting...\n${filePath}`);
    await deleteFileOnGitHub(filePath, f.sha);

    setStatus(`‚úÖ Deleted\n${filePath}`);
    await openFolder(activeFolder);
  }

  /** ---------- UPSERT FILE (PUT) ---------- */
  function b64EncodeUnicode(str) {
    // base64 utf-8 safe
    const bytes = new TextEncoder().encode(str);
    let bin = "";
    for (const b of bytes) bin += String.fromCharCode(b);
    return btoa(bin);
  }

  async function getFileShaIfExists(path) {
    try {
      const meta = await fetchJson(ghContentsUrl(path), true);
      if (meta && meta.sha) return meta.sha;
      return null;
    } catch (e) {
      const msg = String(e?.message || e);
      if (msg.includes("HTTP 404")) return null;
      return null; // best-effort
    }
  }

  async function upsertTextFile(path, text, message) {
    const token = getAuthToken();
    const sha = await getFileShaIfExists(path);

    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(path)}`;
    const body = {
      message: message || `Update ${path}`,
      content: b64EncodeUnicode(text),
      branch: BRANCH
    };
    if (sha) body.sha = sha;

    const res = await fetch(url, {
      method: "PUT",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });

    if (!res.ok) {
      const txt = await res.text().catch(()=> "");
      throw new Error(`Write failed: HTTP ${res.status}\n${txt}`);
    }
    return res.json();
  }

  /** ---------- GRID (kept: Update/Edit/Delete) ---------- */
  async function renderGrid(files) {
    elGrid.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const showPreview = elShowPreview.checked;

    // preview map: base file -> preview file
    const previewByBase = new Map();
    for (const f of files) {
      if (!isMediaFile(f.name)) continue;
      if (!isPreviewName(f.name)) continue;
      const base = f.name.replace("_preview.", ".");
      previewByBase.set(base, f.name);
    }

    // mp4 map: base name -> mp4 file (for Update)
    const mp4ByBase = new Map();
    for (const f of files) {
      const e = extOf(f.name);
      if (VIDEO_EXT.includes(e)) {
        const base = f.name.slice(0, f.name.lastIndexOf(".")); // anime_003
        mp4ByBase.set(base, f.name);
      }
    }

    let shown = files
      .filter(f => isMediaFile(f.name))
      .filter(f => f.name.toLowerCase().includes(q));

    if (!showPreview) shown = shown.filter(f => !isPreviewName(f.name));

    elItemCount.textContent = `Items: ${shown.length}`;

    for (const f of shown) {
      const e = extOf(f.name);
      const isVideo = VIDEO_EXT.includes(e);
      const isImage = IMAGE_EXT.includes(e);

      const card = document.createElement("div");
      card.className = "card";

      const thumb = document.createElement("div");
      thumb.className = "thumb";

      // IMPORTANT: do NOT swap still webp into preview.
      // Only use preview thumbnail when file is a video, or when user opened the preview file itself.
      const maybePreview = previewByBase.get(f.name);
      const displayUrl = (isVideo && maybePreview)
        ? mediaUrl(activeFolder, maybePreview)  // if video has preview, show preview image instead of loading mp4 in grid
        : mediaUrl(activeFolder, f.name);

      if (isVideo) {
        // show preview as image (lighter). user can click open to play video.
        if (maybePreview) {
          const img = document.createElement("img");
          img.loading = "lazy";
          img.src = displayUrl;
          img.alt = f.name;
          thumb.appendChild(img);
        } else {
          const v = document.createElement("video");
          v.src = displayUrl;
          v.controls = true;
          v.muted = true;
          v.playsInline = true;
          v.preload = "metadata";
          thumb.appendChild(v);
        }
      } else {
        const img = document.createElement("img");
        img.loading = "lazy";
        img.src = displayUrl;
        img.alt = f.name;
        thumb.appendChild(img);
      }

      const meta = document.createElement("div");
      meta.className = "meta";

      const labelPreviewHint =
        (!isVideo && !isPreviewName(f.name) && maybePreview) ? " ¬∑ has preview" : "";

      meta.innerHTML = `
        <div class="name" title="${f.name}">${f.name}</div>
        <div class="pill">${isVideo ? "video" : "image"} ¬∑ ${e}${isPreviewName(f.name) ? " ¬∑ preview" : ""}${labelPreviewHint}</div>
        <div class="small" style="margin-top:6px;">
          <a href="${mediaUrl(activeFolder, f.name)}" target="_blank" rel="noreferrer">open file</a>
        </div>
      `;

      const actions = document.createElement("div");
      actions.style.display = "flex";
      actions.style.gap = "8px";
      actions.style.flexWrap = "wrap";
      actions.style.marginTop = "8px";

      // delete
      const delBtn = document.createElement("button");
      delBtn.textContent = "üóë Delete";
      delBtn.className = "btn danger";
      delBtn.onclick = async () => {
        try { await deleteFileFlow(f); }
        catch (err) { alert(String(err?.message || err)); }
      };
      actions.appendChild(delBtn);

      // edit video
      if (isVideo) {
        const editBtn = document.createElement("a");
        editBtn.textContent = "‚úÇÔ∏è Edit";
        editBtn.className = "btn";
        editBtn.href = `./video_editor.html?mode=edit&folder=${encodeURIComponent(activeFolder)}&video=${encodeURIComponent(f.name)}`;
        editBtn.target = "_blank";
        actions.appendChild(editBtn);
      }

      // update image from mp4 (kept)
      const isNormalWebp = isImage && e === "webp" && !isPreviewName(f.name);
      if (isNormalWebp) {
        const base = f.name.slice(0, f.name.lastIndexOf(".")); // anime_001
        const mp4 = mp4ByBase.get(base);
        if (mp4) {
          const updBtn = document.createElement("a");
          updBtn.textContent = "üîÑ Update";
          updBtn.className = "btn";
          updBtn.href =
            `./video_editor.html?mode=replaceImage` +
            `&folder=${encodeURIComponent(activeFolder)}` +
            `&video=${encodeURIComponent(mp4)}` +
            `&target=${encodeURIComponent(f.name)}`;
          updBtn.target = "_blank";
          actions.appendChild(updBtn);
        }
      }

      meta.appendChild(actions);
      card.appendChild(thumb);
      card.appendChild(meta);
      elGrid.appendChild(card);
    }
  }

  /** ---------- LIST ---------- */
  function renderFolders(list) {
    elFolders.innerHTML = "";
    const q = elQ.value.trim().toLowerCase();
    const shown = list.filter(f => f.name.toLowerCase().includes(q));
    elFolderCount.textContent = `${shown.length}/${list.length}`;

    for (const f of shown) {
      const div = document.createElement("div");
      div.className = "folder" + (activeFolder === f.name ? " active" : "");
      div.innerHTML = `<span>üìÅ ${f.name}</span><span class="small">open</span>`;
      div.onclick = () => openFolder(f.name);
      elFolders.appendChild(div);
    }
  }

  async function loadFolders() {
    setStatus("Loading folders...");
    elTitle.textContent = "Ch·ªçn folder";
    elSubtitle.textContent = `${OWNER}/${REPO}/${ROOT_DIR}`;
    elItemCount.textContent = "";
    elGrid.innerHTML = "";

    const data = await fetchJson(ghContentsUrl(ROOT_DIR), false);

    allFolders = data
      .filter(x => x.type === "dir")
      .map(x => ({ name: x.name, path: x.path }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    renderFolders(allFolders);
    setStatus("");
  }

  async function openFolder(folderName) {
    activeFolder = folderName;
    renderFolders(allFolders);

    elTitle.textContent = `üìÅ ${folderName}`;
    elSubtitle.textContent = `${ROOT_DIR}/${folderName}`;
    setStatus("Loading files...");
    elGrid.innerHTML = "";

    const path = `${ROOT_DIR}/${folderName}`;
    const data = await fetchJson(ghContentsUrl(path), false);

    activeFiles = data
      .filter(x => x.type === "file")
      .map(x => ({ name: x.name, size: x.size || 0, sha: x.sha }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));

    setStatus("");
    await renderGrid(activeFiles);
  }

  /** =========================
   *  JSON GENERATOR (ALL)
   *  Rules:
   *   - scan folders in resources/ matching /^\d+_/
   *   - infer type by filename prefix:
   *       couple_*           => type=4, medias=[{webp(+preview)}]
   *       double_<id>_0/1    => type=2, medias=[_0.webp, _1.webp]
   *       days_<id>_6h/12h/18h/24h => type=3, medias with hour
   *       default:
   *         has mp4 + webp   => type=0 (LIVE)
   *         only webp        => type=1 (STILL)
   *   - thumbUrl uses *_preview.webp if exists else ""
   *   - id: `${categoryId}_${NNN}` (NNN extracted from base name)
   *   - createdAt: Date.now()/1000 (unix seconds) at generation time
   *   - isPremium: true, subType:0, coinToUnlock:0
   *  ========================= */

  function pad3(n) {
    const s = String(n);
    if (s.length >= 3) return s;
    return ("000" + s).slice(-3);
  }

  function mimeFor(ext) {
    ext = ext.toLowerCase();
    if (ext === "webp") return "image/webp";
    if (ext === "png") return "image/png";
    if (ext === "jpg" || ext === "jpeg") return "image/jpeg";
    if (ext === "gif") return "image/gif";
    if (ext === "mp4") return "video/mp4";
    if (ext === "webm") return "video/webm";
    if (ext === "mov") return "video/quicktime";
    return "application/octet-stream";
  }

  function byName(files) {
    const m = new Map();
    for (const f of files) m.set(f.name, f);
    return m;
  }

  function listNames(files) { return files.map(x => x.name); }

  function parseNumberFromName(name) {
    // try find last _NNN before extension or before extra suffix
    // examples:
    // anime_003.webp -> 3
    // double_001_0.webp -> 1
    // days_001_6h.webp -> 1
    const base = name.replace(/\.[^.]+$/, "");
    const m = base.match(/_(\d{1,})$/);
    if (m) return parseInt(m[1], 10);

    const m2 = base.match(/_(\d{1,})_(?:0|1)$/);
    if (m2) return parseInt(m2[1], 10);

    const m3 = base.match(/_(\d{1,})_(?:6h|12h|18h|24h)$/);
    if (m3) return parseInt(m3[1], 10);

    // fallback: any 3 digits
    const m4 = base.match(/(\d{3})/);
    if (m4) return parseInt(m4[1], 10);

    return null;
  }

  function detectPrefix(files) {
    // pick first non-preview media file and use prefix before last _NNN
    const names = listNames(files).filter(n => isMediaFile(n) && !isPreviewName(n));
    for (const n of names) {
      const base = n.replace(/\.[^.]+$/, "");
      // remove trailing parts like _0/_1/_6h...
      const cleaned = base
        .replace(/_(?:0|1)$/, "")
        .replace(/_(?:6h|12h|18h|24h)$/, "");
      const m = cleaned.match(/^(.*)_\d+$/);
      if (m) return m[1];
    }
    return "";
  }

  function buildItemLive(categoryId, prefix, num, hasPreview, createdAtSec) {
    const nnn = pad3(num);
    const mp4Name = `${prefix}_${nnn}.mp4`;
    const webpName = `${prefix}_${nnn}.webp`;
    const previewName = `${prefix}_${nnn}_preview.webp`;

    const medias = [
      {
        url: mediaUrl(categoryId, mp4Name),
        name: mp4Name,
        thumbUrl: "",
        contentType: "video/mp4"
      },
      {
        url: mediaUrl(categoryId, webpName),
        name: webpName,
        thumbUrl: hasPreview ? mediaUrl(categoryId, previewName) : "",
        contentType: "image/webp"
      }
    ];

    return {
      id: `${categoryId}_${nnn}`,
      medias,
      categoryId,
      isPremium: true,
      createdAt: createdAtSec,
      subType: 0,
      type: TYPE.LIVE,
      coinToUnlock: 0
    };
  }

  function buildItemStill(categoryId, prefix, num, hasPreview, createdAtSec) {
    const nnn = pad3(num);
    const webpName = `${prefix}_${nnn}.webp`;
    const previewName = `${prefix}_${nnn}_preview.webp`;

    const medias = [
      {
        url: mediaUrl(categoryId, webpName),
        name: webpName,
        thumbUrl: hasPreview ? mediaUrl(categoryId, previewName) : "",
        contentType: "image/webp"
      }
    ];

    return {
      id: `${categoryId}_${nnn}`,
      medias,
      categoryId,
      isPremium: true,
      createdAt: createdAtSec,
      subType: 0,
      type: TYPE.STILL,
      coinToUnlock: 0
    };
  }

  function buildItemCouple(categoryId, num, hasPreview, createdAtSec) {
    const nnn = pad3(num);
    const webpName = `couple_${nnn}.webp`;
    const previewName = `couple_${nnn}_preview.webp`;

    const medias = [
      {
        url: mediaUrl(categoryId, webpName),
        name: webpName,
        thumbUrl: hasPreview ? mediaUrl(categoryId, previewName) : "",
        contentType: "image/webp"
      }
    ];

    return {
      id: `${categoryId}_${nnn}`,
      medias,
      categoryId,
      isPremium: true,
      createdAt: createdAtSec,
      subType: 0,
      type: TYPE.COUPLE,
      coinToUnlock: 0
    };
  }

  function buildItemDouble(categoryId, num, createdAtSec) {
    const nnn = pad3(num);
    const a = `double_${nnn}_0.webp`;
    const b = `double_${nnn}_1.webp`;

    const medias = [
      { url: mediaUrl(categoryId, a), name: a, thumbUrl: "", contentType: "image/webp" },
      { url: mediaUrl(categoryId, b), name: b, thumbUrl: "", contentType: "image/webp" }
    ];

    return {
      id: `${categoryId}_${nnn}`,
      medias,
      categoryId,
      isPremium: true,
      createdAt: createdAtSec,
      subType: 0,
      type: TYPE.DOUBLE,
      coinToUnlock: 0
    };
  }

  function buildItemDays(categoryId, num, createdAtSec) {
    const nnn = pad3(num);
    const slots = [
      { suf: "6h", hour: "06:00" },
      { suf: "12h", hour: "12:00" },
      { suf: "18h", hour: "18:00" },
      { suf: "24h", hour: "24:00" }
    ];
    const medias = slots.map(s => {
      const name = `days_${nnn}_${s.suf}.webp`;
      return {
        url: mediaUrl(categoryId, name),
        name,
        thumbUrl: "",
        hour: s.hour,
        contentType: "image/webp"
      };
    });

    return {
      id: `${categoryId}_${nnn}`,
      medias,
      categoryId,
      isPremium: true,
      createdAt: createdAtSec,
      subType: 0,
      type: TYPE.DAYS,
      coinToUnlock: 0
    };
  }

  function generateItemsForFolder(categoryId, files) {
    const createdAtSec = Math.floor(Date.now() / 1000);

    const nameMap = byName(files);
    const names = new Set(listNames(files));

    // detect based on filename prefixes
    const hasAny = (re) => {
      for (const n of names) if (re.test(n)) return true;
      return false;
    };

    // Collect numbers for each type
    const nums = new Set();

    // couple
    for (const n of names) {
      const m = n.match(/^couple_(\d+)\.webp$/);
      if (m) nums.add(parseInt(m[1], 10));
    }

    // double
    for (const n of names) {
      const m = n.match(/^double_(\d+)_(0|1)\.webp$/);
      if (m) nums.add(parseInt(m[1], 10));
    }

    // days
    for (const n of names) {
      const m = n.match(/^days_(\d+)_(6h|12h|18h|24h)\.webp$/);
      if (m) nums.add(parseInt(m[1], 10));
    }

    // default (anime/silly/whatever): detect prefix
    const prefix = detectPrefix(files); // e.g. anime, silly...
    if (prefix) {
      for (const n of names) {
        // base media: prefix_NNN.(mp4|webp)
        const m = n.match(new RegExp(`^${prefix}_(\\d+)\\.(mp4|webp)$`));
        if (m) nums.add(parseInt(m[1], 10));
      }
    }

    const sortedNums = [...nums].sort((a,b)=>a-b);
    const items = [];

    for (const num of sortedNums) {
      const nnn = pad3(num);

      // COUPLE
      const coupleWebp = `couple_${nnn}.webp`;
      if (names.has(coupleWebp)) {
        const hasPreview = names.has(`couple_${nnn}_preview.webp`);
        items.push(buildItemCouple(categoryId, num, hasPreview, createdAtSec));
        continue;
      }

      // DOUBLE
      const d0 = `double_${nnn}_0.webp`;
      const d1 = `double_${nnn}_1.webp`;
      if (names.has(d0) && names.has(d1)) {
        items.push(buildItemDouble(categoryId, num, createdAtSec));
        continue;
      }

      // DAYS
      const day6 = `days_${nnn}_6h.webp`;
      const day12 = `days_${nnn}_12h.webp`;
      const day18 = `days_${nnn}_18h.webp`;
      const day24 = `days_${nnn}_24h.webp`;
      if (names.has(day6) && names.has(day12) && names.has(day18) && names.has(day24)) {
        items.push(buildItemDays(categoryId, num, createdAtSec));
        continue;
      }

      // DEFAULT (LIVE/STILL)
      if (prefix) {
        const mp4 = `${prefix}_${nnn}.mp4`;
        const webp = `${prefix}_${nnn}.webp`;
        const preview = `${prefix}_${nnn}_preview.webp`;
        const hasPreview = names.has(preview);

        const hasMp4 = names.has(mp4);
        const hasWebp = names.has(webp);

        if (hasMp4 && hasWebp) {
          items.push(buildItemLive(categoryId, prefix, num, hasPreview, createdAtSec));
          continue;
        }
        if (hasWebp) {
          items.push(buildItemStill(categoryId, prefix, num, hasPreview, createdAtSec));
          continue;
        }
      }
    }

    return items;
  }

  async function listFolderFiles(folderName) {
    const path = `${ROOT_DIR}/${folderName}`;
    const data = await fetchJson(ghContentsUrl(path), false);
    return data
      .filter(x => x.type === "file")
      .map(x => ({ name: x.name, size: x.size || 0, sha: x.sha }))
      .sort((a,b) => a.name.localeCompare(b.name, "en"));
  }

  async function generateAllJsonAndUpload() {
    try {
      // need token to write
      getAuthToken();

      setStatus("Generating ALL JSON...\nScanning folders 101_, 102_, ...");
      const root = await fetchJson(ghContentsUrl(ROOT_DIR), false);

      const folders = root
        .filter(x => x.type === "dir")
        .map(x => x.name)
        .filter(name => /^\d+_/.test(name))
        .sort((a,b) => a.localeCompare(b, "en"));

      let allItems = [];
      for (let i=0;i<folders.length;i++) {
        const folderName = folders[i];
        setStatus(`Generating ALL JSON...\n(${i+1}/${folders.length}) ${folderName}`);
        const files = await listFolderFiles(folderName);
        const items = generateItemsForFolder(folderName, files);
        allItems = allItems.concat(items);
      }

      // Output is array only (as you requested ‚Äúg·ªôp th√†nh 1 json‚Äù)
      const jsonText = JSON.stringify(allItems, null, 2);

      setStatus(`Uploading...\n${ALL_JSON_PATH}\nItems: ${allItems.length}`);
      await upsertTextFile(
        ALL_JSON_PATH,
        jsonText,
        `Generate ${ALL_JSON_PATH} (${allItems.length} items)`
      );

      setStatus(`‚úÖ Done!\nWrote: ${ALL_JSON_PATH}\nItems: ${allItems.length}\n\nAPI:\nhttps://${OWNER}.github.io/${REPO}/dev/wallpaper.json`);
      alert(`‚úÖ Generate ALL JSON OK!\nItems: ${allItems.length}\nWrote: ${ALL_JSON_PATH}`);
    } catch (err) {
      console.error(err);
      setStatus(`‚ùå Failed:\n${String(err?.message || err)}`);
      alert(String(err?.message || err));
    }
  }

  /** ---------- EVENTS ---------- */
  document.getElementById("reload").onclick = () => loadFolders();
  document.getElementById("genAll").onclick = () => generateAllJsonAndUpload();

  elQ.addEventListener("input", () => {
    renderFolders(allFolders);
    if (activeFolder) renderGrid(activeFiles);
  });
  elShowPreview.addEventListener("change", () => {
    if (activeFolder) renderGrid(activeFiles);
  });

  loadFolders().catch(err => setStatus(String(err?.message || err)));
</script>
</body>
</html>
