<!doctype html>
<html lang="vi">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Orders ‚Ä¢ Wallpaper</title>
    <style>
        :root { --bd:#e7e7e7; --mut:#666; }
        body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#fff; }
        header {
          padding:12px 14px; border-bottom:1px solid var(--bd);
          display:flex; gap:10px; align-items:center; flex-wrap:wrap;
        }
        header b { font-size:14px; }
        .mut { color:var(--mut); font-size:12px; }
        input[type="text"], input[type="password"]{
          padding:8px 10px; border:1px solid var(--bd); border-radius:10px; min-width:220px;
        }
        button, a.btn{
          padding:8px 10px; border:1px solid var(--bd); background:#fff; border-radius:10px; cursor:pointer;
          text-decoration:none; color:inherit; display:inline-flex; gap:6px; align-items:center;
        }
        button:hover, a.btn:hover { background:#f5f5f5; }
        label.mut { display:inline-flex; gap:6px; align-items:center; }
        input[type="checkbox"] { transform: translateY(1px); }
        .danger { border-color:#f0c1c1 !important; }

        .wrap { display:grid; grid-template-columns: 300px 1fr; min-height: calc(100vh - 64px); }
        aside { border-right:1px solid var(--bd); padding:10px; overflow:auto; }
        main { padding:12px; overflow:auto; }

        .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
        .status { font-size:12px; color:var(--mut); white-space:pre-wrap; margin: 8px 0 10px; }

        .folder {
          padding:9px 10px; border:1px solid var(--bd); border-radius:12px; cursor:pointer;
          display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;
        }
        .folder:hover { background:#f7f7f7; }
        .folder.active { border-color:#bbb; background:#f5f5f5; }
        .small { font-size:12px; color:var(--mut); }

        .list { display:flex; flex-direction:column; gap:10px; }
        .item {
          border:1px solid var(--bd); border-radius:14px; overflow:hidden; background:#fff;
          display:grid; grid-template-columns: 120px 1fr; gap:10px;
        }
        .thumb {
          width:120px; aspect-ratio: 9/16; background:#f2f2f2; display:flex; align-items:center; justify-content:center;
          overflow:hidden;
        }
        /* QUAN TR·ªåNG: ƒë·ªÉ kh√¥ng "ƒÉn drag" */
        .thumb img, .thumb video { width:100%; height:100%; object-fit:cover; display:block; pointer-events:none; user-select:none; }
        .meta { padding:10px 10px 10px 0; }
        .name { font-size:12px; font-weight:600; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .pill { font-size:11px; color:#333; background:#f3f3f3; border:1px solid #e2e2e2; padding:2px 8px; border-radius:999px; display:inline-block; margin-top:6px; }
        .actions { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px; }
        .hint { font-size:12px; color:var(--mut); margin-top:6px; }

        .handle {
          cursor:grab; user-select:none;
          padding:6px 8px; border:1px dashed #ddd; border-radius:10px;
          display:inline-flex; gap:6px; align-items:center;
          touch-action:none; /* ƒë·ªÉ k√©o tr√™n mobile m∆∞·ª£t */
        }
        .handle:active { cursor:grabbing; }

        /* dragging ghost */
        .drag-ghost {
          position: fixed;
          z-index: 9999;
          width: min(620px, calc(100vw - 24px));
          box-shadow: 0 10px 30px rgba(0,0,0,0.18);
          border:1px solid #ddd;
          background:#fff;
          border-radius:14px;
          overflow:hidden;
          pointer-events:none;
          transform: translate(-50%, -50%);
        }
        .placeholder {
          border:1px dashed #bbb;
          border-radius:14px;
          background: #fafafa;
        }
    </style>
</head>
<body>

<header>
    <b>Orders</b>
    <span class="mut">K√©o th·∫£ s·∫Øp x·∫øp item theo folder ¬∑ LIVE tick preview</span>

    <input id="q" type="text" placeholder="Filter folder/item..." />

    <input id="token" type="password" placeholder="GitHub Token (write)" style="min-width:260px" />
    <label class="mut" title="L∆∞u token localStorage">
        <input id="rememberToken" type="checkbox" />
        remember token
    </label>

    <button id="saveLocal">Save orders (local)</button>
    <button id="loadLocal">Load orders (local)</button>
    <button id="uploadOrders">Upload dev/orders.json</button>

    <button id="genAll">Generate JSON (ALL like browser)</button>
    <span class="mut" id="rate"></span>
</header>

<div class="wrap">
    <aside>
        <div class="row" style="justify-content:space-between; margin-bottom:8px;">
            <b style="font-size:13px;">Folders</b>
            <span class="small" id="folderCount"></span>
        </div>
        <div id="folders"></div>
    </aside>

    <main>
        <div class="row" style="justify-content:space-between; margin-bottom:8px;">
            <div>
                <b id="title" style="font-size:13px;">Ch·ªçn folder</b><br/>
                <span class="small" id="subtitle"></span>
            </div>
            <div class="small" id="itemCount"></div>
        </div>

        <div class="status" id="status"></div>
        <div class="list" id="list"></div>
    </main>
</div>

<script>
    /** =========================
     *  CONFIG (gi·ªëng browser)
     *  ========================= */
    const OWNER = "tramiune";
    const REPO  = "tramiune001_res_wallpaper";
    const BRANCH = "main";
    const ROOT_DIR = "resources";
    const CDN_BASE = `https://cdn.jsdelivr.net/gh/${OWNER}/${REPO}/${ROOT_DIR}/`;

    const OUTPUT_ALL_JSON = "dev/wallpaper.json";
    const ORDERS_PATH = "dev/orders.json";

    const IMAGE_EXT = ["webp","png","jpg","jpeg","gif"];
    const VIDEO_EXT = ["mp4","webm","mov"];

    const TYPE = { LIVE:0, STILL:1, DOUBLE:2, DAYS:3, COUPLE:4 };
    /** ========================= */

    const elFolders = document.getElementById("folders");
    const elList = document.getElementById("list");
    const elStatus = document.getElementById("status");
    const elTitle = document.getElementById("title");
    const elSubtitle = document.getElementById("subtitle");
    const elFolderCount = document.getElementById("folderCount");
    const elItemCount = document.getElementById("itemCount");
    const elQ = document.getElementById("q");
    const elRate = document.getElementById("rate");
    const elToken = document.getElementById("token");
    const elRememberToken = document.getElementById("rememberToken");

    let allFolders = [];          // [{name,path}]
    let activeFolder = null;
    let folderCache = new Map();  // folderName -> { files:[name], items:[item] }

    let ordersState = {
      version: 1,
      updatedAt: 0,
      categories: {
        // [categoryId]: { order:[ids], liveUsePreview:{[id]:boolean} }
      }
    };

    /** ========= utils ========= */
    function setStatus(s){ elStatus.textContent = s || ""; }
    function extOf(name){ const i=name.lastIndexOf("."); return i>=0?name.slice(i+1).toLowerCase():""; }
    function pad3(n){ return String(n).padStart(3,"0"); }
    function encodePath(path){ return path.split("/").map(encodeURIComponent).join("/"); }
    function cdnUrl(folder, file){ return `${CDN_BASE}${folder}/${file}`; }
    function folderDefaultPrefix(folderName){ return folderName.replace(/^\d+_/, ""); }
    function isPreviewName(name){ return name.includes("_preview."); }
    function contentTypeFromExt(name){
      const e=extOf(name);
      if (e==="webp") return "image/webp";
      if (e==="png") return "image/png";
      if (e==="jpg"||e==="jpeg") return "image/jpeg";
      if (e==="gif") return "image/gif";
      if (e==="mp4") return "video/mp4";
      if (e==="webm") return "video/webm";
      if (e==="mov") return "video/quicktime";
      return "application/octet-stream";
    }
    function hourToHHMM(h){
      const hh = String(parseInt(h,10)).padStart(2,"0");
      return `${hh}:00`;
    }
    function typeLabel(t){
      if (t===TYPE.LIVE) return "LIVE";
      if (t===TYPE.STILL) return "STILL";
      if (t===TYPE.DOUBLE) return "DOUBLE";
      if (t===TYPE.DAYS) return "DAYS";
      if (t===TYPE.COUPLE) return "COUPLE";
      return String(t);
    }

    function getAuthToken(){
      const t = elToken.value.trim();
      if (!t) throw new Error("B·∫°n ch∆∞a nh·∫≠p GitHub token (write).");
      return t;
    }
    async function fetchJson(url, withAuth=false){
      const headers = { "Accept":"application/vnd.github+json" };
      if (withAuth) headers["Authorization"] = `Bearer ${getAuthToken()}`;
      const res = await fetch(url, { headers });
      const limit = res.headers.get("x-ratelimit-limit");
      const remain = res.headers.get("x-ratelimit-remaining");
      if (limit && remain) elRate.textContent = `GitHub API rate: ${remain}/${limit}`;
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`HTTP ${res.status}\n${txt}`);
      }
      return res.json();
    }
    function ghContentsUrl(path){
      return `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(path)}?ref=${encodeURIComponent(BRANCH)}`;
    }

    /** ========= token localStorage ========= */
    const LS_TOKEN = `orders_token_${OWNER}_${REPO}`;
    (function initToken(){
      const saved = localStorage.getItem(LS_TOKEN);
      if (saved) { elToken.value = saved; elRememberToken.checked = true; }
      elRememberToken.addEventListener("change", () => {
        if (elRememberToken.checked) {
          if (elToken.value.trim()) localStorage.setItem(LS_TOKEN, elToken.value.trim());
        } else {
          localStorage.removeItem(LS_TOKEN);
        }
      });
      elToken.addEventListener("input", () => {
        if (elRememberToken.checked) localStorage.setItem(LS_TOKEN, elToken.value.trim());
      });
    })();

    /** ========= orders localStorage ========= */
    const LS_ORDERS = `orders_state_${OWNER}_${REPO}`;
    function saveOrdersLocal(){
      ordersState.updatedAt = Math.floor(Date.now()/1000);
      localStorage.setItem(LS_ORDERS, JSON.stringify(ordersState));
    }
    function loadOrdersLocal(){
      const raw = localStorage.getItem(LS_ORDERS);
      if (!raw) return null;
      try { return JSON.parse(raw); } catch { return null; }
    }

    /** ========= Git upsert text file ========= */
    async function upsertTextFile(path, text, message) {
      const token = getAuthToken();
      const apiUrl = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodePath(path)}`;

      // check sha if exists
      let sha = null;
      try {
        const meta = await fetchJson(apiUrl + `?ref=${encodeURIComponent(BRANCH)}`, true);
        sha = meta?.sha || null;
      } catch { sha = null; }

      const contentB64 = btoa(unescape(encodeURIComponent(text)));

      const body = { message, content: contentB64, branch: BRANCH };
      if (sha) body.sha = sha;

      const res = await fetch(apiUrl, {
        method: "PUT",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });

      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`Upsert failed: HTTP ${res.status}\n${txt}`);
      }
    }

    /** ========= Orders helpers ========= */
    function ensureCategoryState(catId){
      if (!ordersState.categories[catId]) {
        ordersState.categories[catId] = { order: [], liveUsePreview: {} };
      }
      return ordersState.categories[catId];
    }
    function syncOrderFromDOM(catId){
      const st = ensureCategoryState(catId);
      const ids = [...elList.querySelectorAll(".item")].map(x => x.dataset.id);
      st.order = ids;
    }
    function applyOrder(catId, items){
      const st = ensureCategoryState(catId);
      const byId = new Map(items.map(it => [it.id, it]));
      const out = [];

      for (const id of st.order) {
        const it = byId.get(id);
        if (it) { out.push(it); byId.delete(id); }
      }
      for (const it of byId.values()) out.push(it);
      return out;
    }

    /** ========= Build items (GI·ªêNG LOGIC browser b·∫°n mu·ªën) =========
     * Rule:
     * - LIVE: c√≥ mp4 + webp c√πng s·ªë -> type=0, medias[0]=video, medias[1]=image, thumbUrl=preview (t√πy checkbox)
     * - STILL: ch·ªâ webp -> type=1
     * - COUPLE: file b·∫Øt ƒë·∫ßu couple_... -> type=4
     * - DOUBLE: double_###_0.webp + double_###_1.webp -> type=2 (2 ·∫£nh)
     * - DAYS: days_###_6h/12h/18h/24h.webp -> type=3 (4 ·∫£nh c√≥ hour)
     *
     * ID: KH√îNG TR√ôNG -> m·∫∑c ƒë·ªãnh id = `${categoryId}_${num}` (num 3 ch·ªØ s·ªë)
     */
    function buildItemsFromFiles(folderName, fileNames) {
      const categoryId = folderName;
      const defPrefix = folderDefaultPrefix(folderName);

      const previewByBaseImage = new Map(); // key: baseImageName -> previewFileName
      for (const name of fileNames) {
        const m = name.match(/^(.*)_(\d{1,})_preview\.webp$/i);
        if (m) {
          const base = `${m[1]}_${pad3(m[2])}.webp`;
          previewByBaseImage.set(base, name);
        }
      }

      // group for special types
      const doubleByNum = new Map(); // num -> {0,1}
      const daysByNum = new Map();   // num -> Map(hour -> file)
      const coupleByNum = new Map(); // num -> {single,0,1,preview}

      // live/still sets: key prefix|num
      const mp4ByKey = new Map();
      const imgByKey = new Map();

      for (const name of fileNames) {
        // skip preview files in base scanning
        if (isPreviewName(name)) {
          // couple preview
          const cm = name.match(/^couple_(\d{1,})_preview\.webp$/i);
          if (cm) {
            const num = pad3(cm[1]);
            const obj = coupleByNum.get(num) || {};
            obj.preview = name;
            coupleByNum.set(num, obj);
          }
          continue;
        }

        // DOUBLE
        let m = name.match(/^double_(\d{1,})_([01])\.webp$/i);
        if (m) {
          const num = pad3(m[1]);
          const idx = m[2];
          const obj = doubleByNum.get(num) || {};
          obj[idx] = name;
          doubleByNum.set(num, obj);
          continue;
        }

        // DAYS
        m = name.match(/^days_(\d{1,})_(\d{1,2})h\.webp$/i);
        if (m) {
          const num = pad3(m[1]);
          const hour = String(parseInt(m[2],10));
          const hm = daysByNum.get(num) || new Map();
          hm.set(hour, name);
          daysByNum.set(num, hm);
          continue;
        }

        // COUPLE
        m = name.match(/^couple_(\d{1,})\.webp$/i);
        if (m) {
          const num = pad3(m[1]);
          const obj = coupleByNum.get(num) || {};
          obj.single = name;
          coupleByNum.set(num, obj);
          continue;
        }
        m = name.match(/^couple_(\d{1,})_([01])\.webp$/i);
        if (m) {
          const num = pad3(m[1]);
          const idx = m[2];
          const obj = coupleByNum.get(num) || {};
          obj[idx] = name;
          coupleByNum.set(num, obj);
          continue;
        }

        // LIVE / STILL (prefix_num)
        const e = extOf(name);

        if (VIDEO_EXT.includes(e)) {
          if (name.includes("_noSound.")) continue;
          m = name.match(/^(.*)_(\d{1,})\.(mp4|webm|mov)$/i);
          if (m) {
            const prefix = m[1];
            const num = pad3(m[2]);
            mp4ByKey.set(`${prefix}|${num}`, name);
          }
          continue;
        }

        if (IMAGE_EXT.includes(e)) {
          // ignore double/days/couple variants already handled
          if (/^(double_|days_|couple_)/i.test(name)) continue;

          m = name.match(/^(.*)_(\d{1,})\.(webp|png|jpg|jpeg|gif)$/i);
          if (m) {
            const prefix = m[1];
            const num = pad3(m[2]);
            imgByKey.set(`${prefix}|${num}`, name);
          }
          continue;
        }
      }

      let createdAt = Math.floor(Date.now()/1000);
      const items = [];

      // DOUBLE items
      for (const [num, obj] of [...doubleByNum.entries()].sort((a,b)=>a[0].localeCompare(b[0]))) {
        if (!obj["0"] || !obj["1"]) continue;
        items.push({
          id: `${categoryId}_${num}`,
          categoryId,
          isPremium: true,
          createdAt: createdAt++,
          subType: 0,
          type: TYPE.DOUBLE,
          coinToUnlock: 0,
          medias: [
            { url: cdnUrl(folderName, obj["0"]), name: obj["0"], thumbUrl:"", contentType:"image/webp" },
            { url: cdnUrl(folderName, obj["1"]), name: obj["1"], thumbUrl:"", contentType:"image/webp" },
          ],
          _thumb: cdnUrl(folderName, obj["0"])
        });
      }

      // DAYS items
      for (const [num, hm] of [...daysByNum.entries()].sort((a,b)=>a[0].localeCompare(b[0]))) {
        const order = ["6","12","18","24"];
        const medias = [];
        for (const h of order) {
          const f = hm.get(h);
          if (!f) continue;
          medias.push({
            url: cdnUrl(folderName, f),
            name: f,
            thumbUrl: "",
            hour: hourToHHMM(h),
            contentType: "image/webp"
          });
        }
        if (!medias.length) continue;
        items.push({
          id: `${categoryId}_${num}`,
          categoryId,
          isPremium: true,
          createdAt: createdAt++,
          subType: 0,
          type: TYPE.DAYS,
          coinToUnlock: 0,
          medias,
          _thumb: medias[0].url
        });
      }

      // COUPLE items
      for (const [num, obj] of [...coupleByNum.entries()].sort((a,b)=>a[0].localeCompare(b[0]))) {
        const medias = [];
        if (obj.single) {
          const preview = obj.preview ? cdnUrl(folderName, obj.preview) : (previewByBaseImage.get(obj.single) ? cdnUrl(folderName, previewByBaseImage.get(obj.single)) : "");
          medias.push({
            url: cdnUrl(folderName, obj.single),
            name: obj.single,
            thumbUrl: preview || "",
            contentType: "image/webp"
          });
        } else {
          if (obj["0"]) medias.push({ url: cdnUrl(folderName, obj["0"]), name: obj["0"], thumbUrl:"", contentType:"image/webp" });
          if (obj["1"]) medias.push({ url: cdnUrl(folderName, obj["1"]), name: obj["1"], thumbUrl:"", contentType:"image/webp" });
        }
        if (!medias.length) continue;
        items.push({
          id: `${categoryId}_${num}`,
          categoryId,
          isPremium: true,
          createdAt: createdAt++,
          subType: 0,
          type: TYPE.COUPLE,
          coinToUnlock: 0,
          medias,
          _thumb: medias[0].thumbUrl || medias[0].url
        });
      }

      // LIVE / STILL items
      const keys = new Set([...mp4ByKey.keys(), ...imgByKey.keys()]);
      const sortedKeys = [...keys].sort((a,b)=>{
        const na=a.split("|")[1], nb=b.split("|")[1];
        if (na!==nb) return na.localeCompare(nb);
        return a.localeCompare(b);
      });

      for (const key of sortedKeys) {
        const [prefix, num] = key.split("|");
        const mp4 = mp4ByKey.get(key);
        const img = imgByKey.get(key);

        // ID theo browser: n·∫øu prefix == defPrefix th√¨ id = folder_num, c√≤n kh√°c prefix th√¨ v·∫´n d√πng folder_num (ƒë·ªÉ kh√¥ng b·ªã l·ªách) -> b·∫°n mu·ªën gi·ªëng browser (category_num)
        const id = `${categoryId}_${num}`;

        if (mp4) {
          // LIVE
          const previewFile = img ? previewByBaseImage.get(img) : null;
          const previewUrl = previewFile ? cdnUrl(folderName, previewFile) : "";

          items.push({
            id,
            categoryId,
            isPremium: true,
            createdAt: createdAt++,
            subType: 0,
            type: TYPE.LIVE,
            coinToUnlock: 0,
            medias: [
              { url: cdnUrl(folderName, mp4), name: mp4, thumbUrl:"", contentType: contentTypeFromExt(mp4) },
              ...(img ? [{
                url: cdnUrl(folderName, img),
                name: img,
                thumbUrl: previewUrl, // s·∫Ω b·∫≠t/t·∫Øt theo checkbox
                contentType: contentTypeFromExt(img)
              }] : [])
            ],
            _livePreviewUrl: previewUrl,
            _hasPreview: !!previewUrl,
            _thumb: (previewUrl || (img ? cdnUrl(folderName, img) : cdnUrl(folderName, mp4)))
          });
        } else if (img) {
          // STILL
          items.push({
            id,
            categoryId,
            isPremium: true,
            createdAt: createdAt++,
            subType: 0,
            type: TYPE.STILL,
            coinToUnlock: 0,
            medias: [
              { url: cdnUrl(folderName, img), name: img, thumbUrl:"", contentType: contentTypeFromExt(img) }
            ],
            _thumb: cdnUrl(folderName, img)
          });
        }
      }

      // IMPORTANT: n·∫øu tr√πng id trong c√πng folder (do file l·ªói), ƒë·ªÉ Orders v·∫´n render ƒë∆∞·ª£c:
      const seen = new Map();
      for (const it of items) {
        const c = (seen.get(it.id) || 0) + 1;
        seen.set(it.id, c);
        if (c > 1) it.id = `${it.id}_${c}`; // ch·ªâ ƒë·ªÉ UI/Orders ·ªïn, khi export s·∫Ω unique global ti·∫øp
      }

      // sort ·ªïn ƒë·ªãnh theo id
      items.sort((a,b)=>a.id.localeCompare(b.id,"en"));
      return items;
    }

    /** ========= render ========= */
    function renderFolders(){
      elFolders.innerHTML = "";
      const q = elQ.value.trim().toLowerCase();
      const shown = allFolders.filter(f => f.name.toLowerCase().includes(q));
      elFolderCount.textContent = `${shown.length}/${allFolders.length}`;

      for (const f of shown) {
        const div = document.createElement("div");
        div.className = "folder" + (activeFolder === f.name ? " active" : "");
        div.innerHTML = `<span>üìÅ ${f.name}</span><span class="small">open</span>`;
        div.onclick = () => openFolder(f.name);
        elFolders.appendChild(div);
      }
    }

    function renderItems(catId, items){
      elList.innerHTML = "";
      const q = elQ.value.trim().toLowerCase();
      const st = ensureCategoryState(catId);

      const filtered = items.filter(it => it.id.toLowerCase().includes(q));
      elItemCount.textContent = `Items: ${filtered.length}/${items.length}`;

      for (const it of filtered) {
        const row = document.createElement("div");
        row.className = "item";
        row.dataset.id = it.id;

        const thumb = document.createElement("div");
        thumb.className = "thumb";

        // thumb
        const thumbSrc = it._thumb || (it.medias[0]?.url || "");
        if ((it.medias[0]?.contentType || "").startsWith("video/") && it.type === TYPE.LIVE && !it.medias.find(m => (m.contentType||"").startsWith("image/"))) {
          const v = document.createElement("video");
          v.src = thumbSrc;
          v.muted = true; v.playsInline = true; v.loop = true; v.autoplay = true;
          v.preload = "metadata";
          thumb.appendChild(v);
        } else {
          const img = document.createElement("img");
          img.loading = "lazy";
          img.src = thumbSrc;
          img.alt = it.id;
          thumb.appendChild(img);
        }

        const meta = document.createElement("div");
        meta.className = "meta";
        meta.innerHTML = `
          <div class="row" style="justify-content:space-between;">
            <div class="name" title="${it.id}">${it.id}</div>
            <div class="handle" data-handle="1" title="Gi·ªØ ƒë·ªÉ k√©o">‚†ø Drag</div>
          </div>
          <div class="pill">${typeLabel(it.type)} ¬∑ ${it.id}</div>
        `;

        const actions = document.createElement("div");
        actions.className = "actions";

        const openBtn = document.createElement("a");
        openBtn.className = "btn";
        openBtn.textContent = "üîó Open";
        openBtn.href = (it.medias[0]?.url || "#");
        openBtn.target = "_blank";
        openBtn.rel = "noreferrer";
        actions.appendChild(openBtn);

        // LIVE preview toggle (ch·ªâ LIVE)
        if (it.type === TYPE.LIVE) {
          const hasPreview = !!it._hasPreview;
          const defaultChecked = hasPreview ? (st.liveUsePreview[it.id] ?? true) : false;

          const lb = document.createElement("label");
          lb.className = "mut";
          lb.title = "Tick: medias[1].thumbUrl d√πng _preview.webp. B·ªè tick: thumbUrl = \"\"";
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.disabled = !hasPreview;
          cb.checked = defaultChecked;

          cb.onchange = () => {
            st.liveUsePreview[it.id] = cb.checked;

            // update data ngay ƒë·ªÉ generate
            const imgMedia = it.medias.find(m => (m.contentType||"").startsWith("image/"));
            if (imgMedia) imgMedia.thumbUrl = cb.checked ? (it._livePreviewUrl || "") : "";

            // update thumb UI ngay
            const thumbImg = row.querySelector(".thumb img");
            if (thumbImg && imgMedia) {
              thumbImg.src = (imgMedia.thumbUrl || imgMedia.url);
            }
          };

          lb.appendChild(cb);
          lb.appendChild(document.createTextNode(" use preview thumb"));
          actions.appendChild(lb);

          if (!hasPreview) {
            const h = document.createElement("div");
            h.className = "hint";
            h.textContent = "LIVE n√†y kh√¥ng c√≥ _preview.webp";
            actions.appendChild(h);
          }
        }

        meta.appendChild(actions);
        row.appendChild(thumb);
        row.appendChild(meta);
        elList.appendChild(row);
      }

      // enable pointer-drag reorder
      enablePointerSort(elList, catId);
    }

    /** ========= Pointer Sort (k√©o ch·∫Øc ch·∫Øn ƒë∆∞·ª£c) ========= */
    function enablePointerSort(container, catId){
      // remove old listeners b·∫±ng c√°ch clone? (ƒë∆°n gi·∫£n)
      // nh∆∞ng tr√°nh clone v√¨ m·∫•t checkbox state. Ta ch·ªâ g·∫Øn listener l√™n handle t·ª´ng item.
      const items = [...container.querySelectorAll(".item")];

      let draggingEl = null;
      let ghost = null;
      let placeholder = null;
      let startY = 0, startX = 0;
      let offsetX = 0, offsetY = 0;

      function cleanup(){
        if (ghost) ghost.remove();
        if (placeholder) placeholder.remove();
        ghost = null;
        placeholder = null;
        draggingEl = null;
        document.removeEventListener("pointermove", onMove, {passive:false});
        document.removeEventListener("pointerup", onUp, {passive:false});
        syncOrderFromDOM(catId);
      }

      function createGhostFrom(el){
        const r = el.getBoundingClientRect();
        const g = el.cloneNode(true);
        g.classList.add("drag-ghost");
        g.style.left = r.left + r.width/2 + "px";
        g.style.top  = r.top + r.height/2 + "px";
        g.style.width = r.width + "px";
        // remove videos autoplay in ghost (optional)
        g.querySelectorAll("video").forEach(v => { try { v.pause(); } catch{} });
        document.body.appendChild(g);
        return g;
      }

      function createPlaceholder(el){
        const r = el.getBoundingClientRect();
        const p = document.createElement("div");
        p.className = "placeholder";
        p.style.height = r.height + "px";
        return p;
      }

      function getInsertBeforeElement(y){
        const els = [...container.querySelectorAll(".item")].filter(x => x !== draggingEl);
        let closest = null;
        let closestOffset = -Infinity;
        for (const el of els) {
          const box = el.getBoundingClientRect();
          const offset = y - (box.top + box.height/2);
          if (offset < 0 && offset > closestOffset) {
            closestOffset = offset;
            closest = el;
          }
        }
        return closest; // null => append end
      }

      function onMove(e){
        e.preventDefault();
        if (!ghost || !placeholder || !draggingEl) return;

        const x = e.clientX - offsetX;
        const y = e.clientY - offsetY;

        ghost.style.left = (x + ghost.getBoundingClientRect().width/2) + "px";
        ghost.style.top  = (y + ghost.getBoundingClientRect().height/2) + "px";

        const beforeEl = getInsertBeforeElement(e.clientY);
        if (beforeEl) container.insertBefore(placeholder, beforeEl);
        else container.appendChild(placeholder);
      }

      function onUp(e){
        e.preventDefault();
        if (!draggingEl || !placeholder) return cleanup();

        container.insertBefore(draggingEl, placeholder);
        cleanup();
      }

      for (const it of items) {
        const handle = it.querySelector("[data-handle='1']");
        if (!handle) continue;

        handle.onpointerdown = (e) => {
          e.preventDefault();
          e.stopPropagation();
          handle.setPointerCapture(e.pointerId);

          draggingEl = it;
          const rect = it.getBoundingClientRect();

          ghost = createGhostFrom(it);
          placeholder = createPlaceholder(it);

          // compute offsets so ghost follows pointer nicely
          startX = e.clientX; startY = e.clientY;
          offsetX = e.clientX - rect.left;
          offsetY = e.clientY - rect.top;

          // place placeholder where original item was
          container.insertBefore(placeholder, it);
          it.remove(); // remove original, we'll reinsert on drop

          document.addEventListener("pointermove", onMove, {passive:false});
          document.addEventListener("pointerup", onUp, {passive:false});
        };
      }
    }

    /** ========= loaders ========= */
    async function loadFolders() {
      setStatus("Loading folders... (requires token)");
      const data = await fetchJson(ghContentsUrl(ROOT_DIR), true);
      allFolders = data
        .filter(x => x.type === "dir")
        .map(x => ({ name: x.name, path: x.path }))
        .filter(x => /^\d+_/.test(x.name))
        .sort((a,b) => a.name.localeCompare(b.name, "en"));

      renderFolders();
      setStatus("Ready. Click folder ƒë·ªÉ s·∫Øp x·∫øp.");
    }

    async function listFolderFiles(folderName){
      const path = `${ROOT_DIR}/${folderName}`;
      const data = await fetchJson(ghContentsUrl(path), true);
      return data.filter(x => x.type === "file").map(x => x.name);
    }

    async function openFolder(folderName){
      activeFolder = folderName;
      renderFolders();

      elTitle.textContent = `üìÅ ${folderName}`;
      elSubtitle.textContent = `${OWNER}/${REPO}/${ROOT_DIR}/${folderName}`;
      setStatus("Loading files...");

      let items;
      if (folderCache.has(folderName)) {
        items = folderCache.get(folderName).items;
      } else {
        const files = await listFolderFiles(folderName);
        items = buildItemsFromFiles(folderName, files);
        folderCache.set(folderName, { files, items });
      }

      // apply saved live preview choice
      const st = ensureCategoryState(folderName);
      for (const it of items) {
        if (it.type === TYPE.LIVE) {
          const use = (st.liveUsePreview[it.id] ?? true);
          const imgMedia = it.medias.find(m => (m.contentType||"").startsWith("image/"));
          if (imgMedia) imgMedia.thumbUrl = use ? (it._livePreviewUrl || "") : "";
          it._thumb = (imgMedia ? (imgMedia.thumbUrl || imgMedia.url) : it._thumb);
        }
      }

      // apply order list
      const ordered = applyOrder(folderName, items);
      setStatus(`Loaded ${items.length} items.`);
      renderItems(folderName, ordered);
    }

    /** ========= orders.json upload ========= */
    async function uploadOrdersJson(){
      saveOrdersLocal();
      setStatus(`Uploading ${ORDERS_PATH} ...`);
      const txt = JSON.stringify(ordersState, null, 2);
      await upsertTextFile(ORDERS_PATH, txt, `Update orders (${ordersState.updatedAt})`);
      setStatus(`‚úÖ Uploaded ${ORDERS_PATH}`);
      alert("Upload orders.json xong ‚úÖ");
    }

    /** ========= Generate JSON ALL (like browser) ========= */
    function uniqId(desired, used){
      if (!used.has(desired)) { used.add(desired); return desired; }
      let i=2;
      while (used.has(`${desired}_${i}`)) i++;
      const out = `${desired}_${i}`;
      used.add(out);
      return out;
    }

    async function generateAllLikeBrowser(){
      const ok = confirm(
        `Generate JSON ALL (like browser) + upload?\n\nOutput: ${OUTPUT_ALL_JSON}\n\n‚ö†Ô∏è overwrite file c≈©`
      );
      if (!ok) return;

      setStatus("Generating ALL...");

      // ensure current folder order sync before gen
      if (activeFolder) syncOrderFromDOM(activeFolder);

      const used = new Set();
      const out = [];
      let createdAt = Math.floor(Date.now()/1000);

      if (!allFolders.length) await loadFolders();

      for (const f of allFolders) {
        const folderName = f.name;
        setStatus(`Build: ${folderName} ...`);

        let items;
        if (folderCache.has(folderName)) {
          items = folderCache.get(folderName).items;
        } else {
          const files = await listFolderFiles(folderName);
          items = buildItemsFromFiles(folderName, files);
          folderCache.set(folderName, { files, items });
        }

        // apply order and live preview toggle (the ‚Äúorders‚Äù rule)
        const st = ensureCategoryState(folderName);

        for (const it of items) {
          if (it.type === TYPE.LIVE) {
            const use = (st.liveUsePreview[it.id] ?? true);
            const imgMedia = it.medias.find(m => (m.contentType||"").startsWith("image/"));
            if (imgMedia) imgMedia.thumbUrl = use ? (it._livePreviewUrl || "") : "";
          }
        }

        const ordered = applyOrder(folderName, items);

        for (const it of ordered) {
          const id = uniqId(it.id, used);

          // IMPORTANT: export ƒë√∫ng format browser
          const exportItem = {
            id,
            medias: it.medias.map(m => {
              const mm = { ...m };
              // gi·ªØ hour n·∫øu c√≥ (DAYS)
              return mm;
            }),
            categoryId: it.categoryId,
            isPremium: true,
            createdAt: createdAt++,
            subType: 0,
            type: it.type,
            coinToUnlock: 0
          };

          out.push(exportItem);
        }
      }

      const jsonText = JSON.stringify(out, null, 2);

      setStatus(`Uploading ${OUTPUT_ALL_JSON} ...\nItems: ${out.length}`);
      await upsertTextFile(OUTPUT_ALL_JSON, jsonText, `Generate wallpaper.json (${out.length})`);
      setStatus(`‚úÖ Done\nUploaded: ${OUTPUT_ALL_JSON}\nItems: ${out.length}`);
      alert("Generate JSON xong ‚úÖ");
    }

    /** ========= events ========= */
    document.getElementById("saveLocal").onclick = () => { saveOrdersLocal(); alert("Saved orders local ‚úÖ"); };
    document.getElementById("loadLocal").onclick = () => {
      const st = loadOrdersLocal();
      if (!st) return alert("Ch∆∞a c√≥ orders trong localStorage");
      ordersState = st;
      alert("Loaded orders local ‚úÖ");

      if (activeFolder && folderCache.has(activeFolder)) {
        const items = folderCache.get(activeFolder).items;
        const ordered = applyOrder(activeFolder, items);
        renderItems(activeFolder, ordered);
      }
    };
    document.getElementById("uploadOrders").onclick = () => {
      uploadOrdersJson().catch(err => {
        console.error(err);
        alert(String(err?.message || err));
        setStatus(String(err?.message || err));
      });
    };
    document.getElementById("genAll").onclick = () => {
      generateAllLikeBrowser().catch(err => {
        console.error(err);
        alert(String(err?.message || err));
        setStatus(String(err?.message || err));
      });
    };

    elQ.addEventListener("input", () => {
      renderFolders();
      if (activeFolder && folderCache.has(activeFolder)) {
        const items = folderCache.get(activeFolder).items;
        const ordered = applyOrder(activeFolder, items);
        renderItems(activeFolder, ordered);
      }
    });

    /** boot */
    (function boot(){
      const st = loadOrdersLocal();
      if (st) ordersState = st;
      loadFolders().catch(err => setStatus(String(err?.message || err)));
    })();
</script>
</body>
</html>
